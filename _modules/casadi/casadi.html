

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>casadi.casadi &mdash; YAOCPTool 0.3.8 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> YAOCPTool
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../yaocptool.html">yaocptool package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">YAOCPTool</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>casadi.casadi</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for casadi.casadi</h1><div class="highlight"><pre>
<span></span><span class="c1"># This file was automatically generated by SWIG (http://www.swig.org).</span>
<span class="c1"># Version 3.0.11</span>
<span class="c1">#</span>
<span class="c1"># Do not make changes to this file unless you know what you are doing--modify</span>
<span class="c1"># the SWIG interface file instead.</span>





<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">version_info</span> <span class="k">as</span> <span class="n">_swig_python_version_info</span>
<span class="k">if</span> <span class="n">_swig_python_version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">swig_import_helper</span><span class="p">():</span>
        <span class="kn">import</span> <span class="nn">importlib</span>
        <span class="n">pkg</span> <span class="o">=</span> <span class="vm">__name__</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mname</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">pkg</span><span class="p">,</span> <span class="s1">&#39;_casadi&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">mname</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;_casadi&#39;</span><span class="p">)</span>
    <span class="n">_casadi</span> <span class="o">=</span> <span class="n">swig_import_helper</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">swig_import_helper</span>
<span class="k">elif</span> <span class="n">_swig_python_version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">swig_import_helper</span><span class="p">():</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">dirname</span>
        <span class="kn">import</span> <span class="nn">imp</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fp</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="s1">&#39;_casadi&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">_casadi</span>
            <span class="k">return</span> <span class="n">_casadi</span>
        <span class="k">if</span> <span class="n">fp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_mod</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="s1">&#39;_casadi&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_mod</span>
    <span class="n">_casadi</span> <span class="o">=</span> <span class="n">swig_import_helper</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">swig_import_helper</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">_casadi</span>
<span class="k">del</span> <span class="n">_swig_python_version_info</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">_swig_property</span> <span class="o">=</span> <span class="nb">property</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Python &lt; 2.2 doesn&#39;t have &#39;property&#39;.</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">builtins</span> <span class="k">as</span> <span class="nn">__builtin__</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span>

<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;thisown&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;this&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;SwigPyObject&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">class_type</span><span class="o">.</span><span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">static</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_swig_setattr_nondynamic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_type</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;thisown&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">()</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">class_type</span><span class="o">.</span><span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">class_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_swig_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;proxy of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">; </span><span class="si">%s</span><span class="s2"> &gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">strthis</span><span class="p">,)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">_object</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">_newclass</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_object</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">_newclass</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">weakref</span>
    <span class="n">weakref_proxy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span>
<span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
    <span class="n">weakref_proxy</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>


<span class="n">CASADI_INT_TYPE_STR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CASADI_INT_TYPE_STR</span>


<span class="kn">import</span> <span class="nn">contextlib</span>

<span class="k">class</span> <span class="nc">_copyableObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="n">_object</span> <span class="o">=</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">_copyableObject</span>

<span class="n">_swig_repr_default</span> <span class="o">=</span> <span class="n">_swig_repr</span>
<span class="k">def</span> <span class="nf">_swig_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;repr&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">repr</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_swig_repr_default</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_from_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">check_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">check_only</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">IM_from_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">check_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">check_only</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">SX_from_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">check_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">!=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">DM_from_csc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">check_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="s2">&quot;tocsc&quot;</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;csc_matrix&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">check_only</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">indptr</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">False</span>


<span class="n">MNAME</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MNAME</span>
<span class="k">class</span> <span class="nc">SwigPyIterator</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    SwigPyIterator() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SwigPyIterator</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SwigPyIterator</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_SwigPyIterator</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PyObject *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        value(self) -&gt; PyObject *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        incr(self, size_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        decr(self, size_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ptrdiff_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        distance(self, SwigPyIterator x) -&gt; ptrdiff_t</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        equal(self, SwigPyIterator x) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        copy(self) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PyObject *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        next(self) -&gt; PyObject *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PyObject *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __next__(self) -&gt; PyObject *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___next__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">previous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PyObject *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        previous(self) -&gt; PyObject *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_previous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        advance(self, ptrdiff_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_advance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __eq__(self, SwigPyIterator x) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __ne__(self, SwigPyIterator x) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __iadd__(self, ptrdiff_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __isub__(self, ptrdiff_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;swig::SwigPyIterator *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __add__(self, ptrdiff_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ptrdiff_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __sub__(self, SwigPyIterator x) -&gt; ptrdiff_t</span>
<span class="sd">        __sub__(self, ptrdiff_t n) -&gt; SwigPyIterator</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator___sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
<span class="n">SwigPyIterator_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SwigPyIterator_swigregister</span>
<span class="n">SwigPyIterator_swigregister</span><span class="p">(</span><span class="n">SwigPyIterator</span><span class="p">)</span>

<span class="n">L_INT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">L_INT</span>
<span class="n">L_BOOL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">L_BOOL</span>
<span class="n">LL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">LL</span>
<span class="n">LR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">LR</span>
<span class="n">L_DICT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">L_DICT</span>
<span class="n">L_DOUBLE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">L_DOUBLE</span>
<span class="n">L_STR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">L_STR</span>
<span class="n">LABEL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">LABEL</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">!=</span> <span class="s2">&quot;casadi.casadi&quot;</span><span class="p">:</span>
  <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            CasADi is not running from its package context.</span>

<span class="s2">            You probably specified the wrong casadi directory.</span>

<span class="s2">            When setting PYTHONPATH or sys.path.append,</span>
<span class="s2">            take care not to add a trailing &#39;/casadi&#39;.</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">swigtypeconvertor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
  <span class="k">except</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">NoExist</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="k">class</span> <span class="nc">Temp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
      <span class="n">ndarray</span> <span class="o">=</span> <span class="n">NoExist</span>
    <span class="n">np</span> <span class="o">=</span> <span class="n">Temp</span><span class="p">()</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">&quot;[]&quot;</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;np.array(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()]))</span> <span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">swig_typename_convertor_python2cpp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">&quot;dict&quot;</span>
  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">try</span><span class="p">:</span>
  <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">inf</span>
<span class="k">except</span><span class="p">:</span>
  <span class="k">pass</span>

<span class="n">arcsin</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">arccos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">arctan</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">arctan2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">arctanh</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atanh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">arcsinh</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">asinh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">arccosh</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">acosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">veccat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_veccat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vertcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_vertcat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_horzcat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diagcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_diagcat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vvcat</span><span class="p">(</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_veccat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vcat</span><span class="p">(</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_vertcat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hcat</span><span class="p">(</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_horzcat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dcat</span><span class="p">(</span><span class="n">args</span><span class="p">):</span> <span class="k">return</span> <span class="n">_diagcat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NZproxy</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">matrix</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span>

  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">get_nz</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">set_nz</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">nnz</span><span class="p">()</span>

  <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
      <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">PrintableCommon</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    PrintableCommon() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">str</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_name</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">str</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        PrintableCommon()</span>
<span class="sd">        PrintableCommon(PrintableCommon other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_PrintableCommon</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_PrintableCommon</span>
<span class="n">PrintableCommon_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">PrintableCommon_swigregister</span>
<span class="n">PrintableCommon_swigregister</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SharedObject</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      SharedObject implements a reference counting framework similar for efficient</span>


<span class="sd">    and easily-maintained memory management.</span>

<span class="sd">    To use the class, both the SharedObject class (the public class), and the</span>
<span class="sd">    SharedObjectInternal class (the internal class) must be inherited from. It</span>
<span class="sd">    can be done in two different files and together with memory management, this</span>
<span class="sd">    approach provides a clear distinction of which methods of the class are to</span>
<span class="sd">    be considered &quot;public&quot;, i.e. methods for public use that can be considered</span>
<span class="sd">    to remain over time with small changes, and the internal memory.</span>

<span class="sd">    When interfacing a software, which typically includes including some header</span>
<span class="sd">    file, this is best done only in the file where the internal class is</span>
<span class="sd">    defined, to avoid polluting the global namespace and other side effects.</span>

<span class="sd">    The default constructor always means creating a null pointer to an internal</span>
<span class="sd">    class only. To allocate an internal class (this works only when the internal</span>
<span class="sd">    class isn&#39;t abstract), use the constructor with arguments.</span>

<span class="sd">    The copy constructor and the assignment operator perform shallow copies</span>
<span class="sd">    only, to make a deep copy you must use the clone method explicitly. This</span>
<span class="sd">    will give a shared pointer instance.</span>

<span class="sd">    In an inheritance hierarchy, you can cast down automatically, e.g. (</span>
<span class="sd">    SXFunction is a child class of Function): SXFunction derived(...); Function</span>
<span class="sd">    base = derived;</span>

<span class="sd">    To cast up, use the shared_cast template function, which works analogously</span>
<span class="sd">    to dynamic_cast, static_cast, const_cast etc, e.g.: SXFunction derived(...);</span>
<span class="sd">    Function base = derived; SXFunction derived_from_base =</span>
<span class="sd">    shared_cast&lt;SXFunction&gt;(base);</span>

<span class="sd">    A failed shared_cast will result in a null pointer (cf. dynamic_cast)</span>

<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: shared_object.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">class_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get class name.</span>

<span class="sd">        class_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject_class_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a description of the object.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_ptr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [INTERNAL]  Print the pointer to the internal class</span>

<span class="sd">        print_ptr(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject_print_ptr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_null</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is a null pointer?</span>

<span class="sd">        is_null(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject_is_null</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns a number that is unique for a given Node. If the Object does not</span>

<span class="sd">          __hash__(self) -&gt; int</span>

<span class="sd">        point to any node, &quot;0&quot; is returned.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject___hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        SharedObject()</span>
<span class="sd">        SharedObject(SharedObject other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_SharedObject</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_SharedObject</span>
<span class="n">SharedObject_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SharedObject_swigregister</span>
<span class="n">SharedObject_swigregister</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WeakRef</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Weak reference type A weak reference to a SharedObject.</span>



<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: shared_object.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">WeakRef</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">WeakRef</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">shared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::SharedObject&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a shared (owning) reference.</span>

<span class="sd">        shared(self) -&gt; SharedObject</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">WeakRef_shared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if alive.</span>

<span class="sd">        alive(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">WeakRef_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          WeakRef(int dummy)</span>
<span class="sd">          WeakRef(WeakRef other)</span>
<span class="sd">          WeakRef(SharedObject shared)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          WeakRef(WeakRef other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          WeakRef(SharedObject shared)</span>



<span class="sd">        Construct from a shared object (also implicit type conversion)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          WeakRef(int dummy)</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_WeakRef</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_WeakRef</span>
<span class="n">WeakRef_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">WeakRef_swigregister</span>
<span class="n">WeakRef_swigregister</span><span class="p">(</span><span class="n">WeakRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">complement</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Returns the list of all i in [0, size[ not found in supplied list.</span>

<span class="sd">      complement([int] v, int size) -&gt; [int]</span>


<span class="sd">    The supplied vector may contain duplicates and may be non-monotonous The</span>
<span class="sd">    supplied vector will be checked for bounds The result vector is guaranteed</span>
<span class="sd">    to be monotonously increasing</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookupvector</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">      lookupvector([int] v) -&gt; [int]</span>
<span class="sd">      lookupvector([int] v, int size) -&gt; [int]</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      lookupvector([int] v)</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      lookupvector([int] v, int size)</span>



<span class="sd">    Returns a vector for quickly looking up entries of supplied list.</span>

<span class="sd">    lookupvector[i]!=-1 &lt;=&gt; v contains i v[lookupvector[i]] == i &lt;=&gt; v contains</span>
<span class="sd">    i</span>

<span class="sd">    Duplicates are treated by looking up last occurrence</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">lookupvector</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">temporary_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    temporary_file(str prefix, str suffix) -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">temporary_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">normalized_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    normalized_setup()</span>
<span class="sd">    normalized_setup(std::istream &amp; stream)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">normalized_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">normalized_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    normalized_out(float val)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">normalized_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">normalized_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    normalized_in(std::istream &amp; stream, double &amp; ret) -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">normalized_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="n">SWIG_IND1</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SWIG_IND1</span>
<span class="k">class</span> <span class="nc">GenericType</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Generic data type, can hold different types such as bool, casadi_int, string</span>


<span class="sd">    etc.</span>

<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: generic_type.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenericType</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenericType</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize an object.</span>

<span class="sd">        serialize(self, casadi::SerializingStream &amp; s)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenericType_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::GenericType&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; GenericType</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenericType_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GenericType()</span>
<span class="sd">        GenericType(GenericType other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GenericType</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GenericType</span>
<span class="n">GenericType_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenericType_swigregister</span>
<span class="n">GenericType_swigregister</span><span class="p">(</span><span class="n">GenericType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenericType_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::GenericType&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; GenericType</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenericType_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">OP_ASSIGN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ASSIGN</span>
<span class="n">OP_ADD</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ADD</span>
<span class="n">OP_SUB</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SUB</span>
<span class="n">OP_MUL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_MUL</span>
<span class="n">OP_DIV</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_DIV</span>
<span class="n">OP_NEG</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NEG</span>
<span class="n">OP_EXP</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_EXP</span>
<span class="n">OP_LOG</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_LOG</span>
<span class="n">OP_POW</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_POW</span>
<span class="n">OP_CONSTPOW</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_CONSTPOW</span>
<span class="n">OP_SQRT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SQRT</span>
<span class="n">OP_SQ</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SQ</span>
<span class="n">OP_TWICE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_TWICE</span>
<span class="n">OP_SIN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SIN</span>
<span class="n">OP_COS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_COS</span>
<span class="n">OP_TAN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_TAN</span>
<span class="n">OP_ASIN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ASIN</span>
<span class="n">OP_ACOS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ACOS</span>
<span class="n">OP_ATAN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ATAN</span>
<span class="n">OP_LT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_LT</span>
<span class="n">OP_LE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_LE</span>
<span class="n">OP_EQ</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_EQ</span>
<span class="n">OP_NE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NE</span>
<span class="n">OP_NOT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NOT</span>
<span class="n">OP_AND</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_AND</span>
<span class="n">OP_OR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_OR</span>
<span class="n">OP_FLOOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_FLOOR</span>
<span class="n">OP_CEIL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_CEIL</span>
<span class="n">OP_FMOD</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_FMOD</span>
<span class="n">OP_FABS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_FABS</span>
<span class="n">OP_SIGN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SIGN</span>
<span class="n">OP_COPYSIGN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_COPYSIGN</span>
<span class="n">OP_IF_ELSE_ZERO</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_IF_ELSE_ZERO</span>
<span class="n">OP_ERF</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ERF</span>
<span class="n">OP_FMIN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_FMIN</span>
<span class="n">OP_FMAX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_FMAX</span>
<span class="n">OP_INV</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_INV</span>
<span class="n">OP_SINH</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SINH</span>
<span class="n">OP_COSH</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_COSH</span>
<span class="n">OP_TANH</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_TANH</span>
<span class="n">OP_ASINH</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ASINH</span>
<span class="n">OP_ACOSH</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ACOSH</span>
<span class="n">OP_ATANH</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ATANH</span>
<span class="n">OP_ATAN2</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ATAN2</span>
<span class="n">OP_CONST</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_CONST</span>
<span class="n">OP_INPUT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_INPUT</span>
<span class="n">OP_OUTPUT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_OUTPUT</span>
<span class="n">OP_PARAMETER</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_PARAMETER</span>
<span class="n">OP_CALL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_CALL</span>
<span class="n">OP_FIND</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_FIND</span>
<span class="n">OP_LOW</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_LOW</span>
<span class="n">OP_MAP</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_MAP</span>
<span class="n">OP_MTIMES</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_MTIMES</span>
<span class="n">OP_SOLVE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SOLVE</span>
<span class="n">OP_TRANSPOSE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_TRANSPOSE</span>
<span class="n">OP_DETERMINANT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_DETERMINANT</span>
<span class="n">OP_INVERSE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_INVERSE</span>
<span class="n">OP_DOT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_DOT</span>
<span class="n">OP_BILIN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_BILIN</span>
<span class="n">OP_RANK1</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_RANK1</span>
<span class="n">OP_HORZCAT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_HORZCAT</span>
<span class="n">OP_VERTCAT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_VERTCAT</span>
<span class="n">OP_DIAGCAT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_DIAGCAT</span>
<span class="n">OP_HORZSPLIT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_HORZSPLIT</span>
<span class="n">OP_VERTSPLIT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_VERTSPLIT</span>
<span class="n">OP_DIAGSPLIT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_DIAGSPLIT</span>
<span class="n">OP_RESHAPE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_RESHAPE</span>
<span class="n">OP_SUBREF</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SUBREF</span>
<span class="n">OP_SUBASSIGN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SUBASSIGN</span>
<span class="n">OP_GETNONZEROS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_GETNONZEROS</span>
<span class="n">OP_GETNONZEROS_PARAM</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_GETNONZEROS_PARAM</span>
<span class="n">OP_ADDNONZEROS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ADDNONZEROS</span>
<span class="n">OP_ADDNONZEROS_PARAM</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ADDNONZEROS_PARAM</span>
<span class="n">OP_SETNONZEROS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SETNONZEROS</span>
<span class="n">OP_SETNONZEROS_PARAM</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_SETNONZEROS_PARAM</span>
<span class="n">OP_PROJECT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_PROJECT</span>
<span class="n">OP_ASSERTION</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ASSERTION</span>
<span class="n">OP_MONITOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_MONITOR</span>
<span class="n">OP_NORM2</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NORM2</span>
<span class="n">OP_NORM1</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NORM1</span>
<span class="n">OP_NORMINF</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NORMINF</span>
<span class="n">OP_NORMF</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_NORMF</span>
<span class="n">OP_MMIN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_MMIN</span>
<span class="n">OP_MMAX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_MMAX</span>
<span class="n">OP_HORZREPMAT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_HORZREPMAT</span>
<span class="n">OP_HORZREPSUM</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_HORZREPSUM</span>
<span class="n">OP_ERFINV</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_ERFINV</span>
<span class="n">OP_PRINTME</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_PRINTME</span>
<span class="n">OP_LIFT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_LIFT</span>
<span class="n">OP_EINSTEIN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_EINSTEIN</span>
<span class="n">OP_BSPLINE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_BSPLINE</span>
<span class="n">OP_CONVEXIFY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OP_CONVEXIFY</span>
<span class="k">class</span> <span class="nc">SparsityInterfaceCommon</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    SparsityInterfaceCommon() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        SparsityInterfaceCommon()</span>
<span class="sd">        SparsityInterfaceCommon(SparsityInterfaceCommon other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_SparsityInterfaceCommon</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_SparsityInterfaceCommon</span>
<span class="n">SparsityInterfaceCommon_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SparsityInterfaceCommon_swigregister</span>
<span class="n">SparsityInterfaceCommon_swigregister</span><span class="p">(</span><span class="n">SparsityInterfaceCommon</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Sparsity</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      General sparsity class.</span>



<span class="sd">    The storage format is a compressed column storage (CCS) format.  In this</span>
<span class="sd">    format, the structural non-zero elements are stored in column-major order,</span>
<span class="sd">    starting from the upper left corner of the matrix and ending in the lower</span>
<span class="sd">    right corner.</span>

<span class="sd">    In addition to the dimension ( size1(), size2()), (i.e. the number of rows</span>
<span class="sd">    and the number of columns respectively), there are also two vectors of</span>
<span class="sd">    integers:</span>

<span class="sd">    &quot;colind&quot; [length size2()+1], which contains the index to the first non-</span>
<span class="sd">    zero element on or after the corresponding column. All the non-zero elements</span>
<span class="sd">    of a particular i are thus the elements with index el that fulfills:</span>
<span class="sd">    colind[i] &lt;= el &lt; colind[i+1].</span>

<span class="sd">    &quot;row&quot; [same length as the number of non-zero elements, nnz()] The rows for</span>
<span class="sd">    each of the structural non-zeros.</span>

<span class="sd">    Note that with this format, it is cheap to loop over all the non-zero</span>
<span class="sd">    elements of a particular column, at constant time per element, but expensive</span>
<span class="sd">    to jump to access a location (i, j).</span>

<span class="sd">    If the matrix is dense, i.e. length(row) == size1()*size2(), the format</span>
<span class="sd">    reduces to standard dense column major format, which allows access to an</span>
<span class="sd">    arbitrary element in constant time.</span>

<span class="sd">    Since the object is reference counted (it inherits from SharedObject),</span>
<span class="sd">    several matrices are allowed to share the same sparsity pattern.</span>

<span class="sd">    The implementations of methods marked as such in this class has been taken</span>
<span class="sd">    from the CSparse package and modified to fit CasADi data structures and</span>
<span class="sd">    separation of sparsity pattern calculation and numerical evaluation. These</span>
<span class="sd">    functions are Copyright(c) Timothy A. Davis, 2006-2009 and licensed as a</span>
<span class="sd">    derivative work under the GNU LGPL</span>

<span class="sd">    See:   Matrix</span>

<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: sparsity.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sparsity</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sparsity</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a scalar sparsity pattern.</span>

<span class="sd">        scalar(bool dense_scalar) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">scalar</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dense</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a dense rectangular sparsity pattern.</span>

<span class="sd">        dense(int nrow, int ncol) -&gt; Sparsity</span>
<span class="sd">        dense((int,int) rc) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_dense</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">dense</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">dense</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create the sparsity pattern for a unit vector of length n and a nonzero on</span>

<span class="sd">          unit(int n, int el) -&gt; Sparsity</span>

<span class="sd">        position el.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        upper(int n) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_upper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">upper</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        lower(int n) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_lower</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">lower</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create diagonal sparsity pattern.</span>

<span class="sd">        diag(int nrow) -&gt; Sparsity</span>
<span class="sd">        diag((int,int) rc) -&gt; Sparsity</span>
<span class="sd">        diag(int nrow, int ncol) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_diag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">diag</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">band</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        band(int n, int p) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_band</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">band</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">banded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        banded(int n, int p) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_banded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">banded</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">banded</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rowcol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        rowcol([int] row, [int] col, int nrow, int ncol) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_rowcol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">rowcol</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">rowcol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        triplet(int nrow, int ncol, [int] row, [int] col) -&gt; Sparsity</span>
<span class="sd">        triplet(int nrow, int ncol, [int] row, [int] col, bool invert_mapping) -&gt; (Sparsity , [int] OUTPUT)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">triplet</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nonzeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        nonzeros(int nrow, int ncol, [int] nz, bool ind1) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_nonzeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">nonzeros</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">nonzeros</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compressed</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create from a single vector containing the pattern in compressed column</span>

<span class="sd">          compressed([int] v, bool order_rows) -&gt; Sparsity</span>

<span class="sd">        storage format: The format: The first two entries are the number of rows</span>
<span class="sd">        (nrow) and columns (ncol) The next ncol+1 entries are the column offsets</span>
<span class="sd">        (colind). Note that the last element, colind[ncol], gives the number of</span>
<span class="sd">        nonzeros The last colind[ncol] entries are the row indices</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_compressed</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">compressed</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          [DEPRECATED] Correctness of sparsity patterns are checked during</span>

<span class="sd">          sanity_check(self, bool complete)</span>

<span class="sd">        construction</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the diagonal of the matrix/create a diagonal matrix (mapping will</span>

<span class="sd">          get_diag(self) -&gt; (Sparsity , [int] OUTPUT)</span>

<span class="sd">        contain the nonzero mapping) When the input is square, the diagonal elements</span>
<span class="sd">        are returned. If the input is vector-like, a diagonal matrix is constructed</span>
<span class="sd">        with it.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compress a sparsity pattern.</span>

<span class="sd">        compress(self) -&gt; [int]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_equal(self, Sparsity y) -&gt; bool</span>
<span class="sd">        is_equal(self, int nrow, int ncol, [int] colind, [int] row) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __eq__(self, Sparsity y) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __ne__(self, Sparsity y) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_stacked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if pattern is horizontal repeat of another.</span>

<span class="sd">        is_stacked(self, Sparsity y, int n) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_stacked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of rows.</span>

<span class="sd">        size1(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of rows, Octave-style syntax.</span>

<span class="sd">        rows(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of columns.</span>

<span class="sd">        size2(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of columns, Octave-style syntax.</span>

<span class="sd">        columns(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          The total number of elements, including structural zeros, i.e.</span>

<span class="sd">          numel(self) -&gt; int</span>

<span class="sd">        size2()*size1() Beware of overflow.</span>

<span class="sd">        See:   nnz()</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          The percentage of nonzero Equivalent to (100.0 * nnz())/numel(), but avoids</span>

<span class="sd">          density(self) -&gt; float</span>

<span class="sd">        overflow.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the sparsity is empty.</span>

<span class="sd">          is_empty(self, bool both) -&gt; bool</span>


<span class="sd">        A sparsity is considered empty if one of the dimensions is zero (or</span>
<span class="sd">        optionally both dimensions)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the number of (structural) non-zeros.</span>

<span class="sd">          nnz(self) -&gt; int</span>


<span class="sd">        See:   numel()</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Number of non-zeros in the upper triangular half, i.e. the number of</span>

<span class="sd">          nnz_upper(self, bool strictly) -&gt; int</span>

<span class="sd">        elements (i, j) with j&gt;=i.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Number of non-zeros in the lower triangular half, i.e. the number of</span>

<span class="sd">          nnz_lower(self, bool strictly) -&gt; int</span>

<span class="sd">        elements (i, j) with j&lt;=i.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Number of non-zeros on the diagonal, i.e. the number of elements (i, j) with</span>

<span class="sd">          nnz_diag(self) -&gt; int</span>

<span class="sd">        j==i.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">bw_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upper half-bandwidth.</span>

<span class="sd">        bw_upper(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_bw_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">bw_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lower half-bandwidth.</span>

<span class="sd">        bw_lower(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_bw_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the size along a particular dimensions.</span>

<span class="sd">          size(self) -&gt; (int,int)</span>
<span class="sd">          size(self, int axis) -&gt; int</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self)</span>



<span class="sd">        Get the shape.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self, int axis)</span>



<span class="sd">        Get the size along a particular dimensions.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain information about sparsity</span>

<span class="sd">        info(self) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export sparsity pattern to file</span>

<span class="sd">          to_file(self, str filename, str format_hint)</span>


<span class="sd">        Supported formats: .mtx Matrix Market</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        from_file(str filename, str format_hint) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">from_file</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">from_file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Serialize an object.</span>

<span class="sd">          serialize(self) -&gt; str</span>
<span class="sd">          serialize(self, casadi::SerializingStream &amp; s)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          serialize(self, casadi::SerializingStream &amp; s)</span>



<span class="sd">        Serialize an object.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          serialize(self)</span>



<span class="sd">        Serialize.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(std::istream &amp; stream) -&gt; Sparsity</span>
<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; Sparsity</span>
<span class="sd">        deserialize(str s) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a reference to the colindex of column cc (see class description)</span>

<span class="sd">          colind(self) -&gt; [int]</span>
<span class="sd">          colind(self, int cc) -&gt; int</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          colind(self)</span>



<span class="sd">        Get the column index for each column Together with the row-vector, one</span>
<span class="sd">        obtains the sparsity pattern in the column compressed format.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          colind(self, int cc)</span>



<span class="sd">        Get a reference to the colindex of column cc (see class description)</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the row of a non-zero element.</span>

<span class="sd">          row(self) -&gt; [int]</span>
<span class="sd">          row(self, int el) -&gt; int</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          row(self, int el)</span>



<span class="sd">        Get the row of a non-zero element.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          row(self)</span>



<span class="sd">        Get the row for each non-zero entry Together with the column-vector, this</span>
<span class="sd">        vector gives the sparsity of the matrix in sparse triplet format, and</span>
<span class="sd">        together with the colind vector, one obtains the sparsity in column</span>
<span class="sd">        compressed format.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the column for each non-zero entry Together with the row-vector, this</span>

<span class="sd">          get_col(self) -&gt; [int]</span>

<span class="sd">        vector gives the sparsity of the matrix in sparse triplet format, i.e. the</span>
<span class="sd">        column and row for each non-zero elements.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resize.</span>

<span class="sd">        resize(self, int nrow, int ncol)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the index of a non-zero element Add the element if it does not exist and</span>

<span class="sd">          add_nz(self, int rr, int cc) -&gt; int</span>

<span class="sd">        copy object if it&#39;s not unique.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_add_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the pattern has a non-zero at location rr, cc.</span>

<span class="sd">        has_nz(self, int rr, int cc) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_has_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the nonzero index for a set of elements The index vector is used both</span>

<span class="sd">          get_nz(self) -&gt; [int]</span>
<span class="sd">          get_nz(self, int rr, int cc) -&gt; int</span>
<span class="sd">          get_nz(self, [int] rr, [int] cc) -&gt; [int]</span>

<span class="sd">        for input and outputs and must be sorted by increasing nonzero index, i.e.</span>
<span class="sd">        column-wise. Elements not found in the sparsity pattern are set to -1.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get_nz(self, int rr, int cc)</span>



<span class="sd">        Get the index of an existing non-zero element return -1 if the element does</span>
<span class="sd">        not exist.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get_nz(self)</span>



<span class="sd">        Get the nonzero index for a set of elements The index vector is used both</span>
<span class="sd">        for input and outputs and must be sorted by increasing nonzero index, i.e.</span>
<span class="sd">        column-wise. Elements not found in the sparsity pattern are set to -1.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get_nz(self, [int] rr, [int] cc)</span>



<span class="sd">        Get a set of non-zero element return -1 if the element does not exist.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get nonzeros in lower triangular part.</span>

<span class="sd">        get_lower(self) -&gt; [int]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get nonzeros in upper triangular part.</span>

<span class="sd">        get_upper(self) -&gt; [int]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_ccs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity in compressed column storage (CCS) format.</span>

<span class="sd">        get_ccs(self) -&gt; ([int] OUTPUT, [int] OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_ccs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity in compressed row storage (CRS) format.</span>

<span class="sd">        get_crs(self) -&gt; ([int] OUTPUT, [int] OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_triplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity in sparse triplet format.</span>

<span class="sd">        get_triplet(self) -&gt; ([int] OUTPUT, [int] OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_get_triplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a set of elements.</span>

<span class="sd">          sub(self, [int] rr, Sparsity sp, bool ind1) -&gt; (Sparsity , [int] OUTPUT)</span>
<span class="sd">          sub(self, [int] rr, [int] cc, bool ind1) -&gt; (Sparsity , [int] OUTPUT)</span>


<span class="sd">        Returns the sparsity of the corresponding elements, with a mapping such that</span>
<span class="sd">        submatrix[k] = originalmatrix[mapping[k]]</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sub(self, [int] rr, Sparsity sp, bool ind1)</span>



<span class="sd">        Get a set of elements.</span>

<span class="sd">        Returns the sparsity of the corresponding elements, with a mapping such that</span>
<span class="sd">        submatrix[k] = originalmatrix[mapping[k]]</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sub(self, [int] rr, [int] cc, bool ind1)</span>



<span class="sd">        Get a submatrix.</span>

<span class="sd">        Returns the sparsity of the submatrix, with a mapping such that submatrix[k]</span>
<span class="sd">        = originalmatrix[mapping[k]]</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Transpose the matrix and get the reordering of the non-zero entries.</span>

<span class="sd">          transpose(self, bool invert_mapping) -&gt; (Sparsity , [int] OUTPUT)</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        mapping:  the non-zeros of the original matrix for each non-zero of the new</span>
<span class="sd">        matrix</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the sparsity is the transpose of another.</span>

<span class="sd">        is_transpose(self, Sparsity y) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the sparsity is a reshape of another.</span>

<span class="sd">        is_reshape(self, Sparsity y) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Combine two sparsity patterns Returns the new sparsity pattern as well as a</span>

<span class="sd">          combine(self, Sparsity y, bool f0x_is_zero, bool function0_is_zero) -&gt; Sparsity</span>

<span class="sd">        mapping with the same length as the number of non-zero elements The mapping</span>
<span class="sd">        matrix contains the arguments for each nonzero, the first bit indicates if</span>
<span class="sd">        the first argument is nonzero, the second bit indicates if the second</span>
<span class="sd">        argument is nonzero (note that none of, one of or both of the arguments can</span>
<span class="sd">        be nonzero)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Union of two sparsity patterns.</span>

<span class="sd">        unite(self, Sparsity y) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_unite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __add__(self, Sparsity b) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity___add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Intersection of two sparsity patterns Returns the new sparsity pattern as</span>

<span class="sd">          intersect(self, Sparsity y) -&gt; Sparsity</span>

<span class="sd">        well as a mapping with the same length as the number of non-zero elements</span>
<span class="sd">        The value is 1 if the non-zero comes from the first (i.e. this) object, 2 if</span>
<span class="sd">        it is from the second and 3 (i.e. 1 | 2) if from both.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __mul__(self, Sparsity b) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity___mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is subset?</span>

<span class="sd">        is_subset(self, Sparsity rhs) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">pattern_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take the inverse of a sparsity pattern; flip zeros and non-zeros.</span>

<span class="sd">        pattern_inverse(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_pattern_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Enlarge matrix Make the matrix larger by inserting empty rows and columns,</span>

<span class="sd">          enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        keeping the existing non-zeros.</span>

<span class="sd">        For the matrices A to B A(m, n) length(jj)=m , length(ii)=n B(nrow, ncol)</span>

<span class="sd">        A=enlarge(m, n, ii, jj) makes sure that</span>

<span class="sd">        B[jj, ii] == A</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">enlargeRows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enlarge the matrix along the first dimension (i.e. insert rows)</span>

<span class="sd">        enlargeRows(self, int nrow, [int] rr, bool ind1)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_enlargeRows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">enlargeColumns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enlarge the matrix along the second dimension (i.e. insert columns)</span>

<span class="sd">        enlargeColumns(self, int ncol, [int] cc, bool ind1)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_enlargeColumns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">makeDense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a patten dense.</span>

<span class="sd">        makeDense(self) -&gt; (Sparsity , [int] OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_makeDense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Erase elements of a matrix.</span>

<span class="sd">          erase(self, [int] rr, bool ind1) -&gt; [int]</span>
<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1) -&gt; [int]</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>



<span class="sd">        Erase elements of a matrix.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>



<span class="sd">        Erase rows and/or columns of a matrix.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append another sparsity patten vertically (NOTE: only efficient if vector)</span>

<span class="sd">        append(self, Sparsity sp)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">appendColumns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append another sparsity patten horizontally.</span>

<span class="sd">        appendColumns(self, Sparsity sp)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_appendColumns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is scalar?</span>

<span class="sd">        is_scalar(self, bool scalar_and_dense) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is dense?</span>

<span class="sd">        is_dense(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the pattern is a row vector (i.e. size1()==1)</span>

<span class="sd">        is_row(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the pattern is a column vector (i.e. size2()==1)</span>

<span class="sd">        is_column(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the pattern is a row or column vector.</span>

<span class="sd">        is_vector(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is diagonal?</span>

<span class="sd">        is_diag(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is square?</span>

<span class="sd">        is_square(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is symmetric?</span>

<span class="sd">        is_symmetric(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is upper triangular?</span>

<span class="sd">        is_triu(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is lower triangular?</span>

<span class="sd">        is_tril(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_singular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the sparsity-pattern indicates structural singularity.</span>

<span class="sd">        is_singular(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_is_singular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">rowsSequential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Do the rows appear sequentially on each column.</span>

<span class="sd">          rowsSequential(self, bool strictly) -&gt; bool</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        strictly:  if true, then do not allow multiple entries</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_rowsSequential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Remove duplicate entries.</span>

<span class="sd">          removeDuplicates(self) -&gt; [int]</span>


<span class="sd">        The same indices will be removed from the mapping vector, which must have</span>
<span class="sd">        the same length as the number of nonzeros</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_removeDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">etree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Calculate the elimination tree See Direct Methods for Sparse Linear Systems</span>

<span class="sd">          etree(self, bool ata) -&gt; [int]</span>

<span class="sd">        by Davis (2006). If the parameter ata is false, the algorithm is equivalent</span>
<span class="sd">        to MATLAB&#39;s etree(A), except that the indices are zero- based. If ata is</span>
<span class="sd">        true, the algorithm is equivalent to MATLAB&#39;s etree(A, &#39;col&#39;).</span>

<span class="sd">        The implementation is a modified version of cs_etree in CSparse Copyright(c)</span>
<span class="sd">        Timothy A. Davis, 2006-2009 Licensed as a derivative work under the GNU LGPL</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_etree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ldl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Symbolic LDL factorization Returns the sparsity pattern of L^T.</span>

<span class="sd">          ldl(self, bool amd) -&gt; (Sparsity , [int] OUTPUT)</span>


<span class="sd">        The implementation is a modified version of LDL Copyright(c) Timothy A.</span>
<span class="sd">        Davis, 2005-2013 Licensed as a derivative work under the GNU LGPL</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_ldl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">qr_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Symbolic QR factorization Returns the sparsity pattern of V (compact</span>

<span class="sd">          qr_sparse(self, bool amd) -&gt; (Sparsity OUTPUT, Sparsity OUTPUT, [int] OUTPUT, [int] OUTPUT)</span>

<span class="sd">        representation of Q) and R as well as vectors needed for the numerical</span>
<span class="sd">        factorization and solution. The implementation is a modified version of</span>
<span class="sd">        CSparse Copyright(c) Timothy A. Davis, 2006-2009 Licensed as a derivative</span>
<span class="sd">        work under the GNU LGPL.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_qr_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Depth-first search on the adjacency graph of the sparsity See Direct Methods</span>

<span class="sd">          dfs(self, int j, int top, [int] pinv) -&gt; (int , [int] INOUT, [int] INOUT, [bool] INOUT)</span>

<span class="sd">        for Sparse Linear Systems by Davis (2006).</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">scc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Find the strongly connected components of the bigraph defined by the</span>

<span class="sd">          scc(self) -&gt; (int , [int] OUTPUT, [int] OUTPUT)</span>

<span class="sd">        sparsity pattern of a square matrix.</span>

<span class="sd">        See Direct Methods for Sparse Linear Systems by Davis (2006). Returns:</span>
<span class="sd">        Number of components</span>

<span class="sd">        Offset for each components (length: 1 + number of components)</span>

<span class="sd">        Indices for each components, component i has indices index[offset[i]], ...,</span>
<span class="sd">        index[offset[i+1]]</span>

<span class="sd">        In the case that the matrix is symmetric, the result has a particular</span>
<span class="sd">        interpretation: Given a symmetric matrix A and n = A.scc(p, r)</span>

<span class="sd">        =&gt; A[p, p] will appear block-diagonal with n blocks and with the indices of</span>
<span class="sd">        the block boundaries to be found in r.</span>

<span class="sd">        The implementation is a modified version of cs_scc in CSparse Copyright(c)</span>
<span class="sd">        Timothy A. Davis, 2006-2009 Licensed as a derivative work under the GNU LGPL</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">btf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Calculate the block triangular form (BTF) See Direct Methods for Sparse</span>

<span class="sd">          btf(self) -&gt; (int , [int] OUTPUT, [int] OUTPUT, [int] OUTPUT, [int] OUTPUT, [int] OUTPUT, [int] OUTPUT)</span>

<span class="sd">        Linear Systems by Davis (2006).</span>

<span class="sd">        The function computes the Dulmage-Mendelsohn decomposition, which allows you</span>
<span class="sd">        to reorder the rows and columns of a matrix to bring it into block</span>
<span class="sd">        triangular form (BTF).</span>

<span class="sd">        It will not consider the distance of off-diagonal elements to the diagonal:</span>
<span class="sd">        there is no guarantee you will get a block-diagonal matrix if you supply a</span>
<span class="sd">        randomly permuted block-diagonal matrix.</span>

<span class="sd">        If your matrix is symmetrical, this method is of limited use; permutation</span>
<span class="sd">        can make it non-symmetric.</span>

<span class="sd">        See:   scc  The implementation is a modified version of cs_dmperm in CSparse</span>
<span class="sd">        Copyright(c) Timothy A. Davis, 2006-2009 Licensed as a derivative work under</span>
<span class="sd">        the GNU LGPL</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_btf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">amd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Approximate minimal degree preordering Fill-reducing ordering applied to the</span>

<span class="sd">          amd(self) -&gt; [int]</span>

<span class="sd">        sparsity pattern of a linear system prior to factorization. The system must</span>
<span class="sd">        be symmetric, for an unsymmetric matrix A, first form the square of the</span>
<span class="sd">        pattern, A&#39;*A.</span>

<span class="sd">        The implementation is a modified version of cs_amd in CSparse Copyright(c)</span>
<span class="sd">        Timothy A. Davis, 2006-2009 Licensed as a derivative work under the GNU LGPL</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_amd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the location of all non-zero elements as they would appear in a Dense</span>

<span class="sd">          find(self, bool ind1) -&gt; [int]</span>

<span class="sd">        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-</span>
<span class="sd">        zeros.</span>

<span class="sd">        k = A.find() A[k] will contain the elements of A that are non-zero in B</span>

<span class="sd">        Inverse of nonzeros.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">uni_coloring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Perform a unidirectional coloring: A greedy distance-2 coloring algorithm</span>

<span class="sd">          uni_coloring(self, Sparsity AT, int cutoff) -&gt; Sparsity</span>

<span class="sd">        (Algorithm 3.1 in A. H. GEBREMEDHIN, F. MANNE, A. POTHEN)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_uni_coloring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">star_coloring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Perform a star coloring of a symmetric matrix: A greedy distance-2 coloring</span>

<span class="sd">          star_coloring(self, int ordering, int cutoff) -&gt; Sparsity</span>

<span class="sd">        algorithm Algorithm 4.1 in What Color Is Your Jacobian? Graph Coloring for</span>
<span class="sd">        Computing Derivatives A. H. GEBREMEDHIN, F. MANNE, A. POTHEN SIAM Rev.,</span>
<span class="sd">        47(4), 629705 (2006)</span>

<span class="sd">        Ordering options: None (0), largest first (1)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_star_coloring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">star_coloring2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Perform a star coloring of a symmetric matrix: A new greedy distance-2</span>

<span class="sd">          star_coloring2(self, int ordering, int cutoff) -&gt; Sparsity</span>

<span class="sd">        coloring algorithm Algorithm 4.1 in NEW ACYCLIC AND STAR COLORING ALGORITHMS</span>
<span class="sd">        WITH APPLICATION TO COMPUTING HESSIANS A. H. GEBREMEDHIN, A. TARAFDAR, F.</span>
<span class="sd">        MANNE, A. POTHEN SIAM J. SCI. COMPUT. Vol. 29, No. 3, pp. 10421072 (2007)</span>

<span class="sd">        Ordering options: None (0), largest first (1)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_star_coloring2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">largest_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Order the columns by decreasing degree.</span>

<span class="sd">        largest_first(self) -&gt; [int]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_largest_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">pmult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Permute rows and/or columns Multiply the sparsity with a permutation matrix</span>

<span class="sd">          pmult(self, [int] p, bool permute_rows, bool permute_columns, bool invert_permutation) -&gt; Sparsity</span>

<span class="sd">        from the left and/or from the right P * A * trans(P), A * trans(P) or A *</span>
<span class="sd">        trans(P) with P defined by an index vector containing the row for each col.</span>
<span class="sd">        As an alternative, P can be transposed (inverted).</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_pmult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the dimension as a string.</span>

<span class="sd">        dim(self, bool with_nz) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">postfix_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Dimension string as a postfix to a name Rules:</span>

<span class="sd">          postfix_dim(self) -&gt; str</span>


<span class="sd">        Dense and scalar: &quot;&quot;</span>

<span class="sd">        0-by-0: &quot;[]&quot;</span>

<span class="sd">        Dense column vector: &quot;[5]&quot;</span>

<span class="sd">        Dense matrix: &quot;[5x10]&quot;</span>

<span class="sd">        Otherwise: &quot;[5x10,3nz]&quot;</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_postfix_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">repr_el</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Describe the nonzero location k as a string.</span>

<span class="sd">        repr_el(self, int k) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_repr_el</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">spy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a textual representation of sparsity.</span>

<span class="sd">        spy(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_spy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">spy_matlab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Generate a script for Matlab or Octave which visualizes the sparsity using</span>

<span class="sd">          spy_matlab(self, str mfile)</span>

<span class="sd">        the spy command.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_spy_matlab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export matrix in specific language.</span>

<span class="sd">          export_code(self, str lang, dict options)</span>


<span class="sd">        lang: only &#39;matlab&#39; supported for now</span>

<span class="sd">        ::</span>

<span class="sd">           * options:</span>
<span class="sd">           *   inline: Indicates if you want everything on a single line (default: False)</span>
<span class="sd">           *   name: Name of exported variable (default: &#39;sp&#39;)</span>
<span class="sd">           *   as_matrix: Matlab does not have a sparsity object. (default: false)</span>
<span class="sd">          *               With this option true, a numeric matrix will be constructed</span>
<span class="sd">           * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::size_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        hash(self) -&gt; std::size_t</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        test_cast(casadi::SharedObjectInternal const * ptr) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">test_cast</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">test_cast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">kkt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        kkt(Sparsity H, Sparsity J, bool with_x_diag, bool with_lam_g_diag) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_kkt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">kkt</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">kkt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Sparsity</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;serialization&quot;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;serialization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">()}</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size1</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">size2</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DM</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          Sparsity(int dummy)</span>
<span class="sd">          Sparsity((int,int) rc)</span>
<span class="sd">          Sparsity(Sparsity other)</span>
<span class="sd">          Sparsity(int nrow, int ncol)</span>
<span class="sd">          Sparsity(int nrow, int ncol, [int] colind, [int] row, bool order_rows)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Sparsity(Sparsity other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Sparsity(int nrow, int ncol)</span>



<span class="sd">        Pattern with all structural zeros.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Sparsity(int nrow, int ncol, [int] colind, [int] row, bool order_rows)</span>



<span class="sd">        Construct from sparsity pattern vectors given in compressed column storage</span>
<span class="sd">        format.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Sparsity(int dummy)</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Sparsity((int,int) rc)</span>



<span class="sd">        Create a sparse matrix with all structural zeros.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Sparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Sparsity</span>
<span class="n">Sparsity_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_swigregister</span>
<span class="n">Sparsity_swigregister</span><span class="p">(</span><span class="n">Sparsity</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a scalar sparsity pattern.</span>

<span class="sd">    scalar(bool dense_scalar) -&gt; Sparsity</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_dense</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dense rectangular sparsity pattern.</span>

<span class="sd">    dense(int nrow, int ncol) -&gt; Sparsity</span>
<span class="sd">    dense((int,int) rc) -&gt; Sparsity</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_dense</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create the sparsity pattern for a unit vector of length n and a nonzero on</span>

<span class="sd">      unit(int n, int el) -&gt; Sparsity</span>

<span class="sd">    position el.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_upper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    upper(int n) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_upper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_lower</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    lower(int n) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_lower</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_diag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create diagonal sparsity pattern.</span>

<span class="sd">    diag(int nrow) -&gt; Sparsity</span>
<span class="sd">    diag((int,int) rc) -&gt; Sparsity</span>
<span class="sd">    diag(int nrow, int ncol) -&gt; Sparsity</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_diag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_band</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    band(int n, int p) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_band</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_banded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    banded(int n, int p) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_banded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_rowcol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    rowcol([int] row, [int] col, int nrow, int ncol) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_rowcol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    triplet(int nrow, int ncol, [int] row, [int] col) -&gt; Sparsity</span>
<span class="sd">    triplet(int nrow, int ncol, [int] row, [int] col, bool invert_mapping) -&gt; (Sparsity , [int] OUTPUT)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_nonzeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    nonzeros(int nrow, int ncol, [int] nz, bool ind1) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_nonzeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_compressed</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create from a single vector containing the pattern in compressed column</span>

<span class="sd">      compressed([int] v, bool order_rows) -&gt; Sparsity</span>

<span class="sd">    storage format: The format: The first two entries are the number of rows</span>
<span class="sd">    (nrow) and columns (ncol) The next ncol+1 entries are the column offsets</span>
<span class="sd">    (colind). Note that the last element, colind[ncol], gives the number of</span>
<span class="sd">    nonzeros The last colind[ncol] entries are the row indices</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_compressed</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    from_file(str filename, str format_hint) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(std::istream &amp; stream) -&gt; Sparsity</span>
<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; Sparsity</span>
<span class="sd">    deserialize(str s) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    test_cast(casadi::SharedObjectInternal const * ptr) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Sparsity_kkt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    kkt(Sparsity H, Sparsity J, bool with_x_diag, bool with_lam_g_diag) -&gt; Sparsity</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Sparsity_kkt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">hash_combine</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Generate a hash value incrementally (function taken from boost)</span>

<span class="sd">      hash_combine(std::size_t &amp; seed, [int] v)</span>
<span class="sd">      hash_combine(std::size_t &amp; seed, casadi_int const * v, std::size_t sz)</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      hash_combine(std::size_t &amp; seed, [int] v)</span>



<span class="sd">    Generate a hash value incrementally (function taken from boost)</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      hash_combine(std::size_t &amp; seed, casadi_int const * v, std::size_t sz)</span>



<span class="sd">    Generate a hash value incrementally, array.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">hash_combine</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hash_sparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::size_t&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">      hash_sparsity(int nrow, int ncol, casadi_int const * colind, casadi_int const * row) -&gt; std::size_t</span>
<span class="sd">      hash_sparsity(int nrow, int ncol, [int] colind, [int] row) -&gt; std::size_t</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      hash_sparsity(int nrow, int ncol, casadi_int const * colind, casadi_int const * row)</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      hash_sparsity(int nrow, int ncol, [int] colind, [int] row)</span>



<span class="sd">    Hash a sparsity pattern.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">hash_sparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Slice</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Class representing a Slice.</span>



<span class="sd">    Note that Python or Octave do not need to use this class. They can just use</span>
<span class="sd">    slicing utility from the host language ( M[0:6] in Python, M(1:7) )</span>

<span class="sd">    C++ includes: slice.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_start_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_start_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;stop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_stop_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_stop_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_step_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_step_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a vector of indices (nested slice)</span>

<span class="sd">          all(self) -&gt; [int]</span>
<span class="sd">          all(self, int len, bool ind1) -&gt; [int]</span>
<span class="sd">          all(self, Slice outer, int len) -&gt; [int]</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          all(self)</span>
<span class="sd">          all(self, int len, bool ind1)</span>



<span class="sd">        Get a vector of indices.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          all(self, Slice outer, int len)</span>



<span class="sd">        Get a vector of indices (nested slice)</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;size_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of elements.</span>

<span class="sd">        size(self) -&gt; size_t</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if slice is empty.</span>

<span class="sd">        is_empty(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the slice a scalar.</span>

<span class="sd">        is_scalar(self, int len) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get scalar (if is_scalar)</span>

<span class="sd">        scalar(self, int len) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __eq__(self, Slice other) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __ne__(self, Slice other) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Slice&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply concrete length.</span>

<span class="sd">        apply(self, int len, bool ind1) -&gt; Slice</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Slice&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __sub__(self, int i) -&gt; Slice</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice___sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Slice&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __mul__(self, int i) -&gt; Slice</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice___mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get name of the class.</span>

<span class="sd">        type_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a description of the object.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain information</span>

<span class="sd">        info(self) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize an object.</span>

<span class="sd">        serialize(self, casadi::SerializingStream &amp; s)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Slice&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; Slice</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          Slice()</span>
<span class="sd">          Slice(int i, bool ind1)</span>
<span class="sd">          Slice(Slice other)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Slice()</span>



<span class="sd">        Default constructor - all elements.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Slice(Slice other)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>
<span class="sd">          Slice(int start, int stop, int step)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Slice(int start, int stop, int step)</span>



<span class="sd">        A slice.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Slice(int i, bool ind1)</span>



<span class="sd">        A single element (explicit to avoid ambiguity with IM overload.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Slice</span>
<span class="n">Slice_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_swigregister</span>
<span class="n">Slice_swigregister</span><span class="p">(</span><span class="n">Slice</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Slice_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Slice&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; Slice</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Slice_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Slice&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct from an index vector (requires is_slice(v) to be true)</span>

<span class="sd">    to_slice([int] v, bool ind1) -&gt; Slice</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">to_slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_slice2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; casadi::Slice,casadi::Slice &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Construct nested slices from an index vector (requires is_slice2(v) to be</span>

<span class="sd">      to_slice2([int] v) -&gt; std::pair&lt; casadi::Slice,casadi::Slice &gt;</span>

<span class="sd">    true)</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">to_slice2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if an index vector can be represented more efficiently as a slice.</span>

<span class="sd">    is_slice([int] v, bool ind1) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">is_slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_slice2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Check if an index vector can be represented more efficiently as two nested</span>

<span class="sd">      is_slice2([int] v) -&gt; bool</span>

<span class="sd">    slices.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">is_slice2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">GenericMatrixCommon</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Matrix base class.</span>

<span class="sd">      GenericMatrixCommon() -&gt; </span>


<span class="sd">    This is a common base class for MX and Matrix&lt;&gt;, introducing a uniform</span>
<span class="sd">    syntax and implementing common functionality using the curiously recurring</span>
<span class="sd">    template pattern (CRTP) idiom.  The class is designed with the idea that</span>
<span class="sd">    &quot;everything is a matrix&quot;, that is, also scalars and vectors. This</span>
<span class="sd">    philosophy makes it easy to use and to interface in particularly with Python</span>
<span class="sd">    and Matlab/Octave.  The syntax tries to stay as close as possible to the</span>
<span class="sd">    ublas syntax when it comes to vector/matrix operations.  Index starts with</span>
<span class="sd">    0. Index vec happens as follows: (rr, cc) -&gt; k = rr+cc*size1() Vectors are</span>
<span class="sd">    column vectors.  The storage format is Compressed Column Storage (CCS),</span>
<span class="sd">    similar to that used for sparse matrices in Matlab, but unlike this format,</span>
<span class="sd">    we do allow for elements to be structurally non-zero but numerically zero.</span>
<span class="sd">    The sparsity pattern, which is reference counted and cached, can be accessed</span>
<span class="sd">    with Sparsity&amp; sparsity() Joel Andersson</span>

<span class="sd">    C++ includes: generic_matrix.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">__mldivide__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mldivide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmldivide__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mldivide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mrdivide__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mrdivide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmrdivide__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mrdivide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mpower__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mpower</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmpower__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mpower</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GenericMatrixCommon()</span>
<span class="sd">        GenericMatrixCommon(GenericMatrixCommon other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GenericMatrixCommon</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GenericMatrixCommon</span>
<span class="n">GenericMatrixCommon_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenericMatrixCommon_swigregister</span>
<span class="n">GenericMatrixCommon_swigregister</span><span class="p">(</span><span class="n">GenericMatrixCommon</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">index_interp1d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    index_interp1d([float] x, float xq, bool equidistant) -&gt; float</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">index_interp1d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">GenDM</span><span class="p">(</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>





<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenDM</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenDM</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of (structural) non-zero elements.</span>

<span class="sd">        nnz(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of non-zeros in the lower triangular half.</span>

<span class="sd">        nnz_lower(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of non-zeros in the upper triangular half.</span>

<span class="sd">        nnz_upper(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get get the number of non-zeros on the diagonal.</span>

<span class="sd">        nnz_diag(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of elements.</span>

<span class="sd">        numel(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the first dimension (i.e. number of rows)</span>

<span class="sd">        size1(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of rows, Octave-style syntax.</span>

<span class="sd">        rows(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the second dimension (i.e. number of columns)</span>

<span class="sd">        size2(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of columns, Octave-style syntax.</span>

<span class="sd">        columns(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get string representation of dimensions. The representation is e.g. &quot;4x5&quot;</span>

<span class="sd">          dim(self, bool with_nz) -&gt; str</span>

<span class="sd">        or &quot;4x5,10nz&quot;.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the size along a particular dimensions.</span>

<span class="sd">          size(self) -&gt; (int,int)</span>
<span class="sd">          size(self, int axis) -&gt; int</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self)</span>



<span class="sd">        Get the shape.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self, int axis)</span>



<span class="sd">        Get the size along a particular dimensions.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the sparsity is empty, i.e. if one of the dimensions is zero (or</span>

<span class="sd">          is_empty(self, bool both) -&gt; bool</span>

<span class="sd">        optionally both dimensions)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is dense.</span>

<span class="sd">        is_dense(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is scalar.</span>

<span class="sd">        is_scalar(self, bool scalar_and_dense) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is square.</span>

<span class="sd">        is_square(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a row or column vector.</span>

<span class="sd">        is_vector(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a row vector (i.e. size1()==1)</span>

<span class="sd">        is_row(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a column vector (i.e. size2()==1)</span>

<span class="sd">        is_column(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is upper triangular.</span>

<span class="sd">        is_triu(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is lower triangular.</span>

<span class="sd">        is_tril(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern. See the Sparsity class for details.</span>

<span class="sd">        row(self) -&gt; [int]</span>
<span class="sd">        row(self, int el) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern. See the Sparsity class for details.</span>

<span class="sd">        colind(self) -&gt; [int]</span>
<span class="sd">        colind(self, int col) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a vector of length r of vectors of length p with nrow-by-ncol</span>

<span class="sd">          sym(str name, int nrow, int ncol) -&gt; DM</span>
<span class="sd">          sym(str name, (int,int) rc) -&gt; DM</span>
<span class="sd">          sym(str name, Sparsity sp) -&gt; DM</span>
<span class="sd">          sym(str name, Sparsity sp, int p) -&gt; [DM]</span>
<span class="sd">          sym(str name, int nrow, int ncol, int p) -&gt; [DM]</span>
<span class="sd">          sym(str name, Sparsity sp, int p, int r) -&gt; [[DM]]</span>
<span class="sd">          sym(str name, int nrow, int ncol, int p, int r) -&gt; [[DM]]</span>

<span class="sd">        symbolic primitives.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, (int,int) rc)</span>



<span class="sd">        Construct a symbolic primitive with given dimensions.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol, int p)</span>



<span class="sd">        Create a vector of length p with nrow-by-ncol symbolic primitives.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp, int p, int r)</span>



<span class="sd">        Create a vector of length r of vectors of length p with symbolic primitives</span>
<span class="sd">        with given sparsity.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol, int p, int r)</span>



<span class="sd">        Create a vector of length r of vectors of length p with nrow-by-ncol</span>
<span class="sd">        symbolic primitives.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp)</span>



<span class="sd">        Create symbolic primitive with a given sparsity pattern.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol)</span>



<span class="sd">        Create an nrow-by-ncol symbolic primitive.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp, int p)</span>



<span class="sd">        Create a vector of length p with with matrices with symbolic primitives of</span>
<span class="sd">        given sparsity.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">sym</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">          zeros(int nrow, int ncol) -&gt; DM</span>
<span class="sd">          zeros((int,int) rc) -&gt; DM</span>
<span class="sd">          zeros(Sparsity sp) -&gt; DM</span>

<span class="sd">        zero.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">zeros</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">          ones(int nrow, int ncol) -&gt; DM</span>
<span class="sd">          ones((int,int) rc) -&gt; DM</span>
<span class="sd">          ones(Sparsity sp) -&gt; DM</span>

<span class="sd">        one.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">ones</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GenDM()</span>
<span class="sd">        GenDM(GenDM other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GenDM</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GenDM</span>
<span class="n">GenDM_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_swigregister</span>
<span class="n">GenDM_swigregister</span><span class="p">(</span><span class="n">GenDM</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenDM_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a vector of length r of vectors of length p with nrow-by-ncol</span>

<span class="sd">      sym(str name, int nrow, int ncol) -&gt; DM</span>
<span class="sd">      sym(str name, (int,int) rc) -&gt; DM</span>
<span class="sd">      sym(str name, Sparsity sp) -&gt; DM</span>
<span class="sd">      sym(str name, Sparsity sp, int p) -&gt; [DM]</span>
<span class="sd">      sym(str name, int nrow, int ncol, int p) -&gt; [DM]</span>
<span class="sd">      sym(str name, Sparsity sp, int p, int r) -&gt; [[DM]]</span>
<span class="sd">      sym(str name, int nrow, int ncol, int p, int r) -&gt; [[DM]]</span>

<span class="sd">    symbolic primitives.</span>



<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, (int,int) rc)</span>



<span class="sd">    Construct a symbolic primitive with given dimensions.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol, int p)</span>



<span class="sd">    Create a vector of length p with nrow-by-ncol symbolic primitives.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp, int p, int r)</span>



<span class="sd">    Create a vector of length r of vectors of length p with symbolic primitives</span>
<span class="sd">    with given sparsity.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol, int p, int r)</span>



<span class="sd">    Create a vector of length r of vectors of length p with nrow-by-ncol</span>
<span class="sd">    symbolic primitives.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp)</span>



<span class="sd">    Create symbolic primitive with a given sparsity pattern.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol)</span>



<span class="sd">    Create an nrow-by-ncol symbolic primitive.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp, int p)</span>



<span class="sd">    Create a vector of length p with with matrices with symbolic primitives of</span>
<span class="sd">    given sparsity.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenDM_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">      zeros(int nrow, int ncol) -&gt; DM</span>
<span class="sd">      zeros((int,int) rc) -&gt; DM</span>
<span class="sd">      zeros(Sparsity sp) -&gt; DM</span>

<span class="sd">    zero.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenDM_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">      ones(int nrow, int ncol) -&gt; DM</span>
<span class="sd">      ones((int,int) rc) -&gt; DM</span>
<span class="sd">      ones(Sparsity sp) -&gt; DM</span>

<span class="sd">    one.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenDM_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GenSX</span><span class="p">(</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>





<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenSX</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenSX</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of (structural) non-zero elements.</span>

<span class="sd">        nnz(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of non-zeros in the lower triangular half.</span>

<span class="sd">        nnz_lower(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of non-zeros in the upper triangular half.</span>

<span class="sd">        nnz_upper(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get get the number of non-zeros on the diagonal.</span>

<span class="sd">        nnz_diag(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of elements.</span>

<span class="sd">        numel(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the first dimension (i.e. number of rows)</span>

<span class="sd">        size1(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of rows, Octave-style syntax.</span>

<span class="sd">        rows(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the second dimension (i.e. number of columns)</span>

<span class="sd">        size2(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of columns, Octave-style syntax.</span>

<span class="sd">        columns(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get string representation of dimensions. The representation is e.g. &quot;4x5&quot;</span>

<span class="sd">          dim(self, bool with_nz) -&gt; str</span>

<span class="sd">        or &quot;4x5,10nz&quot;.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the size along a particular dimensions.</span>

<span class="sd">          size(self) -&gt; (int,int)</span>
<span class="sd">          size(self, int axis) -&gt; int</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self)</span>



<span class="sd">        Get the shape.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self, int axis)</span>



<span class="sd">        Get the size along a particular dimensions.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the sparsity is empty, i.e. if one of the dimensions is zero (or</span>

<span class="sd">          is_empty(self, bool both) -&gt; bool</span>

<span class="sd">        optionally both dimensions)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is dense.</span>

<span class="sd">        is_dense(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is scalar.</span>

<span class="sd">        is_scalar(self, bool scalar_and_dense) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is square.</span>

<span class="sd">        is_square(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a row or column vector.</span>

<span class="sd">        is_vector(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a row vector (i.e. size1()==1)</span>

<span class="sd">        is_row(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a column vector (i.e. size2()==1)</span>

<span class="sd">        is_column(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is upper triangular.</span>

<span class="sd">        is_triu(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is lower triangular.</span>

<span class="sd">        is_tril(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern. See the Sparsity class for details.</span>

<span class="sd">        row(self) -&gt; [int]</span>
<span class="sd">        row(self, int el) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern. See the Sparsity class for details.</span>

<span class="sd">        colind(self) -&gt; [int]</span>
<span class="sd">        colind(self, int col) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a vector of length r of vectors of length p with nrow-by-ncol</span>

<span class="sd">          sym(str name, int nrow, int ncol) -&gt; SX</span>
<span class="sd">          sym(str name, (int,int) rc) -&gt; SX</span>
<span class="sd">          sym(str name, Sparsity sp) -&gt; SX</span>
<span class="sd">          sym(str name, Sparsity sp, int p) -&gt; [SX]</span>
<span class="sd">          sym(str name, int nrow, int ncol, int p) -&gt; [SX]</span>
<span class="sd">          sym(str name, Sparsity sp, int p, int r) -&gt; [[SX]]</span>
<span class="sd">          sym(str name, int nrow, int ncol, int p, int r) -&gt; [[SX]]</span>

<span class="sd">        symbolic primitives.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, (int,int) rc)</span>



<span class="sd">        Construct a symbolic primitive with given dimensions.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol, int p)</span>



<span class="sd">        Create a vector of length p with nrow-by-ncol symbolic primitives.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp, int p, int r)</span>



<span class="sd">        Create a vector of length r of vectors of length p with symbolic primitives</span>
<span class="sd">        with given sparsity.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol, int p, int r)</span>



<span class="sd">        Create a vector of length r of vectors of length p with nrow-by-ncol</span>
<span class="sd">        symbolic primitives.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp)</span>



<span class="sd">        Create symbolic primitive with a given sparsity pattern.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol)</span>



<span class="sd">        Create an nrow-by-ncol symbolic primitive.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp, int p)</span>



<span class="sd">        Create a vector of length p with with matrices with symbolic primitives of</span>
<span class="sd">        given sparsity.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">sym</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">          zeros(int nrow, int ncol) -&gt; SX</span>
<span class="sd">          zeros((int,int) rc) -&gt; SX</span>
<span class="sd">          zeros(Sparsity sp) -&gt; SX</span>

<span class="sd">        zero.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">zeros</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">          ones(int nrow, int ncol) -&gt; SX</span>
<span class="sd">          ones((int,int) rc) -&gt; SX</span>
<span class="sd">          ones(Sparsity sp) -&gt; SX</span>

<span class="sd">        one.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">ones</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GenSX()</span>
<span class="sd">        GenSX(GenSX other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GenSX</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GenSX</span>
<span class="n">GenSX_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_swigregister</span>
<span class="n">GenSX_swigregister</span><span class="p">(</span><span class="n">GenSX</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenSX_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a vector of length r of vectors of length p with nrow-by-ncol</span>

<span class="sd">      sym(str name, int nrow, int ncol) -&gt; SX</span>
<span class="sd">      sym(str name, (int,int) rc) -&gt; SX</span>
<span class="sd">      sym(str name, Sparsity sp) -&gt; SX</span>
<span class="sd">      sym(str name, Sparsity sp, int p) -&gt; [SX]</span>
<span class="sd">      sym(str name, int nrow, int ncol, int p) -&gt; [SX]</span>
<span class="sd">      sym(str name, Sparsity sp, int p, int r) -&gt; [[SX]]</span>
<span class="sd">      sym(str name, int nrow, int ncol, int p, int r) -&gt; [[SX]]</span>

<span class="sd">    symbolic primitives.</span>



<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, (int,int) rc)</span>



<span class="sd">    Construct a symbolic primitive with given dimensions.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol, int p)</span>



<span class="sd">    Create a vector of length p with nrow-by-ncol symbolic primitives.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp, int p, int r)</span>



<span class="sd">    Create a vector of length r of vectors of length p with symbolic primitives</span>
<span class="sd">    with given sparsity.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol, int p, int r)</span>



<span class="sd">    Create a vector of length r of vectors of length p with nrow-by-ncol</span>
<span class="sd">    symbolic primitives.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp)</span>



<span class="sd">    Create symbolic primitive with a given sparsity pattern.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol)</span>



<span class="sd">    Create an nrow-by-ncol symbolic primitive.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp, int p)</span>



<span class="sd">    Create a vector of length p with with matrices with symbolic primitives of</span>
<span class="sd">    given sparsity.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenSX_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">      zeros(int nrow, int ncol) -&gt; SX</span>
<span class="sd">      zeros((int,int) rc) -&gt; SX</span>
<span class="sd">      zeros(Sparsity sp) -&gt; SX</span>

<span class="sd">    zero.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenSX_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">      ones(int nrow, int ncol) -&gt; SX</span>
<span class="sd">      ones((int,int) rc) -&gt; SX</span>
<span class="sd">      ones(Sparsity sp) -&gt; SX</span>

<span class="sd">    one.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenSX_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GenMX</span><span class="p">(</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>





<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenMX</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericMatrixCommon</span><span class="p">,</span> <span class="n">SparsityInterfaceCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenMX</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of (structural) non-zero elements.</span>

<span class="sd">        nnz(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of non-zeros in the lower triangular half.</span>

<span class="sd">        nnz_lower(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_nnz_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of non-zeros in the upper triangular half.</span>

<span class="sd">        nnz_upper(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_nnz_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get get the number of non-zeros on the diagonal.</span>

<span class="sd">        nnz_diag(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_nnz_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of elements.</span>

<span class="sd">        numel(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_numel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the first dimension (i.e. number of rows)</span>

<span class="sd">        size1(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_size1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of rows, Octave-style syntax.</span>

<span class="sd">        rows(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the second dimension (i.e. number of columns)</span>

<span class="sd">        size2(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_size2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of columns, Octave-style syntax.</span>

<span class="sd">        columns(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get string representation of dimensions. The representation is e.g. &quot;4x5&quot;</span>

<span class="sd">          dim(self, bool with_nz) -&gt; str</span>

<span class="sd">        or &quot;4x5,10nz&quot;.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the size along a particular dimensions.</span>

<span class="sd">          size(self) -&gt; (int,int)</span>
<span class="sd">          size(self, int axis) -&gt; int</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self)</span>



<span class="sd">        Get the shape.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          size(self, int axis)</span>



<span class="sd">        Get the size along a particular dimensions.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the sparsity is empty, i.e. if one of the dimensions is zero (or</span>

<span class="sd">          is_empty(self, bool both) -&gt; bool</span>

<span class="sd">        optionally both dimensions)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is dense.</span>

<span class="sd">        is_dense(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is scalar.</span>

<span class="sd">        is_scalar(self, bool scalar_and_dense) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix expression is square.</span>

<span class="sd">        is_square(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a row or column vector.</span>

<span class="sd">        is_vector(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a row vector (i.e. size1()==1)</span>

<span class="sd">        is_row(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is a column vector (i.e. size2()==1)</span>

<span class="sd">        is_column(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is upper triangular.</span>

<span class="sd">        is_triu(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_triu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix is lower triangular.</span>

<span class="sd">        is_tril(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_is_tril</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern. See the Sparsity class for details.</span>

<span class="sd">        row(self) -&gt; [int]</span>
<span class="sd">        row(self, int el) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern. See the Sparsity class for details.</span>

<span class="sd">        colind(self) -&gt; [int]</span>
<span class="sd">        colind(self, int col) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_colind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity pattern.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a vector of length r of vectors of length p with nrow-by-ncol</span>

<span class="sd">          sym(str name, int nrow, int ncol) -&gt; MX</span>
<span class="sd">          sym(str name, (int,int) rc) -&gt; MX</span>
<span class="sd">          sym(str name, Sparsity sp) -&gt; MX</span>
<span class="sd">          sym(str name, Sparsity sp, int p) -&gt; [MX]</span>
<span class="sd">          sym(str name, int nrow, int ncol, int p) -&gt; [MX]</span>
<span class="sd">          sym(str name, Sparsity sp, int p, int r) -&gt; [[MX]]</span>
<span class="sd">          sym(str name, int nrow, int ncol, int p, int r) -&gt; [[MX]]</span>

<span class="sd">        symbolic primitives.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, (int,int) rc)</span>



<span class="sd">        Construct a symbolic primitive with given dimensions.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol, int p)</span>



<span class="sd">        Create a vector of length p with nrow-by-ncol symbolic primitives.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp, int p, int r)</span>



<span class="sd">        Create a vector of length r of vectors of length p with symbolic primitives</span>
<span class="sd">        with given sparsity.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol, int p, int r)</span>



<span class="sd">        Create a vector of length r of vectors of length p with nrow-by-ncol</span>
<span class="sd">        symbolic primitives.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp)</span>



<span class="sd">        Create symbolic primitive with a given sparsity pattern.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, int nrow, int ncol)</span>



<span class="sd">        Create an nrow-by-ncol symbolic primitive.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          sym(str name, Sparsity sp, int p)</span>



<span class="sd">        Create a vector of length p with with matrices with symbolic primitives of</span>
<span class="sd">        given sparsity.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">sym</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">          zeros(int nrow, int ncol) -&gt; MX</span>
<span class="sd">          zeros((int,int) rc) -&gt; MX</span>
<span class="sd">          zeros(Sparsity sp) -&gt; MX</span>

<span class="sd">        zero.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">zeros</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">          ones(int nrow, int ncol) -&gt; MX</span>
<span class="sd">          ones((int,int) rc) -&gt; MX</span>
<span class="sd">          ones(Sparsity sp) -&gt; MX</span>

<span class="sd">        one.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">ones</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">ones</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GenMX()</span>
<span class="sd">        GenMX(GenMX other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GenMX</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GenMX</span>
<span class="n">GenMX_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_swigregister</span>
<span class="n">GenMX_swigregister</span><span class="p">(</span><span class="n">GenMX</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenMX_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a vector of length r of vectors of length p with nrow-by-ncol</span>

<span class="sd">      sym(str name, int nrow, int ncol) -&gt; MX</span>
<span class="sd">      sym(str name, (int,int) rc) -&gt; MX</span>
<span class="sd">      sym(str name, Sparsity sp) -&gt; MX</span>
<span class="sd">      sym(str name, Sparsity sp, int p) -&gt; [MX]</span>
<span class="sd">      sym(str name, int nrow, int ncol, int p) -&gt; [MX]</span>
<span class="sd">      sym(str name, Sparsity sp, int p, int r) -&gt; [[MX]]</span>
<span class="sd">      sym(str name, int nrow, int ncol, int p, int r) -&gt; [[MX]]</span>

<span class="sd">    symbolic primitives.</span>



<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, (int,int) rc)</span>



<span class="sd">    Construct a symbolic primitive with given dimensions.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol, int p)</span>



<span class="sd">    Create a vector of length p with nrow-by-ncol symbolic primitives.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp, int p, int r)</span>



<span class="sd">    Create a vector of length r of vectors of length p with symbolic primitives</span>
<span class="sd">    with given sparsity.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol, int p, int r)</span>



<span class="sd">    Create a vector of length r of vectors of length p with nrow-by-ncol</span>
<span class="sd">    symbolic primitives.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp)</span>



<span class="sd">    Create symbolic primitive with a given sparsity pattern.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, int nrow, int ncol)</span>



<span class="sd">    Create an nrow-by-ncol symbolic primitive.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      sym(str name, Sparsity sp, int p)</span>



<span class="sd">    Create a vector of length p with with matrices with symbolic primitives of</span>
<span class="sd">    given sparsity.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenMX_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">      zeros(int nrow, int ncol) -&gt; MX</span>
<span class="sd">      zeros((int,int) rc) -&gt; MX</span>
<span class="sd">      zeros(Sparsity sp) -&gt; MX</span>

<span class="sd">    zero.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GenMX_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a dense matrix or a matrix with specified sparsity with all entries</span>

<span class="sd">      ones(int nrow, int ncol) -&gt; MX</span>
<span class="sd">      ones((int,int) rc) -&gt; MX</span>
<span class="sd">      ones(Sparsity sp) -&gt; MX</span>

<span class="sd">    one.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenMX_ones</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GenericExpressionCommon</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    GenericExpressionCommon() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_hash</span><span class="p">()</span>
      <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SharedObject</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mtimes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mtimes</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">minus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">minus</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rdivide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rdivide</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rdivide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rdivide</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rlt__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rle__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rgt__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rge__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__req__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rne__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__arctan2__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rarctan2__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__fmin__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rfmin__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__fmax__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rfmax__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logic_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logic_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">arcsin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">arctan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">arcsinh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">asinh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">arccosh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">acosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">arctanh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atanh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__copysign__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rcopysign__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">copysign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rcopysign</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__constpow__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">constpow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rconstpow__</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">constpow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">constpow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">constpow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rconstpow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">constpow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GenericExpressionCommon()</span>
<span class="sd">        GenericExpressionCommon(GenericExpressionCommon other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GenericExpressionCommon</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GenericExpressionCommon</span>
<span class="n">GenericExpressionCommon_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GenericExpressionCommon_swigregister</span>
<span class="n">GenericExpressionCommon_swigregister</span><span class="p">(</span><span class="n">GenericExpressionCommon</span><span class="p">)</span>

<span class="n">IS_GLOBAL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_GLOBAL</span>
<span class="n">IS_MEMBER</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_MEMBER</span>
<span class="n">IS_SPARSITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_SPARSITY</span>
<span class="n">IS_DMATRIX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_DMATRIX</span>
<span class="n">IS_IMATRIX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_IMATRIX</span>
<span class="n">IS_SX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_SX</span>
<span class="n">IS_MX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_MX</span>
<span class="n">IS_DOUBLE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IS_DOUBLE</span>
<span class="k">class</span> <span class="nc">MatrixCommon</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Sparse matrix class. SX and DM are specializations.</span>

<span class="sd">      MatrixCommon() -&gt; </span>


<span class="sd">    General sparse matrix class that is designed with the idea that &quot;everything</span>
<span class="sd">    is a matrix&quot;, that is, also scalars and vectors. This philosophy makes it</span>
<span class="sd">    easy to use and to interface in particularly with Python and Matlab/Octave.</span>
<span class="sd">    Index starts with 0. Index vec happens as follows: (rr, cc) -&gt; k =</span>
<span class="sd">    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed</span>
<span class="sd">    Column Storage (CCS), similar to that used for sparse matrices in Matlab,</span>
<span class="sd">    but unlike this format, we do allow for elements to be structurally non-zero</span>
<span class="sd">    but numerically zero.  Matrix&lt;Scalar&gt; is polymorphic with a</span>
<span class="sd">    std::vector&lt;Scalar&gt; that contain all non-identical-zero elements. The</span>
<span class="sd">    sparsity can be accessed with Sparsity&amp; sparsity() Joel Andersson</span>

<span class="sd">    C++ includes: casadi_common.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          MatrixCommon()</span>
<span class="sd">          MatrixCommon(MatrixCommon other)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MatrixCommon(MatrixCommon other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MatrixCommon()</span>



<span class="sd">        constructors</span>

<span class="sd">        empty 0-by-0 matrix constructor</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_MatrixCommon</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_MatrixCommon</span>
<span class="n">MatrixCommon_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MatrixCommon_swigregister</span>
<span class="n">MatrixCommon_swigregister</span><span class="p">(</span><span class="n">MatrixCommon</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DM</span><span class="p">(</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">GenDM</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>





<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">GenDM</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">GenDM</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [DEPRECATED] Correctness is checked during construction</span>

<span class="sd">        sanity_check(self, bool complete)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the matrix has a non-zero at location rr, cc.</span>

<span class="sd">        has_nz(self, int rr, int cc) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_has_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the truth value of a Matrix.</span>

<span class="sd">        __bool__(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM___bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get(self, bool ind1, Sparsity sp) -&gt; DM</span>
<span class="sd">        get(self, bool ind1, Slice rr) -&gt; DM</span>
<span class="sd">        get(self, bool ind1, IM rr) -&gt; DM</span>
<span class="sd">        get(self, bool ind1, Slice rr, Slice cc) -&gt; DM</span>
<span class="sd">        get(self, bool ind1, Slice rr, IM cc) -&gt; DM</span>
<span class="sd">        get(self, bool ind1, IM rr, Slice cc) -&gt; DM</span>
<span class="sd">        get(self, bool ind1, IM rr, IM cc) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set(self, DM m, bool ind1, Sparsity sp)</span>
<span class="sd">        set(self, DM m, bool ind1, Slice rr)</span>
<span class="sd">        set(self, DM m, bool ind1, IM rr)</span>
<span class="sd">        set(self, DM m, bool ind1, Slice rr, Slice cc)</span>
<span class="sd">        set(self, DM m, bool ind1, Slice rr, IM cc)</span>
<span class="sd">        set(self, DM m, bool ind1, IM rr, Slice cc)</span>
<span class="sd">        set(self, DM m, bool ind1, IM rr, IM cc)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_nz(self, bool ind1, Slice k) -&gt; DM</span>
<span class="sd">        get_nz(self, bool ind1, IM k) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set_nz(self, DM m, bool ind1, Slice k)</span>
<span class="sd">        set_nz(self, DM m, bool ind1, IM k)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __pos__(self) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM___pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __neg__(self) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        binary(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unary(int op, DM x) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">unary</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">unary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        scalar_matrix(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">scalar_matrix</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">scalar_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        matrix_scalar(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">matrix_scalar</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">matrix_scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        matrix_matrix(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">matrix_matrix</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">matrix_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">printme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        printme(self, DM y) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_printme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set_max_depth(int eq_depth)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_max_depth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_max_depth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_max_depth() -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_max_depth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_max_depth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_input(Function f) -&gt; [DM]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_input</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_free(Function f) -&gt; [DM]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_free</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_free</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">print_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get strings corresponding to the nonzeros and the interdependencies.</span>

<span class="sd">        print_split(self) -&gt; ([str] OUTPUT, [str] OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_print_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a representation of the object.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print scalar.</span>

<span class="sd">        print_scalar(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_print_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print vector-style.</span>

<span class="sd">        print_vector(self, bool truncate)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_print_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print dense matrix-stype.</span>

<span class="sd">        print_dense(self, bool truncate)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_print_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print sparse matrix style.</span>

<span class="sd">        print_sparse(self, bool truncate)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_print_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        clear(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        resize(self, int nrow, int ncol)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reserve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        reserve(self, int nnz)</span>
<span class="sd">        reserve(self, int nnz, int ncol)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_reserve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Erase a submatrix (leaving structural zeros in its place) Erase elements of</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>
<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        a matrix.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>



<span class="sd">        Erase a submatrix (leaving structural zeros in its place) Erase elements of</span>
<span class="sd">        a matrix.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>



<span class="sd">        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or</span>
<span class="sd">        columns of a matrix.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove columns and rows Remove/delete rows and/or columns of a matrix.</span>

<span class="sd">        remove(self, [int] rr, [int] cc)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Enlarge matrix Make the matrix larger by inserting empty rows and columns,</span>

<span class="sd">          enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        keeping the existing non-zeros.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an owning reference to the sparsity pattern.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        triplet([int] row, [int] col, DM d) -&gt; DM</span>
<span class="sd">        triplet([int] row, [int] col, DM d, (int,int) rc) -&gt; DM</span>
<span class="sd">        triplet([int] row, [int] col, DM d, int nrow, int ncol) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">triplet</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a matrix with all inf</span>

<span class="sd">        inf(int nrow, int ncol) -&gt; DM</span>
<span class="sd">        inf((int,int) rc) -&gt; DM</span>
<span class="sd">        inf(Sparsity sp) -&gt; DM</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">inf</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a matrix with all nan</span>

<span class="sd">        nan(int nrow, int ncol) -&gt; DM</span>
<span class="sd">        nan((int,int) rc) -&gt; DM</span>
<span class="sd">        nan(Sparsity sp) -&gt; DM</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">nan</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        eye(int n) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">eye</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">element_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        element_hash(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_element_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_regular(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_smooth(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_leaf(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_commutative(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_symbolic(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_valid_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_valid_input(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_valid_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_duplicates(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reset_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        reset_input(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_reset_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the matrix is constant (note that false negative answers are</span>

<span class="sd">          is_constant(self) -&gt; bool</span>

<span class="sd">        possible)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the matrix is integer-valued (note that false negative answers are</span>

<span class="sd">          is_integer(self) -&gt; bool</span>

<span class="sd">        possible)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the matrix is 0 (note that false negative answers are possible)</span>

<span class="sd">        is_zero(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the matrix is 1 (note that false negative answers are possible)</span>

<span class="sd">        is_one(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_minus_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the matrix is -1 (note that false negative answers are possible)</span>

<span class="sd">        is_minus_one(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_minus_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          check if the matrix is an identity matrix (note that false negative answers</span>

<span class="sd">          is_eye(self) -&gt; bool</span>

<span class="sd">        are possible)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        op(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_op(self, int op) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_is_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix has any zero entries which are not structural zeros.</span>

<span class="sd">        has_zeros(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_has_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get all nonzeros.</span>

<span class="sd">          nonzeros(self) -&gt; [float]</span>


<span class="sd">        Implementation of Matrix::get_nonzeros (in public API)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all elements.</span>

<span class="sd">        elements(self) -&gt; [float]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __float__(self) -&gt; float</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM___float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __int__(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM___int__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        name(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        dep(self, int ch) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        n_dep(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_n_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">          set_precision(int precision)</span>

<span class="sd">        streams.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_precision</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_precision</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">          set_width(int width)</span>

<span class="sd">        streams.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_width</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_width</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">          set_scientific(bool scientific)</span>

<span class="sd">        streams.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_scientific</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_scientific</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        rng(int seed)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a matrix with uniformly distributed random numbers.</span>

<span class="sd">        rand(int nrow, int ncol) -&gt; DM</span>
<span class="sd">        rand((int,int) rc) -&gt; DM</span>
<span class="sd">        rand(Sparsity sp) -&gt; DM</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">rand</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">rand</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export matrix in specific language.</span>

<span class="sd">          export_code(self, str lang, dict options)</span>


<span class="sd">        lang: only &#39;matlab&#39; supported for now</span>

<span class="sd">        ::</span>

<span class="sd">          * options:</span>
<span class="sd">          *   inline: Indicates if you want everything on a single line (default: False)</span>
<span class="sd">          *   name: Name of exported variable (default: &#39;m&#39;)</span>
<span class="sd">          *   indent_level: Level of indentation (default: 0)</span>
<span class="sd">          *   spoof_zero: Replace numerical zero by a 1e-200 (default: false)</span>
<span class="sd">          *               might be needed for matlab sparse construct,</span>
<span class="sd">          *               which doesn&#39;t allow numerical zero</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        info(self) -&gt; dict</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Serialize an object.</span>

<span class="sd">          serialize(self) -&gt; str</span>
<span class="sd">          serialize(self, casadi::SerializingStream &amp; s)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          serialize(self, casadi::SerializingStream &amp; s)</span>



<span class="sd">        Serialize an object.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          serialize(self)</span>



<span class="sd">        Serialize.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(std::istream &amp; stream) -&gt; DM</span>
<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; DM</span>
<span class="sd">        deserialize(str s) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export numerical matrix to file</span>

<span class="sd">          to_file(self, str filename, str format)</span>


<span class="sd">        Supported formats:</span>



<span class="sd">        ::</span>

<span class="sd">          *   - .mtx   Matrix Market (sparse)</span>
<span class="sd">          *   - .txt   Ascii full precision representation (sparse)</span>
<span class="sd">          *            Whitespace separated, aligned.</span>
<span class="sd">          *            Comments with # % or /</span>
<span class="sd">          *            Uses C locale</span>
<span class="sd">          *            Structural zeros represented by 00</span>
<span class="sd">          *            Does not scale well for large sparse matrices</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export numerical matrix to file</span>

<span class="sd">          from_file(str filename, str format_hint) -&gt; DM</span>


<span class="sd">        Supported formats:</span>



<span class="sd">        ::</span>

<span class="sd">          *   - .mtx   Matrix Market (sparse)</span>
<span class="sd">          *   - .txt   Ascii full precision representation (sparse)</span>
<span class="sd">          *            Whitespace separated, aligned.</span>
<span class="sd">          *            Comments with # % or /</span>
<span class="sd">          *            Uses C locale</span>
<span class="sd">          *            Structural zeros represented by 00</span>
<span class="sd">          *            Does not scale well for large sparse matrices</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">from_file</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">from_file</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        DM()</span>
<span class="sd">        DM(Sparsity sp)</span>
<span class="sd">        DM(float val)</span>
<span class="sd">        DM([[float]] m)</span>
<span class="sd">        DM(DM m)</span>
<span class="sd">        DM([SXElem] x)</span>
<span class="sd">        DM(SX x)</span>
<span class="sd">        DM(int nrow, int ncol)</span>
<span class="sd">        DM(Sparsity sp, DM d)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_DM</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        assign(self, DM rhs)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size1</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">size2</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot slice with None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;CasADi matrices are not iterable by design.</span>
<span class="s2">                      Did you mean to iterate over m.nz, with m IM/DM/SX?</span>
<span class="s2">                      Did you mean to iterate over horzsplit(m,1)/vertsplit(m,1) with m IM/DM/SX/MX?</span>
<span class="s2">                      &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">NZproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PyObject *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        full(self) -&gt; PyObject *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PyObject *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        sparse(self) -&gt; PyObject *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>



    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">999.0</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">out_arr</span><span class="p">,</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_arr</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39; where &#39;a&#39; is a numpy type. This is not supported, and cannot be supported without changing numpy.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

      <span class="k">if</span> <span class="s2">&quot;vectorized&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot; (vectorized)&quot;</span><span class="p">)]</span>

      <span class="n">conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;subtract&quot;</span><span class="p">:</span><span class="s2">&quot;sub&quot;</span><span class="p">,</span><span class="s2">&quot;power&quot;</span><span class="p">:</span><span class="s2">&quot;pow&quot;</span><span class="p">,</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span><span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">}</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">conversion</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">conversion</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">args</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>
      <span class="n">fun</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="n">conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;subtract&quot;</span><span class="p">:</span><span class="s2">&quot;sub&quot;</span><span class="p">,</span><span class="s2">&quot;power&quot;</span><span class="p">:</span><span class="s2">&quot;pow&quot;</span><span class="p">,</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span><span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">}</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39; where &#39;a&#39; is a numpy type. This is not supported, and cannot be supported without changing numpy.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
      <span class="k">if</span> <span class="s2">&quot;vectorized&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot; (vectorized)&quot;</span><span class="p">)]</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">conversion</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">conversion</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;__call__&quot;</span>
        <span class="n">fun</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
      <span class="k">except</span><span class="p">:</span>
<span class="c1">#Fall back to numpy conversion</span>
        <span class="n">new_inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
          <span class="kn">import</span> <span class="nn">warnings</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Implicit conversion of symbolic CasADi type to numeric matrix not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;This may occur when you pass a CasADi object to a numpy function.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;Use an equivalent CasADi function instead of that numpy function.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
          <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">new_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">n</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">ufunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">ufunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nin</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39;. This is not supported when &#39;a&#39; is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use &#39;a = a + b&#39;. &quot;</span> <span class="o">%</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;__array_custom__&#39;</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_custom__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
          <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Implicit conversion of symbolic CasADi type to numeric matrix not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="o">+</span> <span class="s2">&quot;This may occur when you pass a CasADi object to a numpy function.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="o">+</span> <span class="s2">&quot;Use an equivalent CasADi function instead of that numpy function.&quot;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">__array_custom__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="k">if</span> <span class="s2">&quot;dtype&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">double</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full</span><span class="p">(),</span><span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">tocsc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
      <span class="kn">import</span> <span class="nn">warnings</span>
      <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span>
      <span class="k">return</span> <span class="n">csc_matrix</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonzeros</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">colind</span><span class="p">()),</span> <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
      <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">():</span>
          <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_vector</span><span class="p">():</span>
          <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">elements</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">elements</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only a scalar can be cast to a float&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
      <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span>


    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;serialization&quot;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;serialization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">()}</span>

    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_DM</span>
<span class="n">DM_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_swigregister</span>
<span class="n">DM_swigregister</span><span class="p">(</span><span class="n">DM</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    binary(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    unary(int op, DM x) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    scalar_matrix(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    matrix_scalar(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    matrix_matrix(int op, DM x, DM y) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    set_max_depth(int eq_depth)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_max_depth() -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_input(Function f) -&gt; [DM]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_free(Function f) -&gt; [DM]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    triplet([int] row, [int] col, DM d) -&gt; DM</span>
<span class="sd">    triplet([int] row, [int] col, DM d, (int,int) rc) -&gt; DM</span>
<span class="sd">    triplet([int] row, [int] col, DM d, int nrow, int ncol) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a matrix with all inf</span>

<span class="sd">    inf(int nrow, int ncol) -&gt; DM</span>
<span class="sd">    inf((int,int) rc) -&gt; DM</span>
<span class="sd">    inf(Sparsity sp) -&gt; DM</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a matrix with all nan</span>

<span class="sd">    nan(int nrow, int ncol) -&gt; DM</span>
<span class="sd">    nan((int,int) rc) -&gt; DM</span>
<span class="sd">    nan(Sparsity sp) -&gt; DM</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    eye(int n) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">      set_precision(int precision)</span>

<span class="sd">    streams.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">      set_width(int width)</span>

<span class="sd">    streams.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">      set_scientific(bool scientific)</span>

<span class="sd">    streams.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    rng(int seed)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a matrix with uniformly distributed random numbers.</span>

<span class="sd">    rand(int nrow, int ncol) -&gt; DM</span>
<span class="sd">    rand((int,int) rc) -&gt; DM</span>
<span class="sd">    rand(Sparsity sp) -&gt; DM</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(std::istream &amp; stream) -&gt; DM</span>
<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; DM</span>
<span class="sd">    deserialize(str s) -&gt; DM</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DM_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Export numerical matrix to file</span>

<span class="sd">      from_file(str filename, str format_hint) -&gt; DM</span>


<span class="sd">    Supported formats:</span>



<span class="sd">    ::</span>

<span class="sd">      *   - .mtx   Matrix Market (sparse)</span>
<span class="sd">      *   - .txt   Ascii full precision representation (sparse)</span>
<span class="sd">      *            Whitespace separated, aligned.</span>
<span class="sd">      *            Comments with # % or /</span>
<span class="sd">      *            Uses C locale</span>
<span class="sd">      *            Structural zeros represented by 00</span>
<span class="sd">      *            Does not scale well for large sparse matrices</span>
<span class="sd">      * </span>






<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DM_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SXElem</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    SXElem() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SXElem</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SXElem</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        SXElem()</span>
<span class="sd">        SXElem(SXElem other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_SXElem</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_SXElem</span>
<span class="n">SXElem_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SXElem_swigregister</span>
<span class="n">SXElem_swigregister</span><span class="p">(</span><span class="n">SXElem</span><span class="p">)</span>



<span class="k">try</span><span class="p">:</span>
  <span class="kn">import</span> <span class="nn">numpy</span>

  <span class="k">def</span> <span class="nf">constpow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">pass</span>

  <span class="n">constpow</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span><span class="n">constpow</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
  <span class="k">pass</span>

<span class="k">class</span> <span class="nc">SX</span><span class="p">(</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">GenSX</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>





<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">GenSX</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SX</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">GenSX</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SX</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [DEPRECATED] Correctness is checked during construction</span>

<span class="sd">        sanity_check(self, bool complete)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the matrix has a non-zero at location rr, cc.</span>

<span class="sd">        has_nz(self, int rr, int cc) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_has_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the truth value of a Matrix.</span>

<span class="sd">        __bool__(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX___bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get(self, bool ind1, Sparsity sp) -&gt; SX</span>
<span class="sd">        get(self, bool ind1, Slice rr) -&gt; SX</span>
<span class="sd">        get(self, bool ind1, IM rr) -&gt; SX</span>
<span class="sd">        get(self, bool ind1, Slice rr, Slice cc) -&gt; SX</span>
<span class="sd">        get(self, bool ind1, Slice rr, IM cc) -&gt; SX</span>
<span class="sd">        get(self, bool ind1, IM rr, Slice cc) -&gt; SX</span>
<span class="sd">        get(self, bool ind1, IM rr, IM cc) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set(self, SX m, bool ind1, Sparsity sp)</span>
<span class="sd">        set(self, SX m, bool ind1, Slice rr)</span>
<span class="sd">        set(self, SX m, bool ind1, IM rr)</span>
<span class="sd">        set(self, SX m, bool ind1, Slice rr, Slice cc)</span>
<span class="sd">        set(self, SX m, bool ind1, Slice rr, IM cc)</span>
<span class="sd">        set(self, SX m, bool ind1, IM rr, Slice cc)</span>
<span class="sd">        set(self, SX m, bool ind1, IM rr, IM cc)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_nz(self, bool ind1, Slice k) -&gt; SX</span>
<span class="sd">        get_nz(self, bool ind1, IM k) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set_nz(self, SX m, bool ind1, Slice k)</span>
<span class="sd">        set_nz(self, SX m, bool ind1, IM k)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __pos__(self) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX___pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __neg__(self) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        binary(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unary(int op, SX x) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">unary</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">unary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        scalar_matrix(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">scalar_matrix</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">scalar_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        matrix_scalar(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">matrix_scalar</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">matrix_scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        matrix_matrix(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">matrix_matrix</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">matrix_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">printme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        printme(self, SX y) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_printme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set_max_depth(int eq_depth)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_max_depth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_max_depth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_max_depth() -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_max_depth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_max_depth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_input(Function f) -&gt; [SX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_input</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_free(Function f) -&gt; [SX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_free</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_free</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">print_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get strings corresponding to the nonzeros and the interdependencies.</span>

<span class="sd">        print_split(self) -&gt; ([str] OUTPUT, [str] OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_print_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a representation of the object.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print scalar.</span>

<span class="sd">        print_scalar(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_print_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print vector-style.</span>

<span class="sd">        print_vector(self, bool truncate)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_print_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print dense matrix-stype.</span>

<span class="sd">        print_dense(self, bool truncate)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_print_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print sparse matrix style.</span>

<span class="sd">        print_sparse(self, bool truncate)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_print_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        clear(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        resize(self, int nrow, int ncol)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reserve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        reserve(self, int nnz)</span>
<span class="sd">        reserve(self, int nnz, int ncol)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_reserve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Erase a submatrix (leaving structural zeros in its place) Erase elements of</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>
<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        a matrix.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>



<span class="sd">        Erase a submatrix (leaving structural zeros in its place) Erase elements of</span>
<span class="sd">        a matrix.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>



<span class="sd">        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or</span>
<span class="sd">        columns of a matrix.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove columns and rows Remove/delete rows and/or columns of a matrix.</span>

<span class="sd">        remove(self, [int] rr, [int] cc)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Enlarge matrix Make the matrix larger by inserting empty rows and columns,</span>

<span class="sd">          enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        keeping the existing non-zeros.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an owning reference to the sparsity pattern.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        triplet([int] row, [int] col, SX d) -&gt; SX</span>
<span class="sd">        triplet([int] row, [int] col, SX d, (int,int) rc) -&gt; SX</span>
<span class="sd">        triplet([int] row, [int] col, SX d, int nrow, int ncol) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">triplet</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a matrix with all inf</span>

<span class="sd">        inf(int nrow, int ncol) -&gt; SX</span>
<span class="sd">        inf((int,int) rc) -&gt; SX</span>
<span class="sd">        inf(Sparsity sp) -&gt; SX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">inf</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a matrix with all nan</span>

<span class="sd">        nan(int nrow, int ncol) -&gt; SX</span>
<span class="sd">        nan((int,int) rc) -&gt; SX</span>
<span class="sd">        nan(Sparsity sp) -&gt; SX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">nan</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        eye(int n) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">eye</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">element_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        element_hash(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_element_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_regular(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_smooth(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_leaf(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_commutative(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_symbolic(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_valid_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_valid_input(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_valid_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_duplicates(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reset_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        reset_input(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_reset_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the matrix is constant (note that false negative answers are</span>

<span class="sd">          is_constant(self) -&gt; bool</span>

<span class="sd">        possible)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the matrix is integer-valued (note that false negative answers are</span>

<span class="sd">          is_integer(self) -&gt; bool</span>

<span class="sd">        possible)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the matrix is 0 (note that false negative answers are possible)</span>

<span class="sd">        is_zero(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the matrix is 1 (note that false negative answers are possible)</span>

<span class="sd">        is_one(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_minus_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the matrix is -1 (note that false negative answers are possible)</span>

<span class="sd">        is_minus_one(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_minus_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          check if the matrix is an identity matrix (note that false negative answers</span>

<span class="sd">          is_eye(self) -&gt; bool</span>

<span class="sd">        are possible)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        op(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        is_op(self, int op) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_is_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the matrix has any zero entries which are not structural zeros.</span>

<span class="sd">        has_zeros(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_has_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::SXElem,std::allocator&lt; casadi::SXElem &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get all nonzeros.</span>

<span class="sd">          nonzeros(self) -&gt; [SXElem]</span>


<span class="sd">        Implementation of Matrix::get_nonzeros (in public API)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::SXElem,std::allocator&lt; casadi::SXElem &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all elements.</span>

<span class="sd">        elements(self) -&gt; [SXElem]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __float__(self) -&gt; float</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX___float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __int__(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX___int__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        name(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        dep(self, int ch) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        n_dep(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_n_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">          set_precision(int precision)</span>

<span class="sd">        streams.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_precision</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_precision</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">          set_width(int width)</span>

<span class="sd">        streams.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_width</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_width</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">          set_scientific(bool scientific)</span>

<span class="sd">        streams.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_scientific</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_scientific</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        rng(int seed)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a matrix with uniformly distributed random numbers.</span>

<span class="sd">        rand(int nrow, int ncol) -&gt; SX</span>
<span class="sd">        rand((int,int) rc) -&gt; SX</span>
<span class="sd">        rand(Sparsity sp) -&gt; SX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">rand</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">rand</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export matrix in specific language.</span>

<span class="sd">          export_code(self, str lang, dict options)</span>


<span class="sd">        lang: only &#39;matlab&#39; supported for now</span>

<span class="sd">        ::</span>

<span class="sd">          * options:</span>
<span class="sd">          *   inline: Indicates if you want everything on a single line (default: False)</span>
<span class="sd">          *   name: Name of exported variable (default: &#39;m&#39;)</span>
<span class="sd">          *   indent_level: Level of indentation (default: 0)</span>
<span class="sd">          *   spoof_zero: Replace numerical zero by a 1e-200 (default: false)</span>
<span class="sd">          *               might be needed for matlab sparse construct,</span>
<span class="sd">          *               which doesn&#39;t allow numerical zero</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        info(self) -&gt; dict</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Serialize an object.</span>

<span class="sd">          serialize(self) -&gt; str</span>
<span class="sd">          serialize(self, casadi::SerializingStream &amp; s)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          serialize(self, casadi::SerializingStream &amp; s)</span>



<span class="sd">        Serialize an object.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          serialize(self)</span>



<span class="sd">        Serialize.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(std::istream &amp; stream) -&gt; SX</span>
<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; SX</span>
<span class="sd">        deserialize(str s) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export numerical matrix to file</span>

<span class="sd">          to_file(self, str filename, str format)</span>


<span class="sd">        Supported formats:</span>



<span class="sd">        ::</span>

<span class="sd">          *   - .mtx   Matrix Market (sparse)</span>
<span class="sd">          *   - .txt   Ascii full precision representation (sparse)</span>
<span class="sd">          *            Whitespace separated, aligned.</span>
<span class="sd">          *            Comments with # % or /</span>
<span class="sd">          *            Uses C locale</span>
<span class="sd">          *            Structural zeros represented by 00</span>
<span class="sd">          *            Does not scale well for large sparse matrices</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export numerical matrix to file</span>

<span class="sd">          from_file(str filename, str format_hint) -&gt; DM</span>


<span class="sd">        Supported formats:</span>



<span class="sd">        ::</span>

<span class="sd">          *   - .mtx   Matrix Market (sparse)</span>
<span class="sd">          *   - .txt   Ascii full precision representation (sparse)</span>
<span class="sd">          *            Whitespace separated, aligned.</span>
<span class="sd">          *            Comments with # % or /</span>
<span class="sd">          *            Uses C locale</span>
<span class="sd">          *            Structural zeros represented by 00</span>
<span class="sd">          *            Does not scale well for large sparse matrices</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">from_file</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">from_file</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size1</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">size2</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot slice with None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;CasADi matrices are not iterable by design.</span>
<span class="s2">                      Did you mean to iterate over m.nz, with m IM/DM/SX?</span>
<span class="s2">                      Did you mean to iterate over horzsplit(m,1)/vertsplit(m,1) with m IM/DM/SX/MX?</span>
<span class="s2">                      &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">NZproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>




    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">1001.0</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">out_arr</span><span class="p">,</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_arr</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39; where &#39;a&#39; is a numpy type. This is not supported, and cannot be supported without changing numpy.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

      <span class="k">if</span> <span class="s2">&quot;vectorized&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot; (vectorized)&quot;</span><span class="p">)]</span>

      <span class="n">conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;subtract&quot;</span><span class="p">:</span><span class="s2">&quot;sub&quot;</span><span class="p">,</span><span class="s2">&quot;power&quot;</span><span class="p">:</span><span class="s2">&quot;pow&quot;</span><span class="p">,</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span><span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">}</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">conversion</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">conversion</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">args</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>
      <span class="n">fun</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="n">conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;subtract&quot;</span><span class="p">:</span><span class="s2">&quot;sub&quot;</span><span class="p">,</span><span class="s2">&quot;power&quot;</span><span class="p">:</span><span class="s2">&quot;pow&quot;</span><span class="p">,</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span><span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">}</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39; where &#39;a&#39; is a numpy type. This is not supported, and cannot be supported without changing numpy.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
      <span class="k">if</span> <span class="s2">&quot;vectorized&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot; (vectorized)&quot;</span><span class="p">)]</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">conversion</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">conversion</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;__call__&quot;</span>
        <span class="n">fun</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
      <span class="k">except</span><span class="p">:</span>
<span class="c1">#Fall back to numpy conversion</span>
        <span class="n">new_inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
          <span class="kn">import</span> <span class="nn">warnings</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Implicit conversion of symbolic CasADi type to numeric matrix not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;This may occur when you pass a CasADi object to a numpy function.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;Use an equivalent CasADi function instead of that numpy function.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
          <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">new_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">n</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">ufunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">ufunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nin</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39;. This is not supported when &#39;a&#39; is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use &#39;a = a + b&#39;. &quot;</span> <span class="o">%</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;__array_custom__&#39;</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_custom__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
          <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Implicit conversion of symbolic CasADi type to numeric matrix not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="o">+</span> <span class="s2">&quot;This may occur when you pass a CasADi object to a numpy function.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="o">+</span> <span class="s2">&quot;Use an equivalent CasADi function instead of that numpy function.&quot;</span><span class="p">)</span>



    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        SX()</span>
<span class="sd">        SX(Sparsity sp)</span>
<span class="sd">        SX(float val)</span>
<span class="sd">        SX([[float]] m)</span>
<span class="sd">        SX([float] x)</span>
<span class="sd">        SX(DM x)</span>
<span class="sd">        SX(SX m)</span>
<span class="sd">        SX(int nrow, int ncol)</span>
<span class="sd">        SX(Sparsity sp, SX d)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_SX</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_SX</span>
<span class="n">SX_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_swigregister</span>
<span class="n">SX_swigregister</span><span class="p">(</span><span class="n">SX</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    binary(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    unary(int op, SX x) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    scalar_matrix(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_scalar_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    matrix_scalar(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_matrix_scalar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    matrix_matrix(int op, SX x, SX y) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_matrix_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    set_max_depth(int eq_depth)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_max_depth() -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_input(Function f) -&gt; [SX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_free(Function f) -&gt; [SX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    triplet([int] row, [int] col, SX d) -&gt; SX</span>
<span class="sd">    triplet([int] row, [int] col, SX d, (int,int) rc) -&gt; SX</span>
<span class="sd">    triplet([int] row, [int] col, SX d, int nrow, int ncol) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_triplet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a matrix with all inf</span>

<span class="sd">    inf(int nrow, int ncol) -&gt; SX</span>
<span class="sd">    inf((int,int) rc) -&gt; SX</span>
<span class="sd">    inf(Sparsity sp) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a matrix with all nan</span>

<span class="sd">    nan(int nrow, int ncol) -&gt; SX</span>
<span class="sd">    nan((int,int) rc) -&gt; SX</span>
<span class="sd">    nan(Sparsity sp) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    eye(int n) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">      set_precision(int precision)</span>

<span class="sd">    streams.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_precision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">      set_width(int width)</span>

<span class="sd">    streams.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Set the &#39;precision, width &amp; scientific&#39; used in printing and serializing to</span>

<span class="sd">      set_scientific(bool scientific)</span>

<span class="sd">    streams.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_set_scientific</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    rng(int seed)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_rng</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a matrix with uniformly distributed random numbers.</span>

<span class="sd">    rand(int nrow, int ncol) -&gt; SX</span>
<span class="sd">    rand((int,int) rc) -&gt; SX</span>
<span class="sd">    rand(Sparsity sp) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_rand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(std::istream &amp; stream) -&gt; SX</span>
<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; SX</span>
<span class="sd">    deserialize(str s) -&gt; SX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SX_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Export numerical matrix to file</span>

<span class="sd">      from_file(str filename, str format_hint) -&gt; DM</span>


<span class="sd">    Supported formats:</span>



<span class="sd">    ::</span>

<span class="sd">      *   - .mtx   Matrix Market (sparse)</span>
<span class="sd">      *   - .txt   Ascii full precision representation (sparse)</span>
<span class="sd">      *            Whitespace separated, aligned.</span>
<span class="sd">      *            Comments with # % or /</span>
<span class="sd">      *            Uses C locale</span>
<span class="sd">      *            Structural zeros represented by 00</span>
<span class="sd">      *            Does not scale well for large sparse matrices</span>
<span class="sd">      * </span>






<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SX_from_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MX</span><span class="p">(</span><span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">GenMX</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      MX - Matrix expression.</span>



<span class="sd">    The MX class is used to build up trees made up from MXNodes. It is a more</span>
<span class="sd">    general graph representation than the scalar expression, SX, and much less</span>
<span class="sd">    efficient for small objects. On the other hand, the class allows much more</span>
<span class="sd">    general operations than does SX, in particular matrix valued operations and</span>
<span class="sd">    calls to arbitrary differentiable functions.</span>

<span class="sd">    The MX class is designed to have identical syntax with the Matrix&lt;&gt; template</span>
<span class="sd">    class, and uses DM (i.e. Matrix&lt;double&gt;) as its internal representation of</span>
<span class="sd">    the values at a node. By keeping the syntaxes identical, it is possible to</span>
<span class="sd">    switch from one class to the other, as well as inlining MX functions to</span>
<span class="sd">    SXElem functions.</span>

<span class="sd">    Note that an operation is always &quot;lazy&quot;, making a matrix multiplication</span>
<span class="sd">    will create a matrix multiplication node, not perform the actual</span>
<span class="sd">    multiplication.</span>

<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: mx.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">GenMX</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MX</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GenericExpressionCommon</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">GenMX</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MX</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          MX()</span>
<span class="sd">          MX(Sparsity sp)</span>
<span class="sd">          MX(float x)</span>
<span class="sd">          MX(DM x)</span>
<span class="sd">          MX(MX x)</span>
<span class="sd">          MX(int nrow, int ncol)</span>
<span class="sd">          MX(Sparsity sp, MX val)</span>
<span class="sd">          MX(Sparsity sp, str fname)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(DM x)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(Sparsity sp)</span>



<span class="sd">        Create a sparse matrix from a sparsity pattern. Same as MX::ones(sparsity)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(Sparsity sp, MX val)</span>



<span class="sd">        Construct matrix with a given sparsity and nonzeros.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX()</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(float x)</span>



<span class="sd">        Create scalar constant (also implicit type conversion)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(MX x)</span>



<span class="sd">        Copy constructor.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(int nrow, int ncol)</span>



<span class="sd">        Create a sparse matrix with all structural zeros.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          MX(Sparsity sp, str fname)</span>



<span class="sd">        Construct matrix with a given sparsity and a file with nonzeros.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_MX</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_MX</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the truth value of an MX expression.</span>

<span class="sd">        __bool__(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX___bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an owning reference to the sparsity pattern.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Erase a submatrix (leaving structural zeros in its place) Erase elements of</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>
<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        a matrix.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, bool ind1)</span>



<span class="sd">        Erase a submatrix (leaving structural zeros in its place) Erase elements of</span>
<span class="sd">        a matrix.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          erase(self, [int] rr, [int] cc, bool ind1)</span>



<span class="sd">        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or</span>
<span class="sd">        columns of a matrix.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Enlarge matrix Make the matrix larger by inserting empty rows and columns,</span>

<span class="sd">          enlarge(self, int nrow, int ncol, [int] rr, [int] cc, bool ind1)</span>

<span class="sd">        keeping the existing non-zeros.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __neg__(self) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nth dependency as MX.</span>

<span class="sd">        dep(self, int ch) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of outputs.</span>

<span class="sd">        n_out(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_n_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an output.</span>

<span class="sd">        get_output(self, int oind) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of dependencies of a binary SXElem.</span>

<span class="sd">        n_dep(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_n_dep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the name.</span>

<span class="sd">        name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __float__(self) -&gt; float</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX___float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">to_DM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        to_DM(self) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_to_DM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if symbolic.</span>

<span class="sd">        is_symbolic(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if constant.</span>

<span class="sd">        is_constant(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if evaluation.</span>

<span class="sd">        is_call(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">which_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get function - only valid when is_call() is true.</span>

<span class="sd">        which_function(self) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_which_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if evaluation output.</span>

<span class="sd">        is_output(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">which_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the index of evaluation output - only valid when is_output() is true.</span>

<span class="sd">        which_output(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_which_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is it a certain operation.</span>

<span class="sd">        is_op(self, int op) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if multiplication.</span>

<span class="sd">        is_multiplication(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if commutative operation.</span>

<span class="sd">        is_commutative(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if norm.</span>

<span class="sd">        is_norm(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_valid_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if matrix can be used to define function inputs. Valid inputs for</span>

<span class="sd">          is_valid_input(self) -&gt; bool</span>

<span class="sd">        MXFunctions are combinations of Reshape, concatenations and SymbolicMX.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_valid_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of primitives for MXFunction inputs/outputs.</span>

<span class="sd">        n_primitives(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_n_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get primitives.</span>

<span class="sd">        primitives(self) -&gt; [MX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">split_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split up an expression along symbolic primitives.</span>

<span class="sd">        split_primitives(self, MX x) -&gt; [MX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_split_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">join_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join an expression along symbolic primitives.</span>

<span class="sd">        join_primitives(self, [MX] v) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_join_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          [INTERNAL]  Detect duplicate symbolic expressions If there are symbolic</span>

<span class="sd">          has_duplicates(self) -&gt; bool</span>

<span class="sd">        primitives appearing more than once, the function will return true and the</span>
<span class="sd">        names of the duplicate expressions will be passed to casadi_warning. Note:</span>
<span class="sd">        Will mark the node using MX::set_temp. Make sure to call reset_input() after</span>
<span class="sd">        usage.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reset_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [INTERNAL]  Reset the marker for an input expression.</span>

<span class="sd">        reset_input(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_reset_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if identity</span>

<span class="sd">        is_eye(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if zero (note that false negative answers are possible)</span>

<span class="sd">        is_zero(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if zero (note that false negative answers are possible)</span>

<span class="sd">        is_one(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_minus_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if zero (note that false negative answers are possible)</span>

<span class="sd">        is_minus_one(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_minus_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the expression a transpose?</span>

<span class="sd">        is_transpose(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if expression does not contain NaN or Inf.</span>

<span class="sd">        is_regular(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is binary operation.</span>

<span class="sd">        is_binary(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is unary operation.</span>

<span class="sd">        is_unary(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_is_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get operation type.</span>

<span class="sd">        op(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain information about node</span>

<span class="sd">        info(self) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize an object.</span>

<span class="sd">        serialize(self, casadi::SerializingStream &amp; s)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [INTERNAL]  Get the temporary variable</span>

<span class="sd">        get_temp(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [INTERNAL]  Set the temporary variable.</span>

<span class="sd">        set_temp(self, int t)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_set_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create nodes by their ID.</span>

<span class="sd">        binary(int op, MX x, MX y) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">binary</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create nodes by their ID.</span>

<span class="sd">        unary(int op, MX x) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">unary</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">unary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a matrix with all inf</span>

<span class="sd">        inf(int nrow, int ncol) -&gt; MX</span>
<span class="sd">        inf((int,int) rc) -&gt; MX</span>
<span class="sd">        inf(Sparsity sp) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">inf</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a matrix with all nan</span>

<span class="sd">        nan(int nrow, int ncol) -&gt; MX</span>
<span class="sd">        nan((int,int) rc) -&gt; MX</span>
<span class="sd">        nan(Sparsity sp) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">nan</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        eye(int n) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">eye</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a submatrix, two arguments</span>

<span class="sd">          get(self, bool ind1, int rr) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, Sparsity sp) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, Slice rr) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, IM rr) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, MX rr) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, int rr, int cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, int rr, Slice cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, Slice rr, int cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, Slice rr, Slice cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, Slice rr, IM cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, Slice rr, MX cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, IM rr, Slice cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, IM rr, IM cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, MX rr, Slice cc) -&gt; MX</span>
<span class="sd">          get(self, bool ind1, MX rr, MX cc) -&gt; MX</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get(self, bool ind1, IM rr)</span>
<span class="sd">          get(self, bool ind1, Slice rr, IM cc)</span>
<span class="sd">          get(self, bool ind1, IM rr, Slice cc)</span>
<span class="sd">          get(self, bool ind1, IM rr, IM cc)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get(self, bool ind1, int rr)</span>
<span class="sd">          get(self, bool ind1, Sparsity sp)</span>
<span class="sd">          get(self, bool ind1, Slice rr)</span>
<span class="sd">          get(self, bool ind1, MX rr)</span>



<span class="sd">        Get a submatrix, single argument</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get(self, bool ind1, int rr, int cc)</span>
<span class="sd">          get(self, bool ind1, int rr, Slice cc)</span>
<span class="sd">          get(self, bool ind1, Slice rr, int cc)</span>
<span class="sd">          get(self, bool ind1, Slice rr, Slice cc)</span>
<span class="sd">          get(self, bool ind1, Slice rr, MX cc)</span>
<span class="sd">          get(self, bool ind1, MX rr, Slice cc)</span>
<span class="sd">          get(self, bool ind1, MX rr, MX cc)</span>



<span class="sd">        Get a submatrix, two arguments</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          set(self, MX m, bool ind1, Sparsity sp)</span>
<span class="sd">          set(self, MX m, bool ind1, Slice rr)</span>
<span class="sd">          set(self, MX m, bool ind1, IM rr)</span>
<span class="sd">          set(self, MX m, bool ind1, Slice rr, Slice cc)</span>
<span class="sd">          set(self, MX m, bool ind1, Slice rr, IM cc)</span>
<span class="sd">          set(self, MX m, bool ind1, IM rr, Slice cc)</span>
<span class="sd">          set(self, MX m, bool ind1, IM rr, IM cc)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set(self, MX m, bool ind1, IM rr)</span>
<span class="sd">          set(self, MX m, bool ind1, Slice rr, Slice cc)</span>
<span class="sd">          set(self, MX m, bool ind1, Slice rr, IM cc)</span>
<span class="sd">          set(self, MX m, bool ind1, IM rr, Slice cc)</span>
<span class="sd">          set(self, MX m, bool ind1, IM rr, IM cc)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set(self, MX m, bool ind1, Sparsity sp)</span>
<span class="sd">          set(self, MX m, bool ind1, Slice rr)</span>



<span class="sd">        Set a submatrix, single argument</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a set of nonzeros</span>

<span class="sd">          get_nz(self, bool ind1, int kk) -&gt; MX</span>
<span class="sd">          get_nz(self, bool ind1, Slice kk) -&gt; MX</span>
<span class="sd">          get_nz(self, bool ind1, IM kk) -&gt; MX</span>
<span class="sd">          get_nz(self, bool ind1, MX kk) -&gt; MX</span>
<span class="sd">          get_nz(self, bool ind1, Slice inner, MX outer) -&gt; MX</span>
<span class="sd">          get_nz(self, bool ind1, MX inner, Slice outer) -&gt; MX</span>
<span class="sd">          get_nz(self, bool ind1, MX inner, MX outer) -&gt; MX</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get_nz(self, bool ind1, IM kk)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          get_nz(self, bool ind1, int kk)</span>
<span class="sd">          get_nz(self, bool ind1, Slice kk)</span>
<span class="sd">          get_nz(self, bool ind1, MX kk)</span>
<span class="sd">          get_nz(self, bool ind1, Slice inner, MX outer)</span>
<span class="sd">          get_nz(self, bool ind1, MX inner, Slice outer)</span>
<span class="sd">          get_nz(self, bool ind1, MX inner, MX outer)</span>



<span class="sd">        Get a set of nonzeros</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set a set of nonzeros</span>

<span class="sd">          set_nz(self, MX m, bool ind1, int kk)</span>
<span class="sd">          set_nz(self, MX m, bool ind1, Slice kk)</span>
<span class="sd">          set_nz(self, MX m, bool ind1, IM kk)</span>
<span class="sd">          set_nz(self, MX m, bool ind1, MX kk)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_nz(self, MX m, bool ind1, IM kk)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_nz(self, MX m, bool ind1, int kk)</span>
<span class="sd">          set_nz(self, MX m, bool ind1, Slice kk)</span>
<span class="sd">          set_nz(self, MX m, bool ind1, MX kk)</span>



<span class="sd">        Set a set of nonzeros</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_set_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">einstein</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Computes an einstein dense tensor contraction.</span>

<span class="sd">          einstein(MX A, MX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; MX</span>
<span class="sd">          einstein(MX A, MX B, MX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; MX</span>


<span class="sd">        Computes the product: C_c = A_a + B_b where a b c are index/einstein</span>
<span class="sd">        notation in an encoded form</span>

<span class="sd">        For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj</span>

<span class="sd">        The encoded form uses strictly negative numbers to indicate labels. For the</span>
<span class="sd">        above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_einstein</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">einstein</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">einstein</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bspline_dual</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DM&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find first nonzero If failed, returns the number of rows.</span>

<span class="sd">        bspline_dual([float] x, [[float]] knots, [int] degree, dict opts) -&gt; DM</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_bspline_dual</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">bspline_dual</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">bspline_dual</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpn_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        interpn_linear([MX] x, MX v, [MX] xq, dict opts) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_interpn_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">interpn_linear</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">interpn_linear</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">printme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        printme(self, MX b) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_printme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">attachAssert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          returns itself, but with an assertion attached</span>

<span class="sd">          attachAssert(self, MX y, str fail_message) -&gt; MX</span>


<span class="sd">        If y does not evaluate to 1, a runtime error is raised</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_attachAssert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">monitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Monitor an expression Returns itself, but with the side effect of printing</span>

<span class="sd">          monitor(self, str comment) -&gt; MX</span>

<span class="sd">        the nonzeros along with a comment.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_monitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi_int &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an IM representation of a GetNonzeros or SetNonzeros node.</span>

<span class="sd">        mapping(self) -&gt; IM</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        set_max_depth(int eq_depth)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">set_max_depth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">set_max_depth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_max_depth() -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_max_depth</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_max_depth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        test_cast(casadi::SharedObjectInternal const * ptr) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">test_cast</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">test_cast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_input(Function f) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_input</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_free(Function f) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">get_free</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_free</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size1</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">size2</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot slice with None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;CasADi matrices are not iterable by design.</span>
<span class="s2">                      Did you mean to iterate over m.nz, with m IM/DM/SX?</span>
<span class="s2">                      Did you mean to iterate over horzsplit(m,1)/vertsplit(m,1) with m IM/DM/SX/MX?</span>
<span class="s2">                      &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">NZproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>




    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">1002.0</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">out_arr</span><span class="p">,</span><span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_arr</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39; where &#39;a&#39; is a numpy type. This is not supported, and cannot be supported without changing numpy.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

      <span class="k">if</span> <span class="s2">&quot;vectorized&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot; (vectorized)&quot;</span><span class="p">)]</span>

      <span class="n">conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;subtract&quot;</span><span class="p">:</span><span class="s2">&quot;sub&quot;</span><span class="p">,</span><span class="s2">&quot;power&quot;</span><span class="p">:</span><span class="s2">&quot;pow&quot;</span><span class="p">,</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span><span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">}</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">conversion</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">conversion</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">args</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>
      <span class="n">fun</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="n">conversion</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;multiply&quot;</span><span class="p">:</span> <span class="s2">&quot;mul&quot;</span><span class="p">,</span> <span class="s2">&quot;divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;true_divide&quot;</span><span class="p">:</span> <span class="s2">&quot;div&quot;</span><span class="p">,</span> <span class="s2">&quot;subtract&quot;</span><span class="p">:</span><span class="s2">&quot;sub&quot;</span><span class="p">,</span><span class="s2">&quot;power&quot;</span><span class="p">:</span><span class="s2">&quot;pow&quot;</span><span class="p">,</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">:</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span><span class="s2">&quot;less_equal&quot;</span><span class="p">:</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;less&quot;</span><span class="p">:</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;greater&quot;</span><span class="p">:</span> <span class="s2">&quot;gt&quot;</span><span class="p">}</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span>
      <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39; where &#39;a&#39; is a numpy type. This is not supported, and cannot be supported without changing numpy.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
      <span class="k">if</span> <span class="s2">&quot;vectorized&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot; (vectorized)&quot;</span><span class="p">)]</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">conversion</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">conversion</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;__&#39;</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;__call__&quot;</span>
        <span class="n">fun</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
      <span class="k">except</span><span class="p">:</span>
<span class="c1">#Fall back to numpy conversion</span>
        <span class="n">new_inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
          <span class="kn">import</span> <span class="nn">warnings</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Implicit conversion of symbolic CasADi type to numeric matrix not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;This may occur when you pass a CasADi object to a numpy function.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;Use an equivalent CasADi function instead of that numpy function.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
          <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">new_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">new_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">n</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">ufunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="o">.</span><span class="n">ufunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nin</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error with </span><span class="si">%s</span><span class="s2">. Looks like you are using an assignment operator, such as &#39;a+=b&#39;. This is not supported when &#39;a&#39; is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use &#39;a = a + b&#39;. &quot;</span> <span class="o">%</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;__array_custom__&#39;</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_custom__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span><span class="p">()</span>
          <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Implicit conversion of symbolic CasADi type to numeric matrix not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="o">+</span> <span class="s2">&quot;This may occur when you pass a CasADi object to a numpy function.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="o">+</span> <span class="s2">&quot;Use an equivalent CasADi function instead of that numpy function.&quot;</span><span class="p">)</span>


<span class="n">MX_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_swigregister</span>
<span class="n">MX_swigregister</span><span class="p">(</span><span class="n">MX</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create nodes by their ID.</span>

<span class="sd">    binary(int op, MX x, MX y) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_binary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create nodes by their ID.</span>

<span class="sd">    unary(int op, MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_unary</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a matrix with all inf</span>

<span class="sd">    inf(int nrow, int ncol) -&gt; MX</span>
<span class="sd">    inf((int,int) rc) -&gt; MX</span>
<span class="sd">    inf(Sparsity sp) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a matrix with all nan</span>

<span class="sd">    nan(int nrow, int ncol) -&gt; MX</span>
<span class="sd">    nan((int,int) rc) -&gt; MX</span>
<span class="sd">    nan(Sparsity sp) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_nan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    eye(int n) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_eye</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_einstein</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Computes an einstein dense tensor contraction.</span>

<span class="sd">      einstein(MX A, MX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; MX</span>
<span class="sd">      einstein(MX A, MX B, MX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; MX</span>


<span class="sd">    Computes the product: C_c = A_a + B_b where a b c are index/einstein</span>
<span class="sd">    notation in an encoded form</span>

<span class="sd">    For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj</span>

<span class="sd">    The encoded form uses strictly negative numbers to indicate labels. For the</span>
<span class="sd">    above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_einstein</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_bspline_dual</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DM&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find first nonzero If failed, returns the number of rows.</span>

<span class="sd">    bspline_dual([float] x, [[float]] knots, [int] degree, dict opts) -&gt; DM</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_bspline_dual</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_interpn_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    interpn_linear([MX] x, MX v, [MX] xq, dict opts) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_interpn_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    set_max_depth(int eq_depth)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_set_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_max_depth() -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_max_depth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    test_cast(casadi::SharedObjectInternal const * ptr) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_input(Function f) -&gt; [MX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_input</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">MX_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    get_free(Function f) -&gt; [MX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MX_get_free</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">attach_return_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s1">&#39;func_annotations&#39;</span><span class="p">)):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">func_annotations</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s1">&#39;func_annotations&#39;</span><span class="p">),</span><span class="nb">dict</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot annotate this python Method to be a sparsitygenerator. Method has func_annotations attribute with unknown type.&quot;</span><span class="p">)</span>
  <span class="n">f</span><span class="o">.</span><span class="n">func_annotations</span><span class="p">[</span><span class="s2">&quot;return&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
  <span class="k">return</span> <span class="n">f</span>

<span class="k">def</span> <span class="nf">pyevaluate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">attach_return_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pycallback</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">attach_return_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pyfunction</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span><span class="n">outputs</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

    <span class="nd">@pyevaluate</span>
    <span class="k">def</span> <span class="nf">fcustom</span><span class="p">(</span><span class="n">f2</span><span class="p">):</span>
      <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">([</span><span class="n">f2</span><span class="o">.</span><span class="n">getInput</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">n_in</span><span class="p">())])</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">n_out</span><span class="p">()):</span>
        <span class="n">f2</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span><span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
      <span class="n">Fun</span> <span class="o">=</span> <span class="n">CustomFunction</span><span class="p">(</span><span class="s2">&quot;CustomFunction&quot;</span><span class="p">,</span><span class="n">fcustom</span><span class="p">,</span><span class="n">inputs</span><span class="p">,</span><span class="n">outputs</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">Fun</span>

  <span class="k">return</span> <span class="n">wrap</span>

<span class="k">def</span> <span class="nf">PyFunction</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="p">{}):</span>
    <span class="nd">@pyevaluate</span>
    <span class="k">def</span> <span class="nf">fcustom</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
      <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">getOutput</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n_out</span><span class="p">())]</span>
      <span class="n">obj</span><span class="o">.</span><span class="n">evaluate</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">getInput</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n_in</span><span class="p">())],</span><span class="n">res</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">n_out</span><span class="p">()):</span> <span class="n">f</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span><span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">CustomFunction</span><span class="p">(</span><span class="s2">&quot;CustomFunction&quot;</span><span class="p">,</span> <span class="n">fcustom</span><span class="p">,</span>
                            <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Function object A Function instance is a general multiple-input, multiple-</span>


<span class="sd">    output function where each input and output can be a sparse matrix. .</span>

<span class="sd">    For an introduction to this class, see the CasADi user guide. Function is a</span>
<span class="sd">    reference counted and immutable class; copying a class instance is very</span>
<span class="sd">    cheap and its behavior (with some exceptions) is not affected by calling its</span>
<span class="sd">    member functions. Joel Andersson &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for derivative   | Internal         |</span>
<span class="sd">    |                  |                 | calculation.When |                  |</span>
<span class="sd">    |                  |                 | there is an      |                  |</span>
<span class="sd">    |                  |                 | option of either |                  |</span>
<span class="sd">    |                  |                 | using forward or |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | directional      |                  |</span>
<span class="sd">    |                  |                 | derivatives, the |                  |</span>
<span class="sd">    |                  |                 | condition ad_wei |                  |</span>
<span class="sd">    |                  |                 | ght*nf&lt;=(1-ad_we |                  |</span>
<span class="sd">    |                  |                 | ight)*na is used |                  |</span>
<span class="sd">    |                  |                 | where nf and na  |                  |</span>
<span class="sd">    |                  |                 | are estimates of |                  |</span>
<span class="sd">    |                  |                 | the number of    |                  |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | mode directional |                  |</span>
<span class="sd">    |                  |                 | derivatives      |                  |</span>
<span class="sd">    |                  |                 | needed. By       |                  |</span>
<span class="sd">    |                  |                 | default,         |                  |</span>
<span class="sd">    |                  |                 | ad_weight is     |                  |</span>
<span class="sd">    |                  |                 | calculated       |                  |</span>
<span class="sd">    |                  |                 | automatically,   |                  |</span>
<span class="sd">    |                  |                 | but this can be  |                  |</span>
<span class="sd">    |                  |                 | overridden by    |                  |</span>
<span class="sd">    |                  |                 | setting this     |                  |</span>
<span class="sd">    |                  |                 | option. In       |                  |</span>
<span class="sd">    |                  |                 | particular, 0    |                  |</span>
<span class="sd">    |                  |                 | means forcing    |                  |</span>
<span class="sd">    |                  |                 | forward mode and |                  |</span>
<span class="sd">    |                  |                 | 1 forcing        |                  |</span>
<span class="sd">    |                  |                 | reverse mode.    |                  |</span>
<span class="sd">    |                  |                 | Leave unset for  |                  |</span>
<span class="sd">    |                  |                 | (class specific) |                  |</span>
<span class="sd">    |                  |                 | heuristics.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for sparsity     | Internal         |</span>
<span class="sd">    |                  |                 | pattern          |                  |</span>
<span class="sd">    |                  |                 | calculation calc |                  |</span>
<span class="sd">    |                  |                 | ulation.Override |                  |</span>
<span class="sd">    |                  |                 | s default        |                  |</span>
<span class="sd">    |                  |                 | behavior. Set to |                  |</span>
<span class="sd">    |                  |                 | 0 and 1 to force |                  |</span>
<span class="sd">    |                  |                 | forward and      |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | respectively.    |                  |</span>
<span class="sd">    |                  |                 | Cf. option       |                  |</span>
<span class="sd">    |                  |                 | &quot;ad_weight&quot;.     |                  |</span>
<span class="sd">    |                  |                 | When set to -1,  |                  |</span>
<span class="sd">    |                  |                 | sparsity is      |                  |</span>
<span class="sd">    |                  |                 | completely       |                  |</span>
<span class="sd">    |                  |                 | ignored and      |                  |</span>
<span class="sd">    |                  |                 | dense matrices   |                  |</span>
<span class="sd">    |                  |                 | are used.        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler plugin  | Internal         |</span>
<span class="sd">    |                  |                 | to be used.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |</span>
<span class="sd">    |                  |                 | CasADi&#39;s AD. Use | Internal         |</span>
<span class="sd">    |                  |                 | together with    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;:   |                  |</span>
<span class="sd">    |                  |                 | 0. Note: Highly  |                  |</span>
<span class="sd">    |                  |                 | experimental.    |                  |</span>
<span class="sd">    |                  |                 | Syntax may break |                  |</span>
<span class="sd">    |                  |                 | often.           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |</span>
<span class="sd">    |                  |                 | a derivative of  | Internal         |</span>
<span class="sd">    |                  |                 | another          |                  |</span>
<span class="sd">    |                  |                 | function. The    |                  |</span>
<span class="sd">    |                  |                 | type of          |                  |</span>
<span class="sd">    |                  |                 | derivative       |                  |</span>
<span class="sd">    |                  |                 | (directional     |                  |</span>
<span class="sd">    |                  |                 | derivative,      |                  |</span>
<span class="sd">    |                  |                 | Jacobian) is     |                  |</span>
<span class="sd">    |                  |                 | inferred from    |                  |</span>
<span class="sd">    |                  |                 | the function     |                  |</span>
<span class="sd">    |                  |                 | name.            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump             | OT_BOOL         | Dump function to | casadi::Function |</span>
<span class="sd">    |                  |                 | file upon first  | Internal         |</span>
<span class="sd">    |                  |                 | evaluation.      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_dir         | OT_STRING       | Directory to     | casadi::Function |</span>
<span class="sd">    |                  |                 | dump             | Internal         |</span>
<span class="sd">    |                  |                 | inputs/outputs   |                  |</span>
<span class="sd">    |                  |                 | to. Make sure    |                  |</span>
<span class="sd">    |                  |                 | the directory    |                  |</span>
<span class="sd">    |                  |                 | exists [.]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_format      | OT_STRING       | Choose file      | casadi::Function |</span>
<span class="sd">    |                  |                 | format to dump   | Internal         |</span>
<span class="sd">    |                  |                 | matrices. See    |                  |</span>
<span class="sd">    |                  |                 | DM.from_file     |                  |</span>
<span class="sd">    |                  |                 | [mtx]            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | to file          |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs to file  |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_fd        | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation by   |                  |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | differencing.    |                  |</span>
<span class="sd">    |                  |                 | [default:        |                  |</span>
<span class="sd">    |                  |                 | false]]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_forward   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using forward    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobians of all |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | outputs with     |                  |</span>
<span class="sd">    |                  |                 | respect to all   |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | inputs - if      |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_reverse   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | transposed       |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using reverse    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_method        | OT_STRING       | Method for       | casadi::Function |</span>
<span class="sd">    |                  |                 | finite           | Internal         |</span>
<span class="sd">    |                  |                 | differencing     |                  |</span>
<span class="sd">    |                  |                 | [default         |                  |</span>
<span class="sd">    |                  |                 | &#39;central&#39;]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_options       | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | difference       |                  |</span>
<span class="sd">    |                  |                 | instance         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | forward_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | forward mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option           | Internal         |</span>
<span class="sd">    |                  |                 | (ignored):       |                  |</span>
<span class="sd">    |                  |                 | Statistics are   |                  |</span>
<span class="sd">    |                  |                 | now always       |                  |</span>
<span class="sd">    |                  |                 | collected.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when the         | Internal         |</span>
<span class="sd">    |                  |                 | numerical values |                  |</span>
<span class="sd">    |                  |                 | of the inputs    |                  |</span>
<span class="sd">    |                  |                 | don&#39;t make sense |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each input if it | Internal         |</span>
<span class="sd">    |                  |                 | should be        |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each output if   | Internal         |</span>
<span class="sd">    |                  |                 | it should be     |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |</span>
<span class="sd">    |                  |                 | for a number of  | Internal         |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | directions, it   |                  |</span>
<span class="sd">    |                  |                 | may be cheaper   |                  |</span>
<span class="sd">    |                  |                 | to compute first |                  |</span>
<span class="sd">    |                  |                 | the full         |                  |</span>
<span class="sd">    |                  |                 | jacobian and     |                  |</span>
<span class="sd">    |                  |                 | then multiply    |                  |</span>
<span class="sd">    |                  |                 | with seeds,      |                  |</span>
<span class="sd">    |                  |                 | rather than      |                  |</span>
<span class="sd">    |                  |                 | obtain the       |                  |</span>
<span class="sd">    |                  |                 | requested        |                  |</span>
<span class="sd">    |                  |                 | directions in a  |                  |</span>
<span class="sd">    |                  |                 | straightforward  |                  |</span>
<span class="sd">    |                  |                 | manner. Casadi   |                  |</span>
<span class="sd">    |                  |                 | uses a heuristic |                  |</span>
<span class="sd">    |                  |                 | to decide which  |                  |</span>
<span class="sd">    |                  |                 | is cheaper. A    |                  |</span>
<span class="sd">    |                  |                 | high value of    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;    |                  |</span>
<span class="sd">    |                  |                 | makes it less    |                  |</span>
<span class="sd">    |                  |                 | likely for the   |                  |</span>
<span class="sd">    |                  |                 | heurstic to      |                  |</span>
<span class="sd">    |                  |                 | chose the full   |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy. The    |                  |</span>
<span class="sd">    |                  |                 | special value -1 |                  |</span>
<span class="sd">    |                  |                 | indicates never  |                  |</span>
<span class="sd">    |                  |                 | to use the full  |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler to      | Internal         |</span>
<span class="sd">    |                  |                 | speed up the     |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |</span>
<span class="sd">    |                  |                 | temporary source | Internal         |</span>
<span class="sd">    |                  |                 | file that jit    |                  |</span>
<span class="sd">    |                  |                 | creates.         |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_name         | OT_STRING       | The file name    | casadi::Function |</span>
<span class="sd">    |                  |                 | used to write    | Internal         |</span>
<span class="sd">    |                  |                 | out code. The    |                  |</span>
<span class="sd">    |                  |                 | actual file      |                  |</span>
<span class="sd">    |                  |                 | names used       |                  |</span>
<span class="sd">    |                  |                 | depend on &#39;jit_t |                  |</span>
<span class="sd">    |                  |                 | emp_suffix&#39; and  |                  |</span>
<span class="sd">    |                  |                 | include          |                  |</span>
<span class="sd">    |                  |                 | extensions.      |                  |</span>
<span class="sd">    |                  |                 | Default:         |                  |</span>
<span class="sd">    |                  |                 | &#39;jit_tmp&#39;        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_options      | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | jit compiler.    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_serialize    | OT_STRING       | Specify          | casadi::Function |</span>
<span class="sd">    |                  |                 | behaviour when   | Internal         |</span>
<span class="sd">    |                  |                 | serializing a    |                  |</span>
<span class="sd">    |                  |                 | jitted function: |                  |</span>
<span class="sd">    |                  |                 | SOURCE|link|embe |                  |</span>
<span class="sd">    |                  |                 | d.               |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |</span>
<span class="sd">    |                  |                 | (seemingly       | Internal         |</span>
<span class="sd">    |                  |                 | random) filename |                  |</span>
<span class="sd">    |                  |                 | suffix for       |                  |</span>
<span class="sd">    |                  |                 | generated code   |                  |</span>
<span class="sd">    |                  |                 | and libraries.   |                  |</span>
<span class="sd">    |                  |                 | This is desired  |                  |</span>
<span class="sd">    |                  |                 | for thread-      |                  |</span>
<span class="sd">    |                  |                 | safety. This     |                  |</span>
<span class="sd">    |                  |                 | behaviour may    |                  |</span>
<span class="sd">    |                  |                 | defeat caching   |                  |</span>
<span class="sd">    |                  |                 | compiler         |                  |</span>
<span class="sd">    |                  |                 | wrappers.        |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |</span>
<span class="sd">    |                  |                 | maximum number   | Internal         |</span>
<span class="sd">    |                  |                 | of directions    |                  |</span>
<span class="sd">    |                  |                 | for derivative   |                  |</span>
<span class="sd">    |                  |                 | functions.       |                  |</span>
<span class="sd">    |                  |                 | Overrules the    |                  |</span>
<span class="sd">    |                  |                 | builtin optimize |                  |</span>
<span class="sd">    |                  |                 | d_num_dir.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_in         | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_out        | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs          |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_time       | OT_BOOL         | print            | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time. Implies    |                  |</span>
<span class="sd">    |                  |                 | record_time.     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | record_time      | OT_BOOL         | record           | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time, for        |                  |</span>
<span class="sd">    |                  |                 | retrieval with   |                  |</span>
<span class="sd">    |                  |                 | stats() .        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when NaN or Inf  | Internal         |</span>
<span class="sd">    |                  |                 | appears during   |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | reverse_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |</span>
<span class="sd">    |                  |                 | field that can   | Internal         |</span>
<span class="sd">    |                  |                 | be used to       |                  |</span>
<span class="sd">    |                  |                 | identify the     |                  |</span>
<span class="sd">    |                  |                 | function or pass |                  |</span>
<span class="sd">    |                  |                 | additional       |                  |</span>
<span class="sd">    |                  |                 | information      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | verbose          | OT_BOOL         | Verbose          | casadi::Function |</span>
<span class="sd">    |                  |                 | evaluation  for  | Internal         |</span>
<span class="sd">    |                  |                 | debugging        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    C++ includes: function.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">jit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          To resolve ambiguity on some compilers.</span>

<span class="sd">          jit(str name, str body, [str] name_in, [str] name_out, dict opts) -&gt; Function</span>
<span class="sd">          jit(str name, str body, [str] name_in, [str] name_out, [Sparsity] sparsity_in, [Sparsity] sparsity_out, dict opts) -&gt; Function</span>


<span class="sd">        Create a just-in-time compiled function from a C language string The names</span>
<span class="sd">        and sparsity patterns of all the inputs and outputs must be provided. If</span>
<span class="sd">        sparsities are not provided, all inputs and outputs are assumed to be</span>
<span class="sd">        scalar. Only specify the function body, assuming that input and output</span>
<span class="sd">        nonzeros are stored in arrays with the specified naming convension. The data</span>
<span class="sd">        type used is &#39;casadi_real&#39;, which is typically equal to &#39;double` or another</span>
<span class="sd">        data type with the same API as &#39;double&#39;.</span>

<span class="sd">        Inputs may be null pointers. This means that the all entries are zero.</span>
<span class="sd">        Outputs may be null points. This means that the corresponding result can be</span>
<span class="sd">        ignored.</span>

<span class="sd">        If an error occurs in the evaluation, issue &quot;return 1;&quot;;</span>

<span class="sd">        The final generated function will have a structure similar to:</span>

<span class="sd">        casadi_int fname(const casadi_real** arg, casadi_real** res, casadi_int* iw,</span>
<span class="sd">        casadi_real* w, void* mem) { const casadi_real *x1, *x2; casadi_real *r1,</span>
<span class="sd">        *r2; x1 = *arg++; x2 = *arg++; r1 = *res++; r2 = *res++; &lt;FUNCTION_BODY&gt;</span>
<span class="sd">        return 0; }</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_jit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">jit</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">jit</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Function</span>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand a function to SX.</span>

<span class="sd">        expand(self) -&gt; Function</span>
<span class="sd">        expand(self, str name, dict opts) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of function inputs.</span>

<span class="sd">        n_in(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_n_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of function outputs.</span>

<span class="sd">        n_out(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_n_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size1_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get input dimension.</span>

<span class="sd">        size1_in(self, int ind) -&gt; int</span>
<span class="sd">        size1_in(self, str iname) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_size1_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size2_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get input dimension.</span>

<span class="sd">        size2_in(self, int ind) -&gt; int</span>
<span class="sd">        size2_in(self, str iname) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_size2_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; casadi_int,casadi_int &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get input dimension.</span>

<span class="sd">        size_in(self, int ind) -&gt; (int,int)</span>
<span class="sd">        size_in(self, str iname) -&gt; (int,int)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_size_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size1_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get output dimension.</span>

<span class="sd">        size1_out(self, int ind) -&gt; int</span>
<span class="sd">        size1_out(self, str oname) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_size1_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size2_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get output dimension.</span>

<span class="sd">        size2_out(self, int ind) -&gt; int</span>
<span class="sd">        size2_out(self, str oname) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_size2_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">size_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; casadi_int,casadi_int &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get output dimension.</span>

<span class="sd">        size_out(self, int ind) -&gt; (int,int)</span>
<span class="sd">        size_out(self, str oname) -&gt; (int,int)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_size_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get number of input nonzeros.</span>

<span class="sd">          nnz_in(self) -&gt; int</span>
<span class="sd">          nnz_in(self, int ind) -&gt; int</span>
<span class="sd">          nnz_in(self, str iname) -&gt; int</span>


<span class="sd">        For a particular input or for all of the inputs</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_nnz_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nnz_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get number of output nonzeros.</span>

<span class="sd">          nnz_out(self) -&gt; int</span>
<span class="sd">          nnz_out(self, int ind) -&gt; int</span>
<span class="sd">          nnz_out(self, str oname) -&gt; int</span>


<span class="sd">        For a particular output or for all of the outputs</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_nnz_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">numel_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get number of input elements.</span>

<span class="sd">          numel_in(self) -&gt; int</span>
<span class="sd">          numel_in(self, int ind) -&gt; int</span>
<span class="sd">          numel_in(self, str iname) -&gt; int</span>


<span class="sd">        For a particular input or for all of the inputs</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_numel_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">numel_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get number of output elements.</span>

<span class="sd">          numel_out(self) -&gt; int</span>
<span class="sd">          numel_out(self, int ind) -&gt; int</span>
<span class="sd">          numel_out(self, str oname) -&gt; int</span>


<span class="sd">        For a particular output or for all of the outputs</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_numel_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">name_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get input scheme name by index.</span>

<span class="sd">          name_in(self) -&gt; [str]</span>
<span class="sd">          name_in(self, int ind) -&gt; str</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          name_in(self, int ind)</span>



<span class="sd">        Get input scheme name by index.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          name_in(self)</span>



<span class="sd">        Get input scheme.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_name_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">name_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get output scheme name by index.</span>

<span class="sd">          name_out(self) -&gt; [str]</span>
<span class="sd">          name_out(self, int ind) -&gt; str</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          name_out(self, int ind)</span>



<span class="sd">        Get output scheme name by index.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          name_out(self)</span>



<span class="sd">        Get output scheme.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_name_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">index_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Find the index for a string describing a particular entry of an input</span>

<span class="sd">          index_in(self, str name) -&gt; int</span>

<span class="sd">        scheme.</span>

<span class="sd">        example: schemeEntry(&quot;x_opt&quot;) -&gt; returns NLPSOL_X if FunctionInternal</span>
<span class="sd">        adheres to SCHEME_NLPINput</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_index_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">index_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Find the index for a string describing a particular entry of an output</span>

<span class="sd">          index_out(self, str name) -&gt; int</span>

<span class="sd">        scheme.</span>

<span class="sd">        example: schemeEntry(&quot;x_opt&quot;) -&gt; returns NLPSOL_X if FunctionInternal</span>
<span class="sd">        adheres to SCHEME_NLPINput</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_index_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">default_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get default input value.</span>

<span class="sd">        default_in(self, int ind) -&gt; float</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_default_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">max_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get largest input value.</span>

<span class="sd">        max_in(self, int ind) -&gt; float</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_max_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">min_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get smallest input value.</span>

<span class="sd">        min_in(self, int ind) -&gt; float</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_min_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get sparsity of a given input.</span>

<span class="sd">        sparsity_in(self, int ind) -&gt; Sparsity</span>
<span class="sd">        sparsity_in(self, str iname) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sparsity_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get sparsity of a given output.</span>

<span class="sd">        sparsity_out(self, int ind) -&gt; Sparsity</span>
<span class="sd">        sparsity_out(self, str iname) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sparsity_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_diff_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; bool,std::allocator&lt; bool &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get differentiability of inputs/output.</span>

<span class="sd">        is_diff_in(self) -&gt; [bool]</span>
<span class="sd">        is_diff_in(self, int ind) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_is_diff_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_diff_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; bool,std::allocator&lt; bool &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get differentiability of inputs/output.</span>

<span class="sd">        is_diff_out(self) -&gt; [bool]</span>
<span class="sd">        is_diff_out(self, int ind) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_is_diff_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        factory(self, str name, [str] s_in, [str] s_out, dict:[str] aux, dict opts) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">oracle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get oracle.</span>

<span class="sd">        oracle(self) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_oracle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap in an Function instance consisting of only one MX call.</span>

<span class="sd">        wrap(self) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">wrap_as_needed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap in a Function with options.</span>

<span class="sd">        wrap_as_needed(self, dict opts) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_wrap_as_needed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">which_depends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; bool,std::allocator&lt; bool &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Which variables enter with some order.</span>

<span class="sd">          which_depends(self, str s_in, [str] s_out, int order, bool tr) -&gt; [bool]</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        order:  Only 1 (linear) and 2 (nonlinear) allowed</span>

<span class="sd">        tr:  Flip the relationship. Return which expressions contain the variables</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_which_depends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print dimensions of inputs and outputs.</span>

<span class="sd">        print_dimensions(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_print_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print options to a stream.</span>

<span class="sd">        print_options(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_print_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">print_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print all information there is to know about a certain option.</span>

<span class="sd">        print_option(self, str name)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_print_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">uses_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do the derivative functions need nondifferentiated outputs?</span>

<span class="sd">        uses_output(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_uses_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">jacobian_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Generate a Jacobian function of output oind with respect to input iind.</span>

<span class="sd">          jacobian_old(self, int iind, int oind) -&gt; Function</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        iind:  The index of the input</span>

<span class="sd">        oind:  The index of the output Legacy function: To be deprecated in a future</span>
<span class="sd">        version of CasADi. Exists only for compatibility with Function::jacobian</span>
<span class="sd">        pre-CasADi 3.2</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_jacobian_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">hessian_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Generate a Hessian function of output oind with respect to input iind.</span>

<span class="sd">          hessian_old(self, int iind, int oind) -&gt; Function</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        iind:  The index of the input</span>

<span class="sd">        oind:  The index of the output Legacy function: To be deprecated in a future</span>
<span class="sd">        version of CasADi. Exists only for compatibility with Function::hessian pre-</span>
<span class="sd">        CasADi 3.2</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_hessian_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Generate a Jacobian function of all the inputs elements with respect to all</span>

<span class="sd">          jacobian(self) -&gt; Function</span>

<span class="sd">        the output elements).</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">jac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Calculate all Jacobian blocks Generates a function that takes all non-</span>

<span class="sd">          jac(self) -&gt; Function</span>

<span class="sd">        differentiated inputs and outputs and calculates all Jacobian blocks. Inputs</span>
<span class="sd">        that are not needed by the routine are all-zero sparse matrices with the</span>
<span class="sd">        correct dimensions. Output blocks that are not calculated, e.g. if the</span>
<span class="sd">        corresponding input or output is marked non-differentiated are also all-zero</span>
<span class="sd">        sparse. The Jacobian blocks are sorted starting by all the blocks for the</span>
<span class="sd">        first output, then all the blocks for the second output and so on. E.g.</span>
<span class="sd">        f:(x,y)-&gt;(r,s) results in the function jac_f:(x,y,r,s)-&gt;(dr_dx, dr_dy,</span>
<span class="sd">        ds_dx, ds_dy) This function is cached.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Generate a Jacobian function of output oind with respect to input iind.</span>

<span class="sd">          call(self, dict:DM arg, bool always_inline, bool never_inline) -&gt; dict:DM</span>
<span class="sd">          call(self, [DM] arg, bool always_inline, bool never_inline) -&gt; [DM]</span>
<span class="sd">          call(self, [SX] arg, bool always_inline, bool never_inline) -&gt; [SX]</span>
<span class="sd">          call(self, dict:SX arg, bool always_inline, bool never_inline) -&gt; dict:SX</span>
<span class="sd">          call(self, dict:MX arg, bool always_inline, bool never_inline) -&gt; dict:MX</span>
<span class="sd">          call(self, [MX] arg, bool always_inline, bool never_inline) -&gt; [MX]</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        iind:  The index of the input</span>

<span class="sd">        oind:  The index of the output Legacy function: To be deprecated in a future</span>
<span class="sd">        version of CasADi. Exists only for compatibility with Function::jacobian</span>
<span class="sd">        pre-CasADi 3.2</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          call(self, [DM] arg, bool always_inline, bool never_inline)</span>



<span class="sd">        Evaluate the function symbolically or numerically.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          call(self, dict:DM arg, bool always_inline, bool never_inline)</span>
<span class="sd">          call(self, [SX] arg, bool always_inline, bool never_inline)</span>
<span class="sd">          call(self, dict:SX arg, bool always_inline, bool never_inline)</span>
<span class="sd">          call(self, dict:MX arg, bool always_inline, bool never_inline)</span>
<span class="sd">          call(self, [MX] arg, bool always_inline, bool never_inline)</span>



<span class="sd">        Generate a Jacobian function of output oind with respect to input iind.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        iind:  The index of the input</span>

<span class="sd">        oind:  The index of the output Legacy function: To be deprecated in a future</span>
<span class="sd">        version of CasADi. Exists only for compatibility with Function::jacobian</span>
<span class="sd">        pre-CasADi 3.2</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">mapsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Evaluate symbolically in parallel and sum (matrix graph)</span>

<span class="sd">          mapsum(self, [MX] x, str parallelization) -&gt; [MX]</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        parallelization:  Type of parallelization used: unroll|serial|openmp</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_mapsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">mapaccum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a mapaccumulated version of this function.</span>

<span class="sd">          mapaccum(self, int N, dict opts) -&gt; Function</span>
<span class="sd">          mapaccum(self, str name, int N, dict opts) -&gt; Function</span>
<span class="sd">          mapaccum(self, str name, int N, int n_accum, dict opts) -&gt; Function</span>
<span class="sd">          mapaccum(self, str name, int n, [str] accum_in, [str] accum_out, dict opts) -&gt; Function</span>
<span class="sd">          mapaccum(self, str name, int n, [int] accum_in, [int] accum_out, dict opts) -&gt; Function</span>


<span class="sd">        Suppose the function has a signature of:</span>

<span class="sd">        ::</span>

<span class="sd">             f: (x, u) -&gt; (x_next , y )</span>




<span class="sd">        The the mapaccumulated version has the signature:</span>

<span class="sd">        ::</span>

<span class="sd">             F: (x0, U) -&gt; (X , Y )</span>

<span class="sd">              with</span>
<span class="sd">                  U: horzcat([u0, u1, ..., u_(N-1)])</span>
<span class="sd">                  X: horzcat([x1, x2, ..., x_N])</span>
<span class="sd">                  Y: horzcat([y0, y1, ..., y_(N-1)])</span>

<span class="sd">              and</span>
<span class="sd">                  x1, y0 &lt;- f(x0, u0)</span>
<span class="sd">                  x2, y1 &lt;- f(x1, u1)</span>
<span class="sd">                  ...</span>
<span class="sd">                  x_N, y_(N-1) &lt;- f(x_(N-1), u_(N-1))</span>




<span class="sd">        Mapaccum has the following benefits over writing an equivalent for- loop:</span>
<span class="sd">        much faster at construction time</span>

<span class="sd">        potentially much faster compilation times (for codegen)</span>

<span class="sd">        offers a trade-off between memory and evaluation time</span>

<span class="sd">        The base (settable through the options dictionary, default 10), is used to</span>
<span class="sd">        create a tower of function calls, containing unrolled for- loops of length</span>
<span class="sd">        maximum base.</span>

<span class="sd">        This technique is much more scalable in terms of memory-usage, but slightly</span>
<span class="sd">        slower at evaluation, than a plain for-loop. The effect is similar to that</span>
<span class="sd">        of a for-loop with a check-pointing instruction after each chunk of</span>
<span class="sd">        iterations with size base.</span>

<span class="sd">        Set base to -1 to unroll all the way; no gains in memory efficiency here.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_mapaccum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a mapaccumulated version of this function.</span>

<span class="sd">          fold(self, int N, dict opts) -&gt; Function</span>


<span class="sd">        Suppose the function has a signature of:</span>

<span class="sd">        ::</span>

<span class="sd">             f: (x, u) -&gt; (x_next , y )</span>




<span class="sd">        The the mapaccumulated version has the signature:</span>

<span class="sd">        ::</span>

<span class="sd">             F: (x0, U) -&gt; (X , Y )</span>

<span class="sd">              with</span>
<span class="sd">                  U: horzcat([u0, u1, ..., u_(N-1)])</span>
<span class="sd">                  X: horzcat([x1, x2, ..., x_N])</span>
<span class="sd">                  Y: horzcat([y0, y1, ..., y_(N-1)])</span>

<span class="sd">              and</span>
<span class="sd">                  x1, y0 &lt;- f(x0, u0)</span>
<span class="sd">                  x2, y1 &lt;- f(x1, u1)</span>
<span class="sd">                  ...</span>
<span class="sd">                  x_N, y_(N-1) &lt;- f(x_(N-1), u_(N-1))</span>




<span class="sd">        Mapaccum has the following benefits over writing an equivalent for- loop:</span>
<span class="sd">        much faster at construction time</span>

<span class="sd">        potentially much faster compilation times (for codegen)</span>

<span class="sd">        offers a trade-off between memory and evaluation time</span>

<span class="sd">        The base (settable through the options dictionary, default 10), is used to</span>
<span class="sd">        create a tower of function calls, containing unrolled for- loops of length</span>
<span class="sd">        maximum base.</span>

<span class="sd">        This technique is much more scalable in terms of memory-usage, but slightly</span>
<span class="sd">        slower at evaluation, than a plain for-loop. The effect is similar to that</span>
<span class="sd">        of a for-loop with a check-pointing instruction after each chunk of</span>
<span class="sd">        iterations with size base.</span>

<span class="sd">        Set base to -1 to unroll all the way; no gains in memory efficiency here.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Map with reduction A subset of the inputs are non-repeated and a subset of</span>

<span class="sd">          map(self, int n, str parallelization) -&gt; Function</span>
<span class="sd">          map(self, int n, [bool] reduce_in, [bool] reduce_out, dict opts) -&gt; Function</span>
<span class="sd">          map(self, int n, str parallelization, int max_num_threads) -&gt; Function</span>
<span class="sd">          map(self, str name, str parallelization, int n, [str] reduce_in, [str] reduce_out, dict opts) -&gt; Function</span>
<span class="sd">          map(self, str name, str parallelization, int n, [int] reduce_in, [int] reduce_out, dict opts) -&gt; Function</span>

<span class="sd">        the outputs summed up.</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          map(self, int n, str parallelization, int max_num_threads)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          map(self, int n, str parallelization)</span>



<span class="sd">        Create a mapped version of this function.</span>

<span class="sd">        Suppose the function has a signature of:</span>

<span class="sd">        ::</span>

<span class="sd">             f: (a, p) -&gt; ( s )</span>




<span class="sd">        The the mapped version has the signature:</span>

<span class="sd">        ::</span>

<span class="sd">             F: (A, P) -&gt; (S )</span>

<span class="sd">              with</span>
<span class="sd">                  A: horzcat([a0, a1, ..., a_(N-1)])</span>
<span class="sd">                  P: horzcat([p0, p1, ..., p_(N-1)])</span>
<span class="sd">                  S: horzcat([s0, s1, ..., s_(N-1)])</span>
<span class="sd">              and</span>
<span class="sd">                  s0 &lt;- f(a0, p0)</span>
<span class="sd">                  s1 &lt;- f(a1, p1)</span>
<span class="sd">                  ...</span>
<span class="sd">                  s_(N-1) &lt;- f(a_(N-1), p_(N-1))</span>




<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        parallelization:  Type of parallelization used: unroll|serial|openmp</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          map(self, int n, [bool] reduce_in, [bool] reduce_out, dict opts)</span>
<span class="sd">          map(self, str name, str parallelization, int n, [str] reduce_in, [str] reduce_out, dict opts)</span>
<span class="sd">          map(self, str name, str parallelization, int n, [int] reduce_in, [int] reduce_out, dict opts)</span>



<span class="sd">        Map with reduction A subset of the inputs are non-repeated and a subset of</span>
<span class="sd">        the outputs summed up.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns a new function with a selection of inputs/outputs of the original</span>

<span class="sd">        slice(self, str name, [int] order_in, [int] order_out, dict opts) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        conditional(str name, [Function] f, Function f_def, dict opts) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_conditional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">conditional</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bspline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        bspline(str name, [[float]] knots, [float] coeffs, [int] degree, int m, dict opts) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_bspline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">bspline</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">bspline</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">if_else</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        if_else(str name, Function f_true, Function f_false, dict opts) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_if_else</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">if_else</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">if_else</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a function that calculates nfwd forward derivatives.</span>

<span class="sd">          forward(self, int nfwd) -&gt; Function</span>


<span class="sd">        Returns a function with n_in + n_out + n_in inputs and nfwd outputs. The</span>
<span class="sd">        first n_in inputs correspond to nondifferentiated inputs. The next n_out</span>
<span class="sd">        inputs correspond to nondifferentiated outputs. and the last n_in inputs</span>
<span class="sd">        correspond to forward seeds, stacked horizontally The n_out outputs</span>
<span class="sd">        correspond to forward sensitivities, stacked horizontally. * (n_in = n_in(),</span>
<span class="sd">        n_out = n_out())</span>

<span class="sd">        The functions returned are cached, meaning that if called multiple timed</span>
<span class="sd">        with the same value, then multiple references to the same function will be</span>
<span class="sd">        returned.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a function that calculates nadj adjoint derivatives.</span>

<span class="sd">          reverse(self, int nadj) -&gt; Function</span>


<span class="sd">        Returns a function with n_in + n_out + n_out inputs and n_in outputs. The</span>
<span class="sd">        first n_in inputs correspond to nondifferentiated inputs. The next n_out</span>
<span class="sd">        inputs correspond to nondifferentiated outputs. and the last n_out inputs</span>
<span class="sd">        correspond to adjoint seeds, stacked horizontally The n_in outputs</span>
<span class="sd">        correspond to adjoint sensitivities, stacked horizontally. * (n_in = n_in(),</span>
<span class="sd">        n_out = n_out())</span>

<span class="sd">        (n_in = n_in(), n_out = n_out())</span>

<span class="sd">        The functions returned are cached, meaning that if called multiple timed</span>
<span class="sd">        with the same value, then multiple references to the same function will be</span>
<span class="sd">        returned.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get, if necessary generate, the sparsity of a Jacobian block</span>

<span class="sd">        sparsity_jac(self, str iind, int oind, bool compact, bool symmetric) -&gt; Sparsity</span>
<span class="sd">        sparsity_jac(self, int iind, int oind, bool compact, bool symmetric) -&gt; Sparsity</span>
<span class="sd">        sparsity_jac(self, int iind, str oind, bool compact, bool symmetric) -&gt; Sparsity</span>
<span class="sd">        sparsity_jac(self, str iind, str oind, bool compact, bool symmetric) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sparsity_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export / Generate C code for the function.</span>

<span class="sd">        generate(self, dict opts) -&gt; str</span>
<span class="sd">        generate(self, str fname, dict opts) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">generate_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export / Generate C code for the dependency function.</span>

<span class="sd">        generate_dependencies(self, str fname, dict opts) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_generate_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">generate_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::DM,std::allocator&lt; casadi::DM &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export an input file that can be passed to generate C code with a main.</span>

<span class="sd">          generate_in(self, str fname) -&gt; [DM]</span>
<span class="sd">          generate_in(self, str fname, [DM] arg)</span>


<span class="sd">        generate_out  convert_in to convert between dict/map and vector</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_generate_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">generate_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::DM,std::allocator&lt; casadi::DM &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export an output file that can be checked with generated C code output.</span>

<span class="sd">          generate_out(self, str fname) -&gt; [DM]</span>
<span class="sd">          generate_out(self, str fname, [DM] arg)</span>


<span class="sd">        generate_in  convert_out to convert between dict/map and vector</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_generate_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize.</span>

<span class="sd">        serialize(self, dict opts) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export function in specific language.</span>

<span class="sd">          save(self, str fname, dict opts)</span>


<span class="sd">        Only allowed for (a subset of) SX/MX Functions</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Export function in specific language.</span>

<span class="sd">          export_code(self, str lang, dict options) -&gt; str</span>
<span class="sd">          export_code(self, str lang, str fname, dict options)</span>


<span class="sd">        Only allowed for (a subset of) SX/MX Functions</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_export_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all statistics obtained at the end of the last evaluate call.</span>

<span class="sd">        stats(self, int mem) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sx_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::SX,std::allocator&lt; casadi::SX &gt; &gt; const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get symbolic primitives equivalent to the input expressions There is no</span>

<span class="sd">          sx_in(self) -&gt; [SX]</span>
<span class="sd">          sx_in(self, int iind) -&gt; SX</span>
<span class="sd">          sx_in(self, str iname) -&gt; SX</span>

<span class="sd">        guarantee that subsequent calls return unique answers.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sx_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">mx_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt; const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get symbolic primitives equivalent to the input expressions There is no</span>

<span class="sd">          mx_in(self) -&gt; [MX]</span>
<span class="sd">          mx_in(self, int ind) -&gt; MX</span>
<span class="sd">          mx_in(self, str iname) -&gt; MX</span>

<span class="sd">        guarantee that subsequent calls return unique answers.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_mx_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sx_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::SX,std::allocator&lt; casadi::SX &gt; &gt; const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get symbolic primitives equivalent to the output expressions There is no</span>

<span class="sd">          sx_out(self) -&gt; [SX]</span>
<span class="sd">          sx_out(self, int oind) -&gt; SX</span>
<span class="sd">          sx_out(self, str oname) -&gt; SX</span>

<span class="sd">        guarantee that subsequent calls return unique answers.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sx_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">mx_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt; const&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get symbolic primitives equivalent to the output expressions There is no</span>

<span class="sd">          mx_out(self) -&gt; [MX]</span>
<span class="sd">          mx_out(self, int ind) -&gt; MX</span>
<span class="sd">          mx_out(self, str oname) -&gt; MX</span>

<span class="sd">        guarantee that subsequent calls return unique answers.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_mx_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nz_from_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from/to flat vector of input/output nonzeros.</span>

<span class="sd">        nz_from_in(self, [DM] arg) -&gt; [float]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_nz_from_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nz_from_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from/to flat vector of input/output nonzeros.</span>

<span class="sd">        nz_from_out(self, [DM] arg) -&gt; [float]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_nz_from_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nz_to_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::DM,std::allocator&lt; casadi::DM &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from/to flat vector of input/output nonzeros.</span>

<span class="sd">        nz_to_in(self, [float] arg) -&gt; [DM]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_nz_to_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nz_to_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::DM,std::allocator&lt; casadi::DM &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from/to flat vector of input/output nonzeros.</span>

<span class="sd">        nz_to_out(self, [float] arg) -&gt; [DM]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_nz_to_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">convert_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Convert from/to input/output lists/map.</span>

<span class="sd">          convert_in(self, dict:DM arg) -&gt; [DM]</span>
<span class="sd">          convert_in(self, [DM] arg) -&gt; dict:DM</span>
<span class="sd">          convert_in(self, [SX] arg) -&gt; dict:SX</span>
<span class="sd">          convert_in(self, dict:SX arg) -&gt; [SX]</span>
<span class="sd">          convert_in(self, dict:MX arg) -&gt; [MX]</span>
<span class="sd">          convert_in(self, [MX] arg) -&gt; dict:MX</span>


<span class="sd">        Will raise an error when an unknown key is used or a list has incorrect</span>
<span class="sd">        size. Does not perform sparsity checking.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_convert_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">convert_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Convert from/to input/output lists/map.</span>

<span class="sd">          convert_out(self, dict:DM arg) -&gt; [DM]</span>
<span class="sd">          convert_out(self, [DM] arg) -&gt; dict:DM</span>
<span class="sd">          convert_out(self, [SX] arg) -&gt; dict:SX</span>
<span class="sd">          convert_out(self, dict:SX arg) -&gt; [SX]</span>
<span class="sd">          convert_out(self, dict:MX arg) -&gt; [MX]</span>
<span class="sd">          convert_out(self, [MX] arg) -&gt; dict:MX</span>


<span class="sd">        Will raise an error when an unknown key is used or a list has incorrect</span>
<span class="sd">        size. Does not perform sparsity checking.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_convert_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the function have free variables.</span>

<span class="sd">        has_free(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_has_free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string,std::allocator&lt; std::string &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get free variables as a string.</span>

<span class="sd">        get_free(self) -&gt; [str]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_get_free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">free_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::SX,std::allocator&lt; casadi::SX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the free variables of the function.</span>

<span class="sd">        free_sx(self) -&gt; [SX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_free_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">free_mx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the free variables of the function.</span>

<span class="sd">        free_mx(self) -&gt; [MX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_free_mx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">generate_lifted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the functions needed for the Lifted Newton method.</span>

<span class="sd">        generate_lifted(self) -&gt; (Function OUTPUT, Function OUTPUT)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_generate_lifted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of nodes in the algorithm.</span>

<span class="sd">        n_nodes(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">n_instructions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of instruction in the algorithm (SXFunction/MXFunction)</span>

<span class="sd">        n_instructions(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_n_instructions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instruction_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identifier index of the instruction (SXFunction/MXFunction)</span>

<span class="sd">        instruction_id(self, int k) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_instruction_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instruction_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Locations in the work vector for the inputs of the instruction</span>

<span class="sd">          instruction_input(self, int k) -&gt; [int]</span>

<span class="sd">        (SXFunction/MXFunction)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_instruction_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instruction_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the floating point output argument of an instruction ( SXFunction)</span>

<span class="sd">        instruction_constant(self, int k) -&gt; float</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_instruction_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instruction_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Location in the work vector for the output of the instruction</span>

<span class="sd">          instruction_output(self, int k) -&gt; [int]</span>

<span class="sd">        (SXFunction/MXFunction)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_instruction_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instruction_MX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the MX node corresponding to an instruction ( MXFunction)</span>

<span class="sd">        instruction_MX(self, int k) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_instruction_MX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instructions_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::SX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the SX node corresponding to all instructions ( SXFunction)</span>

<span class="sd">          instructions_sx(self) -&gt; SX</span>


<span class="sd">        Note: input and output instructions have no SX representation. This method</span>
<span class="sd">        returns nan for those instructions.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_instructions_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_spfwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the class able to propagate seeds through the algorithm?</span>

<span class="sd">        has_spfwd(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_has_spfwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_sprev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the class able to propagate seeds through the algorithm?</span>

<span class="sd">        has_sprev(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_has_sprev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sz_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;size_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get required length of arg field.</span>

<span class="sd">        sz_arg(self) -&gt; size_t</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sz_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sz_res</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;size_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get required length of res field.</span>

<span class="sd">        sz_res(self) -&gt; size_t</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sz_res</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sz_iw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;size_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get required length of iw field.</span>

<span class="sd">        sz_iw(self) -&gt; size_t</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sz_iw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sz_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;size_t&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get required length of w field.</span>

<span class="sd">        sz_w(self) -&gt; size_t</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_sz_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Name of the function.</span>

<span class="sd">        name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Check if the function is of a particular type Optionally check if name</span>

<span class="sd">          is_a(self, str type, bool recursive) -&gt; bool</span>

<span class="sd">        matches one of the base classes (default true)</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_is_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">check_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        check_name(str name) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_check_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">check_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">check_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fix_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        fix_name(str name) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_fix_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">fix_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">fix_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        load(str filename) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">load</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(std::istream &amp; stream) -&gt; Function</span>
<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; Function</span>
<span class="sd">        deserialize(str s) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assert_size_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assert that an input dimension is equal so some given value.</span>

<span class="sd">        assert_size_in(self, int i, int nrow, int ncol)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_assert_size_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">assert_size_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assert that an output dimension is equal so some given value.</span>

<span class="sd">        assert_size_out(self, int i, int nrow, int ncol)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_assert_size_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">checkout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checkout a memory object.</span>

<span class="sd">        checkout(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_checkout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Release a memory object.</span>

<span class="sd">        release(self, int mem)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_release</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        get_function(self) -&gt; [str]</span>
<span class="sd">        get_function(self, str name) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_get_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_function(self, str fname) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_has_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain information about function</span>

<span class="sd">        info(self) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Function</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;serialization&quot;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;serialization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">()}</span>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Either named inputs or ordered inputs</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Function evaluation requires all arguments to be named or none&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Ordered inputs -&gt; return tuple</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
          <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
    <span class="c1"># Named inputs -&gt; return dictionary</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a FunctionBuffer object for evaluating with minimal overhead</span>

<span class="sd">      &quot;&quot;&quot;</span>
      <span class="kn">import</span> <span class="nn">functools</span>
      <span class="n">fb</span> <span class="o">=</span> <span class="n">FunctionBuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="n">caller</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">_function_buffer_eval</span><span class="p">,</span> <span class="n">fb</span><span class="o">.</span><span class="n">_self</span><span class="p">())</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">caller</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          Function()</span>
<span class="sd">          Function(str fname)</span>
<span class="sd">          Function(Function other)</span>
<span class="sd">          Function(str name, [SX] ex_in, [SX] ex_out, dict opts)</span>
<span class="sd">          Function(str name, [MX] ex_in, [MX] ex_out, dict opts)</span>
<span class="sd">          Function(str name, dict:SX dict, [str] name_in, [str] name_out, dict opts)</span>
<span class="sd">          Function(str name, dict:MX dict, [str] name_in, [str] name_out, dict opts)</span>
<span class="sd">          Function(str name, [SX] ex_in, [SX] ex_out, [str] name_in, [str] name_out, dict opts)</span>
<span class="sd">          Function(str name, [MX] ex_in, [MX] ex_out, [str] name_in, [str] name_out, dict opts)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Function(Function other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Function()</span>



<span class="sd">        Default constructor, null pointer.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Function(str fname)</span>



<span class="sd">        Construct from a file.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Function(str name, [SX] ex_in, [SX] ex_out, dict opts)</span>
<span class="sd">          Function(str name, dict:SX dict, [str] name_in, [str] name_out, dict opts)</span>
<span class="sd">          Function(str name, [SX] ex_in, [SX] ex_out, [str] name_in, [str] name_out, dict opts)</span>



<span class="sd">        Construct an SX function.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Function(str name, [MX] ex_in, [MX] ex_out, dict opts)</span>
<span class="sd">          Function(str name, dict:MX dict, [str] name_in, [str] name_out, dict opts)</span>
<span class="sd">          Function(str name, [MX] ex_in, [MX] ex_out, [str] name_in, [str] name_out, dict opts)</span>



<span class="sd">        Construct an MX function.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
<span class="n">Function_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_swigregister</span>
<span class="n">Function_swigregister</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_jit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      To resolve ambiguity on some compilers.</span>

<span class="sd">      jit(str name, str body, [str] name_in, [str] name_out, dict opts) -&gt; Function</span>
<span class="sd">      jit(str name, str body, [str] name_in, [str] name_out, [Sparsity] sparsity_in, [Sparsity] sparsity_out, dict opts) -&gt; Function</span>


<span class="sd">    Create a just-in-time compiled function from a C language string The names</span>
<span class="sd">    and sparsity patterns of all the inputs and outputs must be provided. If</span>
<span class="sd">    sparsities are not provided, all inputs and outputs are assumed to be</span>
<span class="sd">    scalar. Only specify the function body, assuming that input and output</span>
<span class="sd">    nonzeros are stored in arrays with the specified naming convension. The data</span>
<span class="sd">    type used is &#39;casadi_real&#39;, which is typically equal to &#39;double` or another</span>
<span class="sd">    data type with the same API as &#39;double&#39;.</span>

<span class="sd">    Inputs may be null pointers. This means that the all entries are zero.</span>
<span class="sd">    Outputs may be null points. This means that the corresponding result can be</span>
<span class="sd">    ignored.</span>

<span class="sd">    If an error occurs in the evaluation, issue &quot;return 1;&quot;;</span>

<span class="sd">    The final generated function will have a structure similar to:</span>

<span class="sd">    casadi_int fname(const casadi_real** arg, casadi_real** res, casadi_int* iw,</span>
<span class="sd">    casadi_real* w, void* mem) { const casadi_real *x1, *x2; casadi_real *r1,</span>
<span class="sd">    *r2; x1 = *arg++; x2 = *arg++; r1 = *res++; r2 = *res++; &lt;FUNCTION_BODY&gt;</span>
<span class="sd">    return 0; }</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_jit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_conditional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    conditional(str name, [Function] f, Function f_def, dict opts) -&gt; Function</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_conditional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_bspline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    bspline(str name, [[float]] knots, [float] coeffs, [int] degree, int m, dict opts) -&gt; Function</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_bspline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_if_else</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    if_else(str name, Function f_true, Function f_false, dict opts) -&gt; Function</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_if_else</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_check_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    check_name(str name) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_check_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_fix_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    fix_name(str name) -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_fix_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    load(str filename) -&gt; Function</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Function_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(std::istream &amp; stream) -&gt; Function</span>
<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; Function</span>
<span class="sd">    deserialize(str s) -&gt; Function</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Function_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">FunctionBuffer</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Class to achieve minimal overhead function evaluations.</span>



<span class="sd">    C++ includes: function.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FunctionBuffer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FunctionBuffer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">set_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set input buffer for input i.</span>

<span class="sd">          set_arg(self, int i, memoryview(ro) a, casadi_int size)</span>


<span class="sd">        mem.set_arg(0, memoryview(a))</span>

<span class="sd">        Note that CasADi uses &#39;fortran&#39; order: column-by-column</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FunctionBuffer_set_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_res</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set output buffer for ouput i.</span>

<span class="sd">          set_res(self, int i, memoryview(rw) a, casadi_int size)</span>


<span class="sd">        mem.set_res(0, memoryview(a))</span>

<span class="sd">        Note that CasADi uses &#39;fortran&#39; order: column-by-column</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FunctionBuffer_set_res</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ret</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get last return value.</span>

<span class="sd">        ret(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FunctionBuffer_ret</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        _eval(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FunctionBuffer__eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        _self(self) -&gt; void*</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FunctionBuffer__self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          FunctionBuffer(FunctionBuffer other)</span>
<span class="sd">          FunctionBuffer(Function f)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          FunctionBuffer(FunctionBuffer other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          FunctionBuffer(Function f)</span>



<span class="sd">        Main constructor.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_FunctionBuffer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_FunctionBuffer</span>
<span class="n">FunctionBuffer_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FunctionBuffer_swigregister</span>
<span class="n">FunctionBuffer_swigregister</span><span class="p">(</span><span class="n">FunctionBuffer</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_function_buffer_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    _function_buffer_eval(void* raw)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">_function_buffer_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">external</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Load a just-in-time compiled external function File name given.</span>

<span class="sd">      external(str name, dict opts) -&gt; Function</span>
<span class="sd">      external(str name, Importer li, dict opts) -&gt; Function</span>
<span class="sd">      external(str name, str bin_name, dict opts) -&gt; Function</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      external(str name, Importer li, dict opts)</span>



<span class="sd">    Load a just-in-time compiled external function File name given.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      external(str name, dict opts)</span>



<span class="sd">    Load an external function from a shared library.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    name:  Name as in the label assigned to a CasADi Function object:</span>
<span class="sd">    Function(name,...,...) Will be used to look up symbols/functions named eg.</span>
<span class="sd">    &lt;name&gt;_eval Use nm (linux/osx) or depends.exe (win) to check which symbols</span>
<span class="sd">    are present in your shared library</span>

<span class="sd">    File name is assumed to be ./&lt;name&gt;.so</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      external(str name, str bin_name, dict opts)</span>



<span class="sd">    Load an external function from a shared library.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    name:  Name as in the label assigned to a CasADi Function object:</span>
<span class="sd">    Function(name,...,...) Will be used to look up symbols/functions named eg.</span>
<span class="sd">    &lt;name&gt;_eval Use nm (linux/osx) or depends.exe (win) to check which symbols</span>
<span class="sd">    are present in your shared library</span>

<span class="sd">    bin_name:  File name of the shared library</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">external</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">      integrator(str name, str solver, dict:SX dae, dict opts) -&gt; Function</span>
<span class="sd">      integrator(str name, str solver, dict:MX dae, dict opts) -&gt; Function</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      integrator(str name, str solver, dict:MX dae, dict opts)</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      integrator(str name, str solver, dict:SX dae, dict opts)</span>



<span class="sd">    Create an ODE/DAE integrator Solves an initial value problem (IVP) coupled</span>
<span class="sd">    to a terminal value problem with differential equation given as an implicit</span>
<span class="sd">    ODE coupled to an algebraic equation and a set of quadratures:</span>



<span class="sd">    ::</span>

<span class="sd">      Initial conditions at t=t0</span>
<span class="sd">      x(t0)  = x0</span>
<span class="sd">      q(t0)  = 0</span>

<span class="sd">      Forward integration from t=t0 to t=tf</span>
<span class="sd">      der(x) = function(x, z, p, t)                  Forward ODE</span>
<span class="sd">      0 = fz(x, z, p, t)                  Forward algebraic equations</span>
<span class="sd">      der(q) = fq(x, z, p, t)                  Forward quadratures</span>

<span class="sd">      Terminal conditions at t=tf</span>
<span class="sd">      rx(tf)  = rx0</span>
<span class="sd">      rq(tf)  = 0</span>

<span class="sd">      Backward integration from t=tf to t=t0</span>
<span class="sd">      der(rx) = gx(rx, rz, rp, x, z, p, t)        Backward ODE</span>
<span class="sd">      0 = gz(rx, rz, rp, x, z, p, t)        Backward algebraic equations</span>
<span class="sd">      der(rq) = gq(rx, rz, rp, x, z, p, t)        Backward quadratures</span>

<span class="sd">      where we assume that both the forward and backwards integrations are index-1</span>
<span class="sd">      (i.e. dfz/dz, dgz/drz are invertible) and furthermore that</span>
<span class="sd">      gx, gz and gq have a linear dependency on rx, rz and rp.</span>



<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | augmented_option | OT_DICT         | Options to be    | casadi::Integrat |</span>
<span class="sd">    | s                |                 | passed down to   | or               |</span>
<span class="sd">    |                  |                 | the augmented    |                  |</span>
<span class="sd">    |                  |                 | integrator, if   |                  |</span>
<span class="sd">    |                  |                 | one is           |                  |</span>
<span class="sd">    |                  |                 | constructed.     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | common_options   | OT_DICT         | Options for      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | auto-generated   | nction           |</span>
<span class="sd">    |                  |                 | functions        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | expand           | OT_BOOL         | Replace MX with  | casadi::Integrat |</span>
<span class="sd">    |                  |                 | SX expressions   | or               |</span>
<span class="sd">    |                  |                 | in problem       |                  |</span>
<span class="sd">    |                  |                 | formulation      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | grid             | OT_DOUBLEVECTOR | Time grid        | casadi::Integrat |</span>
<span class="sd">    |                  |                 |                  | or               |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | problem          | nction           |</span>
<span class="sd">    |                  |                 | functions to be  |                  |</span>
<span class="sd">    |                  |                 | monitored        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | number_of_finite | OT_INT          | Number of finite | casadi::Integrat |</span>
<span class="sd">    | _elements        |                 | elements         | or               |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | output_t0        | OT_BOOL         | Output the state | casadi::Integrat |</span>
<span class="sd">    |                  |                 | at the initial   | or               |</span>
<span class="sd">    |                  |                 | time             |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_stats      | OT_BOOL         | Print out        | casadi::Integrat |</span>
<span class="sd">    |                  |                 | statistics after | or               |</span>
<span class="sd">    |                  |                 | integration      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | rootfinder       | OT_STRING       | An implicit      | casadi::Integrat |</span>
<span class="sd">    |                  |                 | function solver  | or               |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | rootfinder_optio | OT_DICT         | Options to be    | casadi::Integrat |</span>
<span class="sd">    | ns               |                 | passed to the    | or               |</span>
<span class="sd">    |                  |                 | NLP Solver       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | show_eval_warnin | OT_BOOL         | Show warnings    | casadi::OracleFu |</span>
<span class="sd">    | gs               |                 | generated from   | nction           |</span>
<span class="sd">    |                  |                 | function         |                  |</span>
<span class="sd">    |                  |                 | evaluations      |                  |</span>
<span class="sd">    |                  |                 | [true]           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | simplify         | OT_BOOL         | Implement as MX  | casadi::Integrat |</span>
<span class="sd">    |                  |                 | Function (codege | or               |</span>
<span class="sd">    |                  |                 | neratable/serial |                  |</span>
<span class="sd">    |                  |                 | izable) default: |                  |</span>
<span class="sd">    |                  |                 | false            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | simplify_options | OT_DICT         | Any options to   | casadi::Integrat |</span>
<span class="sd">    |                  |                 | pass to          | or               |</span>
<span class="sd">    |                  |                 | simplified form  |                  |</span>
<span class="sd">    |                  |                 | Function         |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | specific_options | OT_DICT         | Options for      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | specific auto-   | nction           |</span>
<span class="sd">    |                  |                 | generated        |                  |</span>
<span class="sd">    |                  |                 | functions,       |                  |</span>
<span class="sd">    |                  |                 | overwriting the  |                  |</span>
<span class="sd">    |                  |                 | defaults from    |                  |</span>
<span class="sd">    |                  |                 | common_options.  |                  |</span>
<span class="sd">    |                  |                 | Nested           |                  |</span>
<span class="sd">    |                  |                 | dictionary.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | t0               | OT_DOUBLE       | Beginning of the | casadi::Integrat |</span>
<span class="sd">    |                  |                 | time horizon     | or               |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | tf               | OT_DOUBLE       | End of the time  | casadi::Integrat |</span>
<span class="sd">    |                  |                 | horizon          | or               |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    &gt;Input scheme: casadi::IntegratorInput (INTEGRATOR_NUM_IN = 6)</span>

<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    |   Full name    | Short |                   Description                   |</span>
<span class="sd">    +================+=======+=================================================+</span>
<span class="sd">    | INTEGRATOR_X0  | x0    | Differential state at the initial time.         |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_P   | p     | Parameters.                                     |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_Z0  | z0    | Initial guess for the algebraic variable.       |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_RX0 | rx0   | Backward differential state at the final time.  |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_RP  | rp    | Backward parameter vector.                      |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_RZ0 | rz0   | Initial guess for the backwards algebraic       |</span>
<span class="sd">    |                |       | variable.                                       |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>

<span class="sd">    &gt;Output scheme: casadi::IntegratorOutput (INTEGRATOR_NUM_OUT = 6)</span>

<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    |   Full name    | Short |                   Description                   |</span>
<span class="sd">    +================+=======+=================================================+</span>
<span class="sd">    | INTEGRATOR_XF  | xf    | Differential state at the final time.           |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_QF  | qf    | Quadrature state at the final time.             |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_ZF  | zf    | Algebraic variable at the final time.           |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_RXF | rxf   | Backward differential state at the initial      |</span>
<span class="sd">    |                |       | time.                                           |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_RQF | rqf   | Backward quadrature state at the initial time.  |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>
<span class="sd">    | INTEGRATOR_RZF | rzf   | Backward algebraic variable at the initial      |</span>
<span class="sd">    |                |       | time.                                           |</span>
<span class="sd">    +----------------+-------+-------------------------------------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - cvodes</span>

<span class="sd">    - idas</span>

<span class="sd">    - collocation</span>

<span class="sd">    - rk</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Integrator.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    cvodes</span>
<span class="sd">    ------</span>



<span class="sd">    Interface to CVodes from the Sundials suite.</span>

<span class="sd">    A call to evaluate will integrate to the end.</span>

<span class="sd">    You can retrieve the entire state trajectory as follows, after the evaluate</span>
<span class="sd">    call: Call reset. Then call integrate(t_i) and getOuput for a series of</span>
<span class="sd">    times t_i.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    |             Id             |   Type    |           Description           |</span>
<span class="sd">    +============================+===========+=================================+</span>
<span class="sd">    | abstol                     | OT_DOUBLE | Absolute tolerence for the IVP  |</span>
<span class="sd">    |                            |           | solution                        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | disable_internal_warnings  | OT_BOOL   | Disable SUNDIALS internal       |</span>
<span class="sd">    |                            |           | warning messages                |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | fsens_all_at_once          | OT_BOOL   | Calculate all right hand sides  |</span>
<span class="sd">    |                            |           | of the sensitivity equations at |</span>
<span class="sd">    |                            |           | once                            |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | fsens_err_con              | OT_BOOL   | include the forward             |</span>
<span class="sd">    |                            |           | sensitivities in all error      |</span>
<span class="sd">    |                            |           | controls                        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | interpolation_type         | OT_STRING | Type of interpolation for the   |</span>
<span class="sd">    |                            |           | adjoint sensitivities           |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | linear_multistep_method    | OT_STRING | Integrator scheme: BDF|adams    |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | linear_solver              | OT_STRING | A custom linear solver creator  |</span>
<span class="sd">    |                            |           | function [default: qr]          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | linear_solver_options      | OT_DICT   | Options to be passed to the     |</span>
<span class="sd">    |                            |           | linear solver                   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_krylov                 | OT_INT    | Maximum Krylov subspace size    |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_multistep_order        | OT_INT    | Maximum order for the           |</span>
<span class="sd">    |                            |           | (variable-order) multistep      |</span>
<span class="sd">    |                            |           | method                          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_num_steps              | OT_INT    | Maximum number of integrator    |</span>
<span class="sd">    |                            |           | steps                           |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_order                  | OT_DOUBLE | Maximum order                   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_step_size              | OT_DOUBLE | Max step size [default: 0/inf]  |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | min_step_size              | OT_DOUBLE | Min step size [default: 0/0.0]  |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | newton_scheme              | OT_STRING | Linear solver scheme in the     |</span>
<span class="sd">    |                            |           | Newton method:                  |</span>
<span class="sd">    |                            |           | DIRECT|gmres|bcgstab|tfqmr      |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | nonlin_conv_coeff          | OT_DOUBLE | Coefficient in the nonlinear    |</span>
<span class="sd">    |                            |           | convergence test                |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | nonlinear_solver_iteration | OT_STRING | Nonlinear solver type:          |</span>
<span class="sd">    |                            |           | NEWTON|functional               |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | quad_err_con               | OT_BOOL   | Should the quadratures affect   |</span>
<span class="sd">    |                            |           | the step size control           |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | reltol                     | OT_DOUBLE | Relative tolerence for the IVP  |</span>
<span class="sd">    |                            |           | solution                        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | second_order_correction    | OT_BOOL   | Second order correction in the  |</span>
<span class="sd">    |                            |           | augmented system Jacobian       |</span>
<span class="sd">    |                            |           | [true]                          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | sensitivity_method         | OT_STRING | Sensitivity method:             |</span>
<span class="sd">    |                            |           | SIMULTANEOUS|staggered          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | step0                      | OT_DOUBLE | initial step size [default:     |</span>
<span class="sd">    |                            |           | 0/estimated]                    |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | steps_per_checkpoint       | OT_INT    | Number of steps between two     |</span>
<span class="sd">    |                            |           | consecutive checkpoints         |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | stop_at_end                | OT_BOOL   | Stop the integrator at the end  |</span>
<span class="sd">    |                            |           | of the interval                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | use_preconditioner         | OT_BOOL   | Precondition the iterative      |</span>
<span class="sd">    |                            |           | solver [default: true]          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    idas</span>
<span class="sd">    ----</span>



<span class="sd">    Interface to IDAS from the Sundials suite.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    |            Id             |      Type       |        Description         |</span>
<span class="sd">    +===========================+=================+============================+</span>
<span class="sd">    | abstol                    | OT_DOUBLE       | Absolute tolerence for the |</span>
<span class="sd">    |                           |                 | IVP solution               |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | abstolv                   | OT_DOUBLEVECTOR | Absolute tolerarance for   |</span>
<span class="sd">    |                           |                 | each component             |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | calc_ic                   | OT_BOOL         | Use IDACalcIC to get       |</span>
<span class="sd">    |                           |                 | consistent initial         |</span>
<span class="sd">    |                           |                 | conditions.                |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | calc_icB                  | OT_BOOL         | Use IDACalcIC to get       |</span>
<span class="sd">    |                           |                 | consistent initial         |</span>
<span class="sd">    |                           |                 | conditions for backwards   |</span>
<span class="sd">    |                           |                 | system [default: equal to  |</span>
<span class="sd">    |                           |                 | calc_ic].                  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | cj_scaling                | OT_BOOL         | IDAS scaling on cj for the |</span>
<span class="sd">    |                           |                 | user-defined linear solver |</span>
<span class="sd">    |                           |                 | module                     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | constraints               | OT_INTVECTOR    | Constrain the solution     |</span>
<span class="sd">    |                           |                 | y=[x,z]. 0 (default): no   |</span>
<span class="sd">    |                           |                 | constraint on yi, 1: yi &gt;= |</span>
<span class="sd">    |                           |                 | 0.0, -1: yi &lt;= 0.0, 2: yi  |</span>
<span class="sd">    |                           |                 | &gt; 0.0, -2: yi &lt; 0.0.       |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | disable_internal_warnings | OT_BOOL         | Disable SUNDIALS internal  |</span>
<span class="sd">    |                           |                 | warning messages           |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | first_time                | OT_DOUBLE       | First requested time as a  |</span>
<span class="sd">    |                           |                 | fraction of the time       |</span>
<span class="sd">    |                           |                 | interval                   |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | fsens_err_con             | OT_BOOL         | include the forward        |</span>
<span class="sd">    |                           |                 | sensitivities in all error |</span>
<span class="sd">    |                           |                 | controls                   |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | init_xdot                 | OT_DOUBLEVECTOR | Initial values for the     |</span>
<span class="sd">    |                           |                 | state derivatives          |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | interpolation_type        | OT_STRING       | Type of interpolation for  |</span>
<span class="sd">    |                           |                 | the adjoint sensitivities  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | linear_solver             | OT_STRING       | A custom linear solver     |</span>
<span class="sd">    |                           |                 | creator function [default: |</span>
<span class="sd">    |                           |                 | qr]                        |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | linear_solver_options     | OT_DICT         | Options to be passed to    |</span>
<span class="sd">    |                           |                 | the linear solver          |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_krylov                | OT_INT          | Maximum Krylov subspace    |</span>
<span class="sd">    |                           |                 | size                       |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_multistep_order       | OT_INT          | Maximum order for the      |</span>
<span class="sd">    |                           |                 | (variable-order) multistep |</span>
<span class="sd">    |                           |                 | method                     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_num_steps             | OT_INT          | Maximum number of          |</span>
<span class="sd">    |                           |                 | integrator steps           |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_order                 | OT_DOUBLE       | Maximum order              |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_step_size             | OT_DOUBLE       | Maximim step size          |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | newton_scheme             | OT_STRING       | Linear solver scheme in    |</span>
<span class="sd">    |                           |                 | the Newton method:         |</span>
<span class="sd">    |                           |                 | DIRECT|gmres|bcgstab|tfqmr |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | nonlin_conv_coeff         | OT_DOUBLE       | Coefficient in the         |</span>
<span class="sd">    |                           |                 | nonlinear convergence test |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | quad_err_con              | OT_BOOL         | Should the quadratures     |</span>
<span class="sd">    |                           |                 | affect the step size       |</span>
<span class="sd">    |                           |                 | control                    |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | reltol                    | OT_DOUBLE       | Relative tolerence for the |</span>
<span class="sd">    |                           |                 | IVP solution               |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | second_order_correction   | OT_BOOL         | Second order correction in |</span>
<span class="sd">    |                           |                 | the augmented system       |</span>
<span class="sd">    |                           |                 | Jacobian [true]            |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | sensitivity_method        | OT_STRING       | Sensitivity method:        |</span>
<span class="sd">    |                           |                 | SIMULTANEOUS|staggered     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | step0                     | OT_DOUBLE       | initial step size          |</span>
<span class="sd">    |                           |                 | [default: 0/estimated]     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | steps_per_checkpoint      | OT_INT          | Number of steps between    |</span>
<span class="sd">    |                           |                 | two consecutive            |</span>
<span class="sd">    |                           |                 | checkpoints                |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | stop_at_end               | OT_BOOL         | Stop the integrator at the |</span>
<span class="sd">    |                           |                 | end of the interval        |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | suppress_algebraic        | OT_BOOL         | Suppress algebraic         |</span>
<span class="sd">    |                           |                 | variables in the error     |</span>
<span class="sd">    |                           |                 | testing                    |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | use_preconditioner        | OT_BOOL         | Precondition the iterative |</span>
<span class="sd">    |                           |                 | solver [default: true]     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    collocation</span>
<span class="sd">    -----------</span>



<span class="sd">    Fixed-step implicit Runge-Kutta integrator ODE/DAE integrator based on</span>
<span class="sd">    collocation schemes</span>

<span class="sd">    The method is still under development</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    |            Id             |      Type       |        Description         |</span>
<span class="sd">    +===========================+=================+============================+</span>
<span class="sd">    | augmented_options         | OT_DICT         | Options to be passed down  |</span>
<span class="sd">    |                           |                 | to the augmented           |</span>
<span class="sd">    |                           |                 | integrator, if one is      |</span>
<span class="sd">    |                           |                 | constructed.               |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | collocation_scheme        | OT_STRING       | Collocation scheme:        |</span>
<span class="sd">    |                           |                 | radau|legendre             |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | expand                    | OT_BOOL         | Replace MX with SX         |</span>
<span class="sd">    |                           |                 | expressions in problem     |</span>
<span class="sd">    |                           |                 | formulation [false]        |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | grid                      | OT_DOUBLEVECTOR | Time grid                  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | interpolation_order       | OT_INT          | Order of the interpolating |</span>
<span class="sd">    |                           |                 | polynomials                |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | number_of_finite_elements | OT_INT          | Number of finite elements  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | output_t0                 | OT_BOOL         | Output the state at the    |</span>
<span class="sd">    |                           |                 | initial time               |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | print_stats               | OT_BOOL         | Print out statistics after |</span>
<span class="sd">    |                           |                 | integration                |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | rootfinder                | OT_STRING       | An implicit function       |</span>
<span class="sd">    |                           |                 | solver                     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | rootfinder_options        | OT_DICT         | Options to be passed to    |</span>
<span class="sd">    |                           |                 | the NLP Solver             |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | simplify                  | OT_BOOL         | Implement as MX  Function  |</span>
<span class="sd">    |                           |                 | (codegeneratable/serializa |</span>
<span class="sd">    |                           |                 | ble) default: false        |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | simplify_options          | OT_DICT         | Any options to pass to     |</span>
<span class="sd">    |                           |                 | simplified form Function   |</span>
<span class="sd">    |                           |                 | constructor                |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | t0                        | OT_DOUBLE       | Beginning of the time      |</span>
<span class="sd">    |                           |                 | horizon                    |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | tf                        | OT_DOUBLE       | End of the time horizon    |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    rk --</span>



<span class="sd">    Fixed-step explicit Runge-Kutta integrator for ODEs Currently implements</span>
<span class="sd">    RK4.</span>

<span class="sd">    The method is still under development</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joel Andersson</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_integrator(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_integrator(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_integrator(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_integrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">integrator_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get integrator input scheme name by index.</span>

<span class="sd">      integrator_in() -&gt; [str]</span>
<span class="sd">      integrator_in(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      integrator_in()</span>



<span class="sd">    Get input scheme of integrators.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      integrator_in(int ind)</span>



<span class="sd">    Get integrator input scheme name by index.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">integrator_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">integrator_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get output scheme name by index.</span>

<span class="sd">      integrator_out() -&gt; [str]</span>
<span class="sd">      integrator_out(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      integrator_out()</span>



<span class="sd">    Get integrator output scheme of integrators.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      integrator_out(int ind)</span>



<span class="sd">    Get output scheme name by index.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">integrator_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">integrator_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of integrator inputs.</span>

<span class="sd">    integrator_n_in() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">integrator_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">integrator_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of integrator outputs.</span>

<span class="sd">    integrator_n_out() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">integrator_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a QP solver Solves the following strictly convex problem:</span>

<span class="sd">      conic(str name, str solver, dict:Sparsity qp, dict opts) -&gt; Function</span>




<span class="sd">    ::</span>

<span class="sd">      min          1/2 x&#39; H x + g&#39; x</span>
<span class="sd">      x</span>

<span class="sd">      subject to</span>
<span class="sd">      LBA &lt;= A x &lt;= UBA</span>
<span class="sd">      LBX &lt;= x   &lt;= UBX</span>

<span class="sd">      resize(Q x, np, np) + P &gt;= 0 (psd)</span>

<span class="sd">      with :</span>
<span class="sd">      H sparse (n x n) positive definite</span>
<span class="sd">      g dense  (n x 1)</span>
<span class="sd">      A sparse (nc x n)</span>
<span class="sd">      Q sparse symmetric (np^2 x n)</span>
<span class="sd">      P sparse symmetric (np x nq)</span>

<span class="sd">      n: number of decision variables (x)</span>
<span class="sd">      nc: number of constraints (A)</span>
<span class="sd">      nq: shape of psd constraint matrix</span>



<span class="sd">    If H is not positive-definite, the solver should throw an error.</span>

<span class="sd">    Second-order cone constraints can be added as psd constraints through a</span>
<span class="sd">    helper function &#39;soc&#39;:</span>

<span class="sd">    x in R^n y in R</span>

<span class="sd">    || x ||_2 &lt;= y</span>

<span class="sd">    &lt;=&gt;</span>

<span class="sd">    soc(x, y) psd</span>

<span class="sd">    This can be proven with soc(x, y)=[y*I x; x&#39; y] using the Shur complement.</span>

<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for derivative   | Internal         |</span>
<span class="sd">    |                  |                 | calculation.When |                  |</span>
<span class="sd">    |                  |                 | there is an      |                  |</span>
<span class="sd">    |                  |                 | option of either |                  |</span>
<span class="sd">    |                  |                 | using forward or |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | directional      |                  |</span>
<span class="sd">    |                  |                 | derivatives, the |                  |</span>
<span class="sd">    |                  |                 | condition ad_wei |                  |</span>
<span class="sd">    |                  |                 | ght*nf&lt;=(1-ad_we |                  |</span>
<span class="sd">    |                  |                 | ight)*na is used |                  |</span>
<span class="sd">    |                  |                 | where nf and na  |                  |</span>
<span class="sd">    |                  |                 | are estimates of |                  |</span>
<span class="sd">    |                  |                 | the number of    |                  |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | mode directional |                  |</span>
<span class="sd">    |                  |                 | derivatives      |                  |</span>
<span class="sd">    |                  |                 | needed. By       |                  |</span>
<span class="sd">    |                  |                 | default,         |                  |</span>
<span class="sd">    |                  |                 | ad_weight is     |                  |</span>
<span class="sd">    |                  |                 | calculated       |                  |</span>
<span class="sd">    |                  |                 | automatically,   |                  |</span>
<span class="sd">    |                  |                 | but this can be  |                  |</span>
<span class="sd">    |                  |                 | overridden by    |                  |</span>
<span class="sd">    |                  |                 | setting this     |                  |</span>
<span class="sd">    |                  |                 | option. In       |                  |</span>
<span class="sd">    |                  |                 | particular, 0    |                  |</span>
<span class="sd">    |                  |                 | means forcing    |                  |</span>
<span class="sd">    |                  |                 | forward mode and |                  |</span>
<span class="sd">    |                  |                 | 1 forcing        |                  |</span>
<span class="sd">    |                  |                 | reverse mode.    |                  |</span>
<span class="sd">    |                  |                 | Leave unset for  |                  |</span>
<span class="sd">    |                  |                 | (class specific) |                  |</span>
<span class="sd">    |                  |                 | heuristics.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for sparsity     | Internal         |</span>
<span class="sd">    |                  |                 | pattern          |                  |</span>
<span class="sd">    |                  |                 | calculation calc |                  |</span>
<span class="sd">    |                  |                 | ulation.Override |                  |</span>
<span class="sd">    |                  |                 | s default        |                  |</span>
<span class="sd">    |                  |                 | behavior. Set to |                  |</span>
<span class="sd">    |                  |                 | 0 and 1 to force |                  |</span>
<span class="sd">    |                  |                 | forward and      |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | respectively.    |                  |</span>
<span class="sd">    |                  |                 | Cf. option       |                  |</span>
<span class="sd">    |                  |                 | &quot;ad_weight&quot;.     |                  |</span>
<span class="sd">    |                  |                 | When set to -1,  |                  |</span>
<span class="sd">    |                  |                 | sparsity is      |                  |</span>
<span class="sd">    |                  |                 | completely       |                  |</span>
<span class="sd">    |                  |                 | ignored and      |                  |</span>
<span class="sd">    |                  |                 | dense matrices   |                  |</span>
<span class="sd">    |                  |                 | are used.        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler plugin  | Internal         |</span>
<span class="sd">    |                  |                 | to be used.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |</span>
<span class="sd">    |                  |                 | CasADi&#39;s AD. Use | Internal         |</span>
<span class="sd">    |                  |                 | together with    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;:   |                  |</span>
<span class="sd">    |                  |                 | 0. Note: Highly  |                  |</span>
<span class="sd">    |                  |                 | experimental.    |                  |</span>
<span class="sd">    |                  |                 | Syntax may break |                  |</span>
<span class="sd">    |                  |                 | often.           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |</span>
<span class="sd">    |                  |                 | a derivative of  | Internal         |</span>
<span class="sd">    |                  |                 | another          |                  |</span>
<span class="sd">    |                  |                 | function. The    |                  |</span>
<span class="sd">    |                  |                 | type of          |                  |</span>
<span class="sd">    |                  |                 | derivative       |                  |</span>
<span class="sd">    |                  |                 | (directional     |                  |</span>
<span class="sd">    |                  |                 | derivative,      |                  |</span>
<span class="sd">    |                  |                 | Jacobian) is     |                  |</span>
<span class="sd">    |                  |                 | inferred from    |                  |</span>
<span class="sd">    |                  |                 | the function     |                  |</span>
<span class="sd">    |                  |                 | name.            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | discrete         | OT_BOOLVECTOR   | Indicates which  | casadi::Conic    |</span>
<span class="sd">    |                  |                 | of the variables |                  |</span>
<span class="sd">    |                  |                 | are discrete,    |                  |</span>
<span class="sd">    |                  |                 | i.e. integer-    |                  |</span>
<span class="sd">    |                  |                 | valued           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump             | OT_BOOL         | Dump function to | casadi::Function |</span>
<span class="sd">    |                  |                 | file upon first  | Internal         |</span>
<span class="sd">    |                  |                 | evaluation.      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_dir         | OT_STRING       | Directory to     | casadi::Function |</span>
<span class="sd">    |                  |                 | dump             | Internal         |</span>
<span class="sd">    |                  |                 | inputs/outputs   |                  |</span>
<span class="sd">    |                  |                 | to. Make sure    |                  |</span>
<span class="sd">    |                  |                 | the directory    |                  |</span>
<span class="sd">    |                  |                 | exists [.]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_format      | OT_STRING       | Choose file      | casadi::Function |</span>
<span class="sd">    |                  |                 | format to dump   | Internal         |</span>
<span class="sd">    |                  |                 | matrices. See    |                  |</span>
<span class="sd">    |                  |                 | DM.from_file     |                  |</span>
<span class="sd">    |                  |                 | [mtx]            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | to file          |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs to file  |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_fd        | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation by   |                  |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | differencing.    |                  |</span>
<span class="sd">    |                  |                 | [default:        |                  |</span>
<span class="sd">    |                  |                 | false]]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_forward   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using forward    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobians of all |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | outputs with     |                  |</span>
<span class="sd">    |                  |                 | respect to all   |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | inputs - if      |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_reverse   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | transposed       |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using reverse    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | error_on_fail    | OT_BOOL         | When the         | casadi::Conic    |</span>
<span class="sd">    |                  |                 | numerical        |                  |</span>
<span class="sd">    |                  |                 | process returns  |                  |</span>
<span class="sd">    |                  |                 | unsuccessfully,  |                  |</span>
<span class="sd">    |                  |                 | raise an error   |                  |</span>
<span class="sd">    |                  |                 | (default false). |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_method        | OT_STRING       | Method for       | casadi::Function |</span>
<span class="sd">    |                  |                 | finite           | Internal         |</span>
<span class="sd">    |                  |                 | differencing     |                  |</span>
<span class="sd">    |                  |                 | [default         |                  |</span>
<span class="sd">    |                  |                 | &#39;central&#39;]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_options       | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | difference       |                  |</span>
<span class="sd">    |                  |                 | instance         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | forward_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | forward mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option           | Internal         |</span>
<span class="sd">    |                  |                 | (ignored):       |                  |</span>
<span class="sd">    |                  |                 | Statistics are   |                  |</span>
<span class="sd">    |                  |                 | now always       |                  |</span>
<span class="sd">    |                  |                 | collected.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when the         | Internal         |</span>
<span class="sd">    |                  |                 | numerical values |                  |</span>
<span class="sd">    |                  |                 | of the inputs    |                  |</span>
<span class="sd">    |                  |                 | don&#39;t make sense |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each input if it | Internal         |</span>
<span class="sd">    |                  |                 | should be        |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each output if   | Internal         |</span>
<span class="sd">    |                  |                 | it should be     |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |</span>
<span class="sd">    |                  |                 | for a number of  | Internal         |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | directions, it   |                  |</span>
<span class="sd">    |                  |                 | may be cheaper   |                  |</span>
<span class="sd">    |                  |                 | to compute first |                  |</span>
<span class="sd">    |                  |                 | the full         |                  |</span>
<span class="sd">    |                  |                 | jacobian and     |                  |</span>
<span class="sd">    |                  |                 | then multiply    |                  |</span>
<span class="sd">    |                  |                 | with seeds,      |                  |</span>
<span class="sd">    |                  |                 | rather than      |                  |</span>
<span class="sd">    |                  |                 | obtain the       |                  |</span>
<span class="sd">    |                  |                 | requested        |                  |</span>
<span class="sd">    |                  |                 | directions in a  |                  |</span>
<span class="sd">    |                  |                 | straightforward  |                  |</span>
<span class="sd">    |                  |                 | manner. Casadi   |                  |</span>
<span class="sd">    |                  |                 | uses a heuristic |                  |</span>
<span class="sd">    |                  |                 | to decide which  |                  |</span>
<span class="sd">    |                  |                 | is cheaper. A    |                  |</span>
<span class="sd">    |                  |                 | high value of    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;    |                  |</span>
<span class="sd">    |                  |                 | makes it less    |                  |</span>
<span class="sd">    |                  |                 | likely for the   |                  |</span>
<span class="sd">    |                  |                 | heurstic to      |                  |</span>
<span class="sd">    |                  |                 | chose the full   |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy. The    |                  |</span>
<span class="sd">    |                  |                 | special value -1 |                  |</span>
<span class="sd">    |                  |                 | indicates never  |                  |</span>
<span class="sd">    |                  |                 | to use the full  |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler to      | Internal         |</span>
<span class="sd">    |                  |                 | speed up the     |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |</span>
<span class="sd">    |                  |                 | temporary source | Internal         |</span>
<span class="sd">    |                  |                 | file that jit    |                  |</span>
<span class="sd">    |                  |                 | creates.         |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_name         | OT_STRING       | The file name    | casadi::Function |</span>
<span class="sd">    |                  |                 | used to write    | Internal         |</span>
<span class="sd">    |                  |                 | out code. The    |                  |</span>
<span class="sd">    |                  |                 | actual file      |                  |</span>
<span class="sd">    |                  |                 | names used       |                  |</span>
<span class="sd">    |                  |                 | depend on &#39;jit_t |                  |</span>
<span class="sd">    |                  |                 | emp_suffix&#39; and  |                  |</span>
<span class="sd">    |                  |                 | include          |                  |</span>
<span class="sd">    |                  |                 | extensions.      |                  |</span>
<span class="sd">    |                  |                 | Default:         |                  |</span>
<span class="sd">    |                  |                 | &#39;jit_tmp&#39;        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_options      | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | jit compiler.    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_serialize    | OT_STRING       | Specify          | casadi::Function |</span>
<span class="sd">    |                  |                 | behaviour when   | Internal         |</span>
<span class="sd">    |                  |                 | serializing a    |                  |</span>
<span class="sd">    |                  |                 | jitted function: |                  |</span>
<span class="sd">    |                  |                 | SOURCE|link|embe |                  |</span>
<span class="sd">    |                  |                 | d.               |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |</span>
<span class="sd">    |                  |                 | (seemingly       | Internal         |</span>
<span class="sd">    |                  |                 | random) filename |                  |</span>
<span class="sd">    |                  |                 | suffix for       |                  |</span>
<span class="sd">    |                  |                 | generated code   |                  |</span>
<span class="sd">    |                  |                 | and libraries.   |                  |</span>
<span class="sd">    |                  |                 | This is desired  |                  |</span>
<span class="sd">    |                  |                 | for thread-      |                  |</span>
<span class="sd">    |                  |                 | safety. This     |                  |</span>
<span class="sd">    |                  |                 | behaviour may    |                  |</span>
<span class="sd">    |                  |                 | defeat caching   |                  |</span>
<span class="sd">    |                  |                 | compiler         |                  |</span>
<span class="sd">    |                  |                 | wrappers.        |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |</span>
<span class="sd">    |                  |                 | maximum number   | Internal         |</span>
<span class="sd">    |                  |                 | of directions    |                  |</span>
<span class="sd">    |                  |                 | for derivative   |                  |</span>
<span class="sd">    |                  |                 | functions.       |                  |</span>
<span class="sd">    |                  |                 | Overrules the    |                  |</span>
<span class="sd">    |                  |                 | builtin optimize |                  |</span>
<span class="sd">    |                  |                 | d_num_dir.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_in         | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_out        | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs          |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_problem    | OT_BOOL         | Print a numeric  | casadi::Conic    |</span>
<span class="sd">    |                  |                 | description of   |                  |</span>
<span class="sd">    |                  |                 | the problem      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_time       | OT_BOOL         | print            | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time. Implies    |                  |</span>
<span class="sd">    |                  |                 | record_time.     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | record_time      | OT_BOOL         | record           | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time, for        |                  |</span>
<span class="sd">    |                  |                 | retrieval with   |                  |</span>
<span class="sd">    |                  |                 | stats().         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when NaN or Inf  | Internal         |</span>
<span class="sd">    |                  |                 | appears during   |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | reverse_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |</span>
<span class="sd">    |                  |                 | field that can   | Internal         |</span>
<span class="sd">    |                  |                 | be used to       |                  |</span>
<span class="sd">    |                  |                 | identify the     |                  |</span>
<span class="sd">    |                  |                 | function or pass |                  |</span>
<span class="sd">    |                  |                 | additional       |                  |</span>
<span class="sd">    |                  |                 | information      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | verbose          | OT_BOOL         | Verbose          | casadi::Function |</span>
<span class="sd">    |                  |                 | evaluation  for  | Internal         |</span>
<span class="sd">    |                  |                 | debugging        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    &gt;Input scheme: casadi::ConicInput (CONIC_NUM_IN = 12)</span>

<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    |  Full name   | Short  |                   Description                    |</span>
<span class="sd">    +==============+========+==================================================+</span>
<span class="sd">    | CONIC_H      | h      | The square matrix H: sparse, (n x n). Only the   |</span>
<span class="sd">    |              |        | lower triangular part is actually used. The      |</span>
<span class="sd">    |              |        | matrix is assumed to be symmetrical.             |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_G      | g      | The vector g: dense, (n x 1)                     |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_A      | a      | The matrix A: sparse, (nc x n) - product with x  |</span>
<span class="sd">    |              |        | must be dense.                                   |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_LBA    | lba    | dense, (nc x 1)                                  |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_UBA    | uba    | dense, (nc x 1)                                  |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_LBX    | lbx    | dense, (n x 1)                                   |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_UBX    | ubx    | dense, (n x 1)                                   |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_X0     | x0     | dense, (n x 1)                                   |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_LAM_X0 | lam_x0 | dense                                            |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_LAM_A0 | lam_a0 | dense                                            |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_Q      | q      | The matrix Q: sparse symmetric, (np^2 x n)       |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>
<span class="sd">    | CONIC_P      | p      | The matrix P: sparse symmetric, (np x np)        |</span>
<span class="sd">    +--------------+--------+--------------------------------------------------+</span>

<span class="sd">    &gt;Output scheme: casadi::ConicOutput (CONIC_NUM_OUT = 4)</span>

<span class="sd">    +-------------+-------+---------------------------------------------------+</span>
<span class="sd">    |  Full name  | Short |                    Description                    |</span>
<span class="sd">    +=============+=======+===================================================+</span>
<span class="sd">    | CONIC_X     | x     | The primal solution.                              |</span>
<span class="sd">    +-------------+-------+---------------------------------------------------+</span>
<span class="sd">    | CONIC_COST  | cost  | The optimal cost.                                 |</span>
<span class="sd">    +-------------+-------+---------------------------------------------------+</span>
<span class="sd">    | CONIC_LAM_A | lam_a | The dual solution corresponding to linear bounds. |</span>
<span class="sd">    +-------------+-------+---------------------------------------------------+</span>
<span class="sd">    | CONIC_LAM_X | lam_x | The dual solution corresponding to simple bounds. |</span>
<span class="sd">    +-------------+-------+---------------------------------------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - cbc</span>

<span class="sd">    - clp</span>

<span class="sd">    - cplex</span>

<span class="sd">    - gurobi</span>

<span class="sd">    - hpmpc</span>

<span class="sd">    - ooqp</span>

<span class="sd">    - osqp</span>

<span class="sd">    - qpoases</span>

<span class="sd">    - sqic</span>

<span class="sd">    - superscs</span>

<span class="sd">    - nlpsol</span>

<span class="sd">    - qrqp</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Conic.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    cbc</span>
<span class="sd">    ---</span>



<span class="sd">    Interface to Cbc solver for sparse Quadratic Programs</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    |     Id      |         Type          |            Description             |</span>
<span class="sd">    +=============+=======================+====================================+</span>
<span class="sd">    | cbc         | OT_DICT               | Options to be passed to CBC.Three  |</span>
<span class="sd">    |             |                       | sets of options are supported. The |</span>
<span class="sd">    |             |                       | first can be found in              |</span>
<span class="sd">    |             |                       | OsiSolverParameters.hpp. The       |</span>
<span class="sd">    |             |                       | second can be found in             |</span>
<span class="sd">    |             |                       | CbcModel.hpp. The third are        |</span>
<span class="sd">    |             |                       | options that can be passed to      |</span>
<span class="sd">    |             |                       | CbcMain1.                          |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | hot_start   | OT_BOOL               | Hot start with x0 [Default false]. |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | sos_groups  | OT_INTVECTORVECTOR    | Definition of SOS groups by        |</span>
<span class="sd">    |             |                       | indices.                           |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | sos_types   | OT_INTVECTOR          | Specify 1 or 2 for each SOS group. |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | sos_weights | OT_DOUBLEVECTORVECTOR | Weights corresponding to SOS       |</span>
<span class="sd">    |             |                       | entries.                           |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    clp</span>
<span class="sd">    ---</span>



<span class="sd">    Interface to Clp solver for sparse Quadratic Programs</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----+---------+----------------------------------------------------------+</span>
<span class="sd">    | Id  |  Type   |                       Description                        |</span>
<span class="sd">    +=====+=========+==========================================================+</span>
<span class="sd">    | clp | OT_DICT | Options to be passed to CLP. A first set of options can  |</span>
<span class="sd">    |     |         | be found in ClpParameters.hpp. eg. &#39;PrimalTolerance&#39;.    |</span>
<span class="sd">    |     |         | There are other options in additions. &#39;AutomaticScaling&#39; |</span>
<span class="sd">    |     |         | (bool) is recognised. &#39;initial_solve&#39; (default off)      |</span>
<span class="sd">    |     |         | activates the use of Clp&#39;s initialSolve.                 |</span>
<span class="sd">    |     |         | &#39;initial_solve_options&#39; takes a dictionary with          |</span>
<span class="sd">    |     |         | following keys (see ClpSolve.hpp): SolveType (string),   |</span>
<span class="sd">    |     |         | PresolveType (string), NumberPasses, SpecialOptions      |</span>
<span class="sd">    |     |         | (intvectorvector), IndependentOptions (intvectorvector). |</span>
<span class="sd">    +-----+---------+----------------------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    cplex</span>
<span class="sd">    -----</span>



<span class="sd">    Interface to Cplex solver for sparse Quadratic Programs</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    |      Id       |         Type          |           Description            |</span>
<span class="sd">    +===============+=======================+==================================+</span>
<span class="sd">    | cplex         | OT_DICT               | Options to be passed to CPLEX    |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | dep_check     | OT_INT                | Detect redundant constraints.    |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | dump_filename | OT_STRING             | The filename to dump to.         |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | dump_to_file  | OT_BOOL               | Dumps QP to file in CPLEX        |</span>
<span class="sd">    |               |                       | format.                          |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | mip_start     | OT_BOOL               | Hot start integers with x0       |</span>
<span class="sd">    |               |                       | [Default false].                 |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | qp_method     | OT_INT                | Determines which CPLEX algorithm |</span>
<span class="sd">    |               |                       | to use.                          |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | sos_groups    | OT_INTVECTORVECTOR    | Definition of SOS groups by      |</span>
<span class="sd">    |               |                       | indices.                         |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | sos_types     | OT_INTVECTOR          | Specify 1 or 2 for each SOS      |</span>
<span class="sd">    |               |                       | group.                           |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | sos_weights   | OT_DOUBLEVECTORVECTOR | Weights corresponding to SOS     |</span>
<span class="sd">    |               |                       | entries.                         |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | tol           | OT_DOUBLE             | Tolerance of solver              |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>
<span class="sd">    | warm_start    | OT_BOOL               | Use warm start with simplex      |</span>
<span class="sd">    |               |                       | methods (affects only the        |</span>
<span class="sd">    |               |                       | simplex methods).                |</span>
<span class="sd">    +---------------+-----------------------+----------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    gurobi</span>
<span class="sd">    ------</span>



<span class="sd">    Interface to the GUROBI Solver for quadratic programming</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    |     Id      |         Type          |            Description             |</span>
<span class="sd">    +=============+=======================+====================================+</span>
<span class="sd">    | gurobi      | OT_DICT               | Options to be passed to gurobi.    |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | sos_groups  | OT_INTVECTORVECTOR    | Definition of SOS groups by        |</span>
<span class="sd">    |             |                       | indices.                           |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | sos_types   | OT_INTVECTOR          | Specify 1 or 2 for each SOS group. |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | sos_weights | OT_DOUBLEVECTORVECTOR | Weights corresponding to SOS       |</span>
<span class="sd">    |             |                       | entries.                           |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>
<span class="sd">    | vtype       | OT_STRINGVECTOR       | Type of variables: [CONTINUOUS|bin |</span>
<span class="sd">    |             |                       | ary|integer|semicont|semiint]      |</span>
<span class="sd">    +-------------+-----------------------+------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    hpmpc</span>
<span class="sd">    -----</span>



<span class="sd">    Interface to HMPC Solver</span>

<span class="sd">    In order to use this interface, you must:</span>

<span class="sd">    Decision variables must only by state and control, and the variable ordering</span>
<span class="sd">    must be [x0 u0 x1 u1 ...]</span>

<span class="sd">    The constraints must be in order: [ gap0 lincon0 gap1 lincon1 ]</span>

<span class="sd">    gap: Ak+1 = Ak xk + Bk uk lincon: yk= Ck xk + Dk uk</span>



<span class="sd">    ::</span>

<span class="sd">             A0 B0 -I</span>
<span class="sd">             C0 D0</span>
<span class="sd">                    A1 B1 -I</span>
<span class="sd">                    C1 D1</span>



<span class="sd">    where I must be a diagonal sparse matrix Either supply all of N, nx, ng, nu</span>
<span class="sd">    options or rely on automatic detection</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    |       Id       |     Type     |               Description                |</span>
<span class="sd">    +================+==============+==========================================+</span>
<span class="sd">    | N              | OT_INT       | OCP horizon                              |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | blasfeo_target | OT_STRING    | hpmpc target                             |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | inf            | OT_DOUBLE    | HPMPC cannot handle infinities.          |</span>
<span class="sd">    |                |              | Infinities will be replaced by this      |</span>
<span class="sd">    |                |              | option&#39;s value.                          |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | max_iter       | OT_INT       | Max number of iterations                 |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | mu0            | OT_DOUBLE    | Max element in cost function as estimate |</span>
<span class="sd">    |                |              | of max multiplier                        |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | ng             | OT_INTVECTOR | Number of non-dynamic constraints,       |</span>
<span class="sd">    |                |              | length N+1                               |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | nu             | OT_INTVECTOR | Number of controls, length N             |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | nx             | OT_INTVECTOR | Number of states, length N+1             |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | print_level    | OT_INT       | Amount of diagnostic printing [Default:  |</span>
<span class="sd">    |                |              | 1].                                      |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | target         | OT_STRING    | hpmpc target                             |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | tol            | OT_DOUBLE    | Tolerance in the duality measure         |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>
<span class="sd">    | warm_start     | OT_BOOL      | Use warm-starting                        |</span>
<span class="sd">    +----------------+--------------+------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    ooqp</span>
<span class="sd">    ----</span>



<span class="sd">    Interface to the OOQP Solver for quadratic programming The current</span>
<span class="sd">    implementation assumes that OOQP is configured with the MA27 sparse linear</span>
<span class="sd">    solver.</span>

<span class="sd">    NOTE: when doing multiple calls to evaluate(), check if you need to</span>
<span class="sd">    reInit();</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------+-----------+------------------------------------------------+</span>
<span class="sd">    |     Id      |   Type    |                  Description                   |</span>
<span class="sd">    +=============+===========+================================================+</span>
<span class="sd">    | artol       | OT_DOUBLE | tolerance as provided with setArTol to OOQP    |</span>
<span class="sd">    +-------------+-----------+------------------------------------------------+</span>
<span class="sd">    | mutol       | OT_DOUBLE | tolerance as provided with setMuTol to OOQP    |</span>
<span class="sd">    +-------------+-----------+------------------------------------------------+</span>
<span class="sd">    | print_level | OT_INT    | Print level. OOQP listens to print_level 0, 10 |</span>
<span class="sd">    |             |           | and 100                                        |</span>
<span class="sd">    +-------------+-----------+------------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    osqp</span>
<span class="sd">    ----</span>



<span class="sd">    Interface to the OSQP Solver for quadratic programming</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------------+---------+--------------------------------------------+</span>
<span class="sd">    |        Id         |  Type   |                Description                 |</span>
<span class="sd">    +===================+=========+============================================+</span>
<span class="sd">    | osqp              | OT_DICT | const Options to be passed to osqp.        |</span>
<span class="sd">    +-------------------+---------+--------------------------------------------+</span>
<span class="sd">    | warm_start_dual   | OT_BOOL | Use lam_a0 and lam_x0 input to warmstart   |</span>
<span class="sd">    |                   |         | [Default: truw].                           |</span>
<span class="sd">    +-------------------+---------+--------------------------------------------+</span>
<span class="sd">    | warm_start_primal | OT_BOOL | Use x0 input to warmstart [Default: true]. |</span>
<span class="sd">    +-------------------+---------+--------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    qpoases</span>
<span class="sd">    -------</span>



<span class="sd">    Interface to QPOases Solver for quadratic programming</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    |              Id               |   Type    |         Description          |</span>
<span class="sd">    +===============================+===========+==============================+</span>
<span class="sd">    | CPUtime                       | OT_DOUBLE | The maximum allowed CPU time |</span>
<span class="sd">    |                               |           | in seconds for the whole     |</span>
<span class="sd">    |                               |           | initialisation (and the      |</span>
<span class="sd">    |                               |           | actually required one on     |</span>
<span class="sd">    |                               |           | output). Disabled if unset.  |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | boundRelaxation               | OT_DOUBLE | Initial relaxation of bounds |</span>
<span class="sd">    |                               |           | to start homotopy and        |</span>
<span class="sd">    |                               |           | initial value for far        |</span>
<span class="sd">    |                               |           | bounds.                      |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | boundTolerance                | OT_DOUBLE | If upper and lower bounds    |</span>
<span class="sd">    |                               |           | differ less than this        |</span>
<span class="sd">    |                               |           | tolerance, they are regarded |</span>
<span class="sd">    |                               |           | equal, i.e. as equality      |</span>
<span class="sd">    |                               |           | constraint.                  |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableCholeskyRefactorisation | OT_INT    | Specifies the frequency of a |</span>
<span class="sd">    |                               |           | full re-factorisation of     |</span>
<span class="sd">    |                               |           | projected Hessian matrix: 0: |</span>
<span class="sd">    |                               |           | turns them off, 1: uses them |</span>
<span class="sd">    |                               |           | at each iteration etc.       |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableDriftCorrection         | OT_INT    | Specifies the frequency of   |</span>
<span class="sd">    |                               |           | drift corrections: 0: turns  |</span>
<span class="sd">    |                               |           | them off.                    |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableEqualities              | OT_BOOL   | Specifies whether equalities |</span>
<span class="sd">    |                               |           | should be treated as always  |</span>
<span class="sd">    |                               |           | active (True) or not (False) |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableFarBounds               | OT_BOOL   | Enables the use of far       |</span>
<span class="sd">    |                               |           | bounds.                      |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableFlippingBounds          | OT_BOOL   | Enables the use of flipping  |</span>
<span class="sd">    |                               |           | bounds.                      |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableFullLITests             | OT_BOOL   | Enables condition-hardened   |</span>
<span class="sd">    |                               |           | (but more expensive) LI      |</span>
<span class="sd">    |                               |           | test.                        |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableInertiaCorrection       | OT_BOOL   | Should working set be        |</span>
<span class="sd">    |                               |           | repaired when negative       |</span>
<span class="sd">    |                               |           | curvature is discovered      |</span>
<span class="sd">    |                               |           | during hotstart.             |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableNZCTests                | OT_BOOL   | Enables nonzero curvature    |</span>
<span class="sd">    |                               |           | tests.                       |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableRamping                 | OT_BOOL   | Enables ramping.             |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | enableRegularisation          | OT_BOOL   | Enables automatic Hessian    |</span>
<span class="sd">    |                               |           | regularisation.              |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsDen                        | OT_DOUBLE | Denominator tolerance for    |</span>
<span class="sd">    |                               |           | ratio tests.                 |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsFlipping                   | OT_DOUBLE | Tolerance of squared         |</span>
<span class="sd">    |                               |           | Cholesky diagonal factor     |</span>
<span class="sd">    |                               |           | which triggers flipping      |</span>
<span class="sd">    |                               |           | bound.                       |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsIterRef                    | OT_DOUBLE | Early termination tolerance  |</span>
<span class="sd">    |                               |           | for iterative refinement.    |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsLITests                    | OT_DOUBLE | Tolerance for linear         |</span>
<span class="sd">    |                               |           | independence tests.          |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsNZCTests                   | OT_DOUBLE | Tolerance for nonzero        |</span>
<span class="sd">    |                               |           | curvature tests.             |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsNum                        | OT_DOUBLE | Numerator tolerance for      |</span>
<span class="sd">    |                               |           | ratio tests.                 |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | epsRegularisation             | OT_DOUBLE | Scaling factor of identity   |</span>
<span class="sd">    |                               |           | matrix used for Hessian      |</span>
<span class="sd">    |                               |           | regularisation.              |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | finalRamping                  | OT_DOUBLE | Final value for ramping      |</span>
<span class="sd">    |                               |           | strategy.                    |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | growFarBounds                 | OT_DOUBLE | Factor to grow far bounds.   |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | hessian_type                  | OT_STRING | Type of Hessian - see        |</span>
<span class="sd">    |                               |           | qpOASES documentation [UNKNO |</span>
<span class="sd">    |                               |           | WN|posdef|semidef|indef|zero |</span>
<span class="sd">    |                               |           | |identity]]                  |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | initialFarBounds              | OT_DOUBLE | Initial size for far bounds. |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | initialRamping                | OT_DOUBLE | Start value for ramping      |</span>
<span class="sd">    |                               |           | strategy.                    |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | initialStatusBounds           | OT_STRING | Initial status of bounds at  |</span>
<span class="sd">    |                               |           | first iteration.             |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | linsol_plugin                 | OT_STRING | Linear solver plugin         |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | maxDualJump                   | OT_DOUBLE | Maximum allowed jump in dual |</span>
<span class="sd">    |                               |           | variables in linear          |</span>
<span class="sd">    |                               |           | independence tests.          |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | maxPrimalJump                 | OT_DOUBLE | Maximum allowed jump in      |</span>
<span class="sd">    |                               |           | primal variables in nonzero  |</span>
<span class="sd">    |                               |           | curvature tests.             |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | max_schur                     | OT_INT    | Maximal number of Schur      |</span>
<span class="sd">    |                               |           | updates [75]                 |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | nWSR                          | OT_INT    | The maximum number of        |</span>
<span class="sd">    |                               |           | working set recalculations   |</span>
<span class="sd">    |                               |           | to be performed during the   |</span>
<span class="sd">    |                               |           | initial homotopy. Default is |</span>
<span class="sd">    |                               |           | 5(nx + nc)                   |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | numRefinementSteps            | OT_INT    | Maximum number of iterative  |</span>
<span class="sd">    |                               |           | refinement steps.            |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | numRegularisationSteps        | OT_INT    | Maximum number of successive |</span>
<span class="sd">    |                               |           | regularisation steps.        |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | printLevel                    | OT_STRING | Defines the amount of text   |</span>
<span class="sd">    |                               |           | output during QP solution,   |</span>
<span class="sd">    |                               |           | see Section 5.7              |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | schur                         | OT_BOOL   | Use Schur Complement         |</span>
<span class="sd">    |                               |           | Approach [false]             |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | sparse                        | OT_BOOL   | Formulate the QP using       |</span>
<span class="sd">    |                               |           | sparse matrices. [false]     |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>
<span class="sd">    | terminationTolerance          | OT_DOUBLE | Relative termination         |</span>
<span class="sd">    |                               |           | tolerance to stop homotopy.  |</span>
<span class="sd">    +-------------------------------+-----------+------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    sqic</span>
<span class="sd">    ----</span>



<span class="sd">    Interface to the SQIC solver for quadratic programming</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    superscs</span>
<span class="sd">    --------</span>



<span class="sd">    Interface to the SuperSCS solver for conic programming</span>

<span class="sd">    Joris Gillis, 2019</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------+---------+-----------------------------------+</span>
<span class="sd">    |    Id    |  Type   |            Description            |</span>
<span class="sd">    +==========+=========+===================================+</span>
<span class="sd">    | superscs | OT_DICT | Options to be passed to superscs. |</span>
<span class="sd">    +----------+---------+-----------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    nlpsol</span>
<span class="sd">    ------</span>



<span class="sd">    Solve QPs using an Nlpsol Use the &#39;nlpsol&#39; option to specify the NLP solver</span>
<span class="sd">    to use.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------------+-----------+---------------------------------+</span>
<span class="sd">    |       Id       |   Type    |           Description           |</span>
<span class="sd">    +================+===========+=================================+</span>
<span class="sd">    | nlpsol         | OT_STRING | Name of solver.                 |</span>
<span class="sd">    +----------------+-----------+---------------------------------+</span>
<span class="sd">    | nlpsol_options | OT_DICT   | Options to be passed to solver. |</span>
<span class="sd">    +----------------+-----------+---------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    qrqp</span>
<span class="sd">    ----</span>



<span class="sd">    Solve QPs using an active-set method</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    |       Id        |   Type    |                Description                 |</span>
<span class="sd">    +=================+===========+============================================+</span>
<span class="sd">    | constr_viol_tol | OT_DOUBLE | Constraint violation tolerance [1e-8].     |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | dual_inf_tol    | OT_DOUBLE | Dual feasibility violation tolerance       |</span>
<span class="sd">    |                 |           | [1e-8]                                     |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | max_iter        | OT_INT    | Maximum number of iterations [1000].       |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | min_lam         | OT_DOUBLE | Smallest multiplier treated as inactive    |</span>
<span class="sd">    |                 |           | for the initial active set [0].            |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | print_header    | OT_BOOL   | Print header [true].                       |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | print_info      | OT_BOOL   | Print info [true].                         |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | print_iter      | OT_BOOL   | Print iterations [true].                   |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | print_lincomb   | OT_BOOL   | Print dependant linear combinations of     |</span>
<span class="sd">    |                 |           | constraints [false]. Printed numbers are   |</span>
<span class="sd">    |                 |           | 0-based indices into the vector of [simple |</span>
<span class="sd">    |                 |           | bounds;linear bounds]                      |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joel Andersson</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">qpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    qpsol(str name, str solver, dict:SX qp, dict opts) -&gt; Function</span>
<span class="sd">    qpsol(str name, str solver, dict:MX qp, dict opts) -&gt; Function</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">qpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get QP solver input scheme name by index.</span>

<span class="sd">      conic_in() -&gt; [str]</span>
<span class="sd">      conic_in(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      conic_in()</span>



<span class="sd">    Get input scheme of QP solvers.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      conic_in(int ind)</span>



<span class="sd">    Get QP solver input scheme name by index.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get output scheme name by index.</span>

<span class="sd">      conic_out() -&gt; [str]</span>
<span class="sd">      conic_out(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      conic_out()</span>



<span class="sd">    Get QP solver output scheme of QP solvers.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      conic_out(int ind)</span>



<span class="sd">    Get output scheme name by index.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of QP solver inputs.</span>

<span class="sd">    conic_n_in() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of QP solver outputs.</span>

<span class="sd">    conic_n_out() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string,std::allocator&lt; std::string &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all options for a plugin.</span>

<span class="sd">    conic_options(str name) -&gt; [str]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_option_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get type info for a particular option.</span>

<span class="sd">    conic_option_type(str name, str op) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_option_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_option_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get documentation for a particular option.</span>

<span class="sd">    conic_option_info(str name, str op) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_option_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_conic(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_conic(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_conic(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_conic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conic_debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate native code in the interfaced language for debugging</span>

<span class="sd">    conic_debug(Function f, std::ostream &amp; file)</span>
<span class="sd">    conic_debug(Function f, str filename)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conic_debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">      nlpsol(str name, str solver, Importer compiler, dict opts) -&gt; Function</span>
<span class="sd">      nlpsol(str name, str solver, NlpBuilder nl, dict opts) -&gt; Function</span>
<span class="sd">      nlpsol(str name, str solver, dict:SX nlp, dict opts) -&gt; Function</span>
<span class="sd">      nlpsol(str name, str solver, dict:MX nlp, dict opts) -&gt; Function</span>
<span class="sd">      nlpsol(str name, str solver, str fname, dict opts) -&gt; Function</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      nlpsol(str name, str solver, Importer compiler, dict opts)</span>
<span class="sd">      nlpsol(str name, str solver, NlpBuilder nl, dict opts)</span>
<span class="sd">      nlpsol(str name, str solver, dict:MX nlp, dict opts)</span>
<span class="sd">      nlpsol(str name, str solver, str fname, dict opts)</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      nlpsol(str name, str solver, dict:SX nlp, dict opts)</span>



<span class="sd">    Create an NLP solver Creates a solver for the following parametric nonlinear</span>
<span class="sd">    program (NLP):</span>

<span class="sd">    ::</span>

<span class="sd">      min          F(x, p)</span>
<span class="sd">      x</span>

<span class="sd">      subject to</span>
<span class="sd">      LBX &lt;=   x    &lt;= UBX</span>
<span class="sd">      LBG &lt;= G(x, p) &lt;= UBG</span>
<span class="sd">      p  == P</span>

<span class="sd">      nx: number of decision variables</span>
<span class="sd">      ng: number of constraints</span>
<span class="sd">      np: number of parameters</span>



<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | bound_consistenc | OT_BOOL         | Ensure that      | casadi::Nlpsol   |</span>
<span class="sd">    | y                |                 | primal-dual      |                  |</span>
<span class="sd">    |                  |                 | solution is      |                  |</span>
<span class="sd">    |                  |                 | consistent with  |                  |</span>
<span class="sd">    |                  |                 | the bounds       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | calc_f           | OT_BOOL         | Calculate &#39;f&#39; in | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | the Nlpsol base  |                  |</span>
<span class="sd">    |                  |                 | class            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | calc_g           | OT_BOOL         | Calculate &#39;g&#39; in | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | the Nlpsol base  |                  |</span>
<span class="sd">    |                  |                 | class            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | calc_lam_p       | OT_BOOL         | Calculate        | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | &#39;lam_p&#39; in the   |                  |</span>
<span class="sd">    |                  |                 | Nlpsol base      |                  |</span>
<span class="sd">    |                  |                 | class            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | calc_lam_x       | OT_BOOL         | Calculate        | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | &#39;lam_x&#39; in the   |                  |</span>
<span class="sd">    |                  |                 | Nlpsol base      |                  |</span>
<span class="sd">    |                  |                 | class            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | calc_multipliers | OT_BOOL         | Calculate        | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | Lagrange         |                  |</span>
<span class="sd">    |                  |                 | multipliers in   |                  |</span>
<span class="sd">    |                  |                 | the Nlpsol base  |                  |</span>
<span class="sd">    |                  |                 | class            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | common_options   | OT_DICT         | Options for      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | auto-generated   | nction           |</span>
<span class="sd">    |                  |                 | functions        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | discrete         | OT_BOOLVECTOR   | Indicates which  | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | of the variables |                  |</span>
<span class="sd">    |                  |                 | are discrete,    |                  |</span>
<span class="sd">    |                  |                 | i.e. integer-    |                  |</span>
<span class="sd">    |                  |                 | valued           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | error_on_fail    | OT_BOOL         | When the         | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | numerical        |                  |</span>
<span class="sd">    |                  |                 | process returns  |                  |</span>
<span class="sd">    |                  |                 | unsuccessfully,  |                  |</span>
<span class="sd">    |                  |                 | raise an error   |                  |</span>
<span class="sd">    |                  |                 | (default false). |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | eval_errors_fata | OT_BOOL         | When errors      | casadi::Nlpsol   |</span>
<span class="sd">    | l                |                 | occur during     |                  |</span>
<span class="sd">    |                  |                 | evaluation of    |                  |</span>
<span class="sd">    |                  |                 | f,g,...,stop the |                  |</span>
<span class="sd">    |                  |                 | iterations       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | expand           | OT_BOOL         | Replace MX with  | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | SX expressions   | nction           |</span>
<span class="sd">    |                  |                 | in problem       |                  |</span>
<span class="sd">    |                  |                 | formulation      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | ignore_check_vec | OT_BOOL         | If set to true,  | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | the input shape  |                  |</span>
<span class="sd">    |                  |                 | of F will not be |                  |</span>
<span class="sd">    |                  |                 | checked.         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | iteration_callba | OT_FUNCTION     | A function that  | casadi::Nlpsol   |</span>
<span class="sd">    | ck               |                 | will be called   |                  |</span>
<span class="sd">    |                  |                 | at each          |                  |</span>
<span class="sd">    |                  |                 | iteration with   |                  |</span>
<span class="sd">    |                  |                 | the solver as    |                  |</span>
<span class="sd">    |                  |                 | input. Check     |                  |</span>
<span class="sd">    |                  |                 | documentation of |                  |</span>
<span class="sd">    |                  |                 | Callback .       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | iteration_callba | OT_BOOL         | If set to true,  | casadi::Nlpsol   |</span>
<span class="sd">    | ck_ignore_errors |                 | errors thrown by |                  |</span>
<span class="sd">    |                  |                 | iteration_callba |                  |</span>
<span class="sd">    |                  |                 | ck will be       |                  |</span>
<span class="sd">    |                  |                 | ignored.         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | iteration_callba | OT_INT          | Only call the    | casadi::Nlpsol   |</span>
<span class="sd">    | ck_step          |                 | callback         |                  |</span>
<span class="sd">    |                  |                 | function every   |                  |</span>
<span class="sd">    |                  |                 | few iterations.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | min_lam          | OT_DOUBLE       | Minimum allowed  | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | multiplier value |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | problem          | nction           |</span>
<span class="sd">    |                  |                 | functions to be  |                  |</span>
<span class="sd">    |                  |                 | monitored        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | no_nlp_grad      | OT_BOOL         | Prevent the      | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | creation of the  |                  |</span>
<span class="sd">    |                  |                 | &#39;nlp_grad&#39;       |                  |</span>
<span class="sd">    |                  |                 | function         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | oracle_options   | OT_DICT         | Options to be    | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | passed to the    |                  |</span>
<span class="sd">    |                  |                 | oracle function  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | sens_linsol      | OT_STRING       | Linear solver    | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | used for         |                  |</span>
<span class="sd">    |                  |                 | parametric       |                  |</span>
<span class="sd">    |                  |                 | sensitivities    |                  |</span>
<span class="sd">    |                  |                 | (default &#39;qr&#39;).  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | sens_linsol_opti | OT_DICT         | Linear solver    | casadi::Nlpsol   |</span>
<span class="sd">    | ons              |                 | options used for |                  |</span>
<span class="sd">    |                  |                 | parametric       |                  |</span>
<span class="sd">    |                  |                 | sensitivities.   |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | show_eval_warnin | OT_BOOL         | Show warnings    | casadi::OracleFu |</span>
<span class="sd">    | gs               |                 | generated from   | nction           |</span>
<span class="sd">    |                  |                 | function         |                  |</span>
<span class="sd">    |                  |                 | evaluations      |                  |</span>
<span class="sd">    |                  |                 | [true]           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | specific_options | OT_DICT         | Options for      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | specific auto-   | nction           |</span>
<span class="sd">    |                  |                 | generated        |                  |</span>
<span class="sd">    |                  |                 | functions,       |                  |</span>
<span class="sd">    |                  |                 | overwriting the  |                  |</span>
<span class="sd">    |                  |                 | defaults from    |                  |</span>
<span class="sd">    |                  |                 | common_options.  |                  |</span>
<span class="sd">    |                  |                 | Nested           |                  |</span>
<span class="sd">    |                  |                 | dictionary.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | verbose_init     | OT_BOOL         | Print out timing | casadi::Nlpsol   |</span>
<span class="sd">    |                  |                 | information      |                  |</span>
<span class="sd">    |                  |                 | about the        |                  |</span>
<span class="sd">    |                  |                 | different stages |                  |</span>
<span class="sd">    |                  |                 | of               |                  |</span>
<span class="sd">    |                  |                 | initialization   |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | warn_initial_bou | OT_BOOL         | Warn if the      | casadi::Nlpsol   |</span>
<span class="sd">    | nds              |                 | initial guess    |                  |</span>
<span class="sd">    |                  |                 | does not satisfy |                  |</span>
<span class="sd">    |                  |                 | LBX and UBX      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    &gt;Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)</span>

<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    |   Full name   | Short  |                   Description                   |</span>
<span class="sd">    +===============+========+=================================================+</span>
<span class="sd">    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |</span>
<span class="sd">    |               |        | default -inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |</span>
<span class="sd">    |               |        | default +inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |</span>
<span class="sd">    |               |        | guess (nx x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |</span>
<span class="sd">    |               |        | guess (ng x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>

<span class="sd">    &gt;Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)</span>

<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    |  Full name   | Short |                    Description                    |</span>
<span class="sd">    +==============+=======+===================================================+</span>
<span class="sd">    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |</span>
<span class="sd">    |              |       | x 1)                                              |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |</span>
<span class="sd">    |              |       | solution (nx x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |</span>
<span class="sd">    |              |       | solution (ng x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |</span>
<span class="sd">    |              |       | solution (np x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - AmplInterface</span>

<span class="sd">    - blocksqp</span>

<span class="sd">    - bonmin</span>

<span class="sd">    - ipopt</span>

<span class="sd">    - knitro</span>

<span class="sd">    - snopt</span>

<span class="sd">    - worhp</span>

<span class="sd">    - qrsqp</span>

<span class="sd">    - scpgen</span>

<span class="sd">    - sqpmethod</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Nlpsol.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    AmplInterface</span>
<span class="sd">    -------------</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +--------+-----------+--------------------+</span>
<span class="sd">    |   Id   |   Type    |    Description     |</span>
<span class="sd">    +========+===========+====================+</span>
<span class="sd">    | solver | OT_STRING | AMPL solver binary |</span>
<span class="sd">    +--------+-----------+--------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    blocksqp</span>
<span class="sd">    --------</span>



<span class="sd">    This is a modified version of blockSQP by Janka et al.</span>

<span class="sd">    Dennis Janka, Joel Andersson</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    |             Id             |   Type    |           Description           |</span>
<span class="sd">    +============================+===========+=================================+</span>
<span class="sd">    | block_hess                 | OT_INT    | Blockwise Hessian               |</span>
<span class="sd">    |                            |           | approximation?                  |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | col_eps                    | OT_DOUBLE | Epsilon for COL scaling         |</span>
<span class="sd">    |                            |           | strategy                        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | col_tau1                   | OT_DOUBLE | tau1 for COL scaling strategy   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | col_tau2                   | OT_DOUBLE | tau2 for COL scaling strategy   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | conv_strategy              | OT_INT    | Convexification strategy        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | delta                      | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | delta_h0                   | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | eps                        | OT_DOUBLE | Values smaller than this are    |</span>
<span class="sd">    |                            |           | regarded as numerically zero    |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | eta                        | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | fallback_scaling           | OT_INT    | If indefinite update is used,   |</span>
<span class="sd">    |                            |           | the type of fallback strategy   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | fallback_update            | OT_INT    | If indefinite update is used,   |</span>
<span class="sd">    |                            |           | the type of fallback strategy   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | gamma_f                    | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | gamma_theta                | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | globalization              | OT_BOOL   | Enable globalization            |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | hess_damp                  | OT_INT    | Activate Powell damping for     |</span>
<span class="sd">    |                            |           | BFGS                            |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | hess_damp_fac              | OT_DOUBLE | Damping factor for BFGS Powell  |</span>
<span class="sd">    |                            |           | modification                    |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | hess_lim_mem               | OT_INT    | Full or limited memory          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | hess_memsize               | OT_INT    | Memory size for L-BFGS updates  |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | hess_scaling               | OT_INT    | Scaling strategy for Hessian    |</span>
<span class="sd">    |                            |           | approximation                   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | hess_update                | OT_INT    | Type of Hessian approximation   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | ini_hess_diag              | OT_DOUBLE | Initial Hessian guess: diagonal |</span>
<span class="sd">    |                            |           | matrix diag(iniHessDiag)        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | kappa_f                    | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | kappa_minus                | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | kappa_plus                 | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | kappa_plus_max             | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | kappa_soc                  | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | linsol                     | OT_STRING | The linear solver to be used by |</span>
<span class="sd">    |                            |           | the QP method                   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_consec_reduced_steps   | OT_INT    | Maximum number of consecutive   |</span>
<span class="sd">    |                            |           | reduced steps                   |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_consec_skipped_updates | OT_INT    | Maximum number of consecutive   |</span>
<span class="sd">    |                            |           | skipped updates                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_conv_qp                | OT_INT    | How many additional QPs may be  |</span>
<span class="sd">    |                            |           | solved for convexification per  |</span>
<span class="sd">    |                            |           | iteration?                      |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_it_qp                  | OT_INT    | Maximum number of QP iterations |</span>
<span class="sd">    |                            |           | per SQP iteration               |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_iter                   | OT_INT    | Maximum number of SQP           |</span>
<span class="sd">    |                            |           | iterations                      |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_line_search            | OT_INT    | Maximum number of steps in line |</span>
<span class="sd">    |                            |           | search                          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_soc_iter               | OT_INT    | Maximum number of SOC line      |</span>
<span class="sd">    |                            |           | search iterations               |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | max_time_qp                | OT_DOUBLE | Maximum number of time in       |</span>
<span class="sd">    |                            |           | seconds per QP solve per SQP    |</span>
<span class="sd">    |                            |           | iteration                       |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | nlinfeastol                | OT_DOUBLE | Nonlinear feasibility tolerance |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | obj_lo                     | OT_DOUBLE | Lower bound on objective        |</span>
<span class="sd">    |                            |           | function [-inf]                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | obj_up                     | OT_DOUBLE | Upper bound on objective        |</span>
<span class="sd">    |                            |           | function [inf]                  |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | opttol                     | OT_DOUBLE | Optimality tolerance            |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | print_header               | OT_BOOL   | Print solver header at startup  |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | print_iteration            | OT_BOOL   | Print SQP iterations            |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | print_maxit_reached        | OT_BOOL   | Print error when maximum number |</span>
<span class="sd">    |                            |           | of SQP iterations reached       |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | qp_init                    | OT_BOOL   | Use warmstarting                |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | qpsol                      | OT_STRING | The QP solver to be used by the |</span>
<span class="sd">    |                            |           | SQP method                      |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | qpsol_options              | OT_DICT   | Options to be passed to the QP  |</span>
<span class="sd">    |                            |           | solver                          |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | restore_feas               | OT_BOOL   | Use feasibility restoration     |</span>
<span class="sd">    |                            |           | phase                           |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | rho                        | OT_DOUBLE | Feasibility restoration phase   |</span>
<span class="sd">    |                            |           | parameter                       |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | s_f                        | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | s_theta                    | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | schur                      | OT_BOOL   | Use qpOASES Schur compliment    |</span>
<span class="sd">    |                            |           | approach                        |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | skip_first_globalization   | OT_BOOL   | No globalization strategy in    |</span>
<span class="sd">    |                            |           | first iteration                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | theta_max                  | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | theta_min                  | OT_DOUBLE | Filter line search parameter,   |</span>
<span class="sd">    |                            |           | cf. IPOPT paper                 |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | warmstart                  | OT_BOOL   | Use warmstarting                |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | which_second_derv          | OT_INT    | For which block should second   |</span>
<span class="sd">    |                            |           | derivatives be provided by the  |</span>
<span class="sd">    |                            |           | user                            |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>
<span class="sd">    | zeta                       | OT_DOUBLE | Feasibility restoration phase   |</span>
<span class="sd">    |                            |           | parameter                       |</span>
<span class="sd">    +----------------------------+-----------+---------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    bonmin</span>
<span class="sd">    ------</span>



<span class="sd">    When in warmstart mode, output NLPSOL_LAM_X may be used as input</span>

<span class="sd">    NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) ==</span>
<span class="sd">    output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will</span>
<span class="sd">    differ.</span>

<span class="sd">    For a good tutorial on BONMIN,</span>
<span class="sd">    seehttp://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf</span>

<span class="sd">    A good resource about the algorithms in BONMIN is: Wachter and L. T.</span>
<span class="sd">    Biegler, On the Implementation of an Interior-Point Filter Line-Search</span>
<span class="sd">    Algorithm for Large-Scale Nonlinear Programming, Mathematical Programming</span>
<span class="sd">    106(1), pp. 25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson</span>
<span class="sd">    Research Center, Yorktown, USA</span>

<span class="sd">    Caveats: with default options, multipliers for the decision variables are</span>
<span class="sd">    wrong for equality constraints. Change the &#39;fixed_variable_treatment&#39; to</span>
<span class="sd">    &#39;make_constraint&#39; or &#39;relax_bounds&#39; to obtain correct results.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    |           Id            |         Type          |      Description       |</span>
<span class="sd">    +=========================+=======================+========================+</span>
<span class="sd">    | bonmin                  | OT_DICT               | Options to be passed   |</span>
<span class="sd">    |                         |                       | to BONMIN              |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | con_integer_md          | OT_DICT               | Integer metadata (a    |</span>
<span class="sd">    |                         |                       | dictionary with lists  |</span>
<span class="sd">    |                         |                       | of integers) about     |</span>
<span class="sd">    |                         |                       | constraints to be      |</span>
<span class="sd">    |                         |                       | passed to BONMIN       |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | con_numeric_md          | OT_DICT               | Numeric metadata (a    |</span>
<span class="sd">    |                         |                       | dictionary with lists  |</span>
<span class="sd">    |                         |                       | of reals) about        |</span>
<span class="sd">    |                         |                       | constraints to be      |</span>
<span class="sd">    |                         |                       | passed to BONMIN       |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | con_string_md           | OT_DICT               | String metadata (a     |</span>
<span class="sd">    |                         |                       | dictionary with lists  |</span>
<span class="sd">    |                         |                       | of strings) about      |</span>
<span class="sd">    |                         |                       | constraints to be      |</span>
<span class="sd">    |                         |                       | passed to BONMIN       |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | grad_f                  | OT_FUNCTION           | Function for           |</span>
<span class="sd">    |                         |                       | calculating the        |</span>
<span class="sd">    |                         |                       | gradient of the        |</span>
<span class="sd">    |                         |                       | objective (column,     |</span>
<span class="sd">    |                         |                       | autogenerated by       |</span>
<span class="sd">    |                         |                       | default)               |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | grad_f_options          | OT_DICT               | Options for the        |</span>
<span class="sd">    |                         |                       | autogenerated gradient |</span>
<span class="sd">    |                         |                       | of the objective.      |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | hess_lag                | OT_FUNCTION           | Function for           |</span>
<span class="sd">    |                         |                       | calculating the        |</span>
<span class="sd">    |                         |                       | Hessian of the         |</span>
<span class="sd">    |                         |                       | Lagrangian             |</span>
<span class="sd">    |                         |                       | (autogenerated by      |</span>
<span class="sd">    |                         |                       | default)               |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | hess_lag_options        | OT_DICT               | Options for the        |</span>
<span class="sd">    |                         |                       | autogenerated Hessian  |</span>
<span class="sd">    |                         |                       | of the Lagrangian.     |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | jac_g                   | OT_FUNCTION           | Function for           |</span>
<span class="sd">    |                         |                       | calculating the        |</span>
<span class="sd">    |                         |                       | Jacobian of the        |</span>
<span class="sd">    |                         |                       | constraints            |</span>
<span class="sd">    |                         |                       | (autogenerated by      |</span>
<span class="sd">    |                         |                       | default)               |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | jac_g_options           | OT_DICT               | Options for the        |</span>
<span class="sd">    |                         |                       | autogenerated Jacobian |</span>
<span class="sd">    |                         |                       | of the constraints.    |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | pass_nonlinear_constrai | OT_BOOL               | Pass list of           |</span>
<span class="sd">    | nts                     |                       | constraints entering   |</span>
<span class="sd">    |                         |                       | nonlinearly to BONMIN  |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | pass_nonlinear_variable | OT_BOOL               | Pass list of variables |</span>
<span class="sd">    | s                       |                       | entering nonlinearly   |</span>
<span class="sd">    |                         |                       | to BONMIN              |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | sos1_groups             | OT_INTVECTORVECTOR    | Options for the        |</span>
<span class="sd">    |                         |                       | autogenerated gradient |</span>
<span class="sd">    |                         |                       | of the objective.      |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | sos1_priorities         | OT_INTVECTOR          | Options for the        |</span>
<span class="sd">    |                         |                       | autogenerated gradient |</span>
<span class="sd">    |                         |                       | of the objective.      |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | sos1_weights            | OT_DOUBLEVECTORVECTOR | Options for the        |</span>
<span class="sd">    |                         |                       | autogenerated gradient |</span>
<span class="sd">    |                         |                       | of the objective.      |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | var_integer_md          | OT_DICT               | Integer metadata (a    |</span>
<span class="sd">    |                         |                       | dictionary with lists  |</span>
<span class="sd">    |                         |                       | of integers) about     |</span>
<span class="sd">    |                         |                       | variables to be passed |</span>
<span class="sd">    |                         |                       | to BONMIN              |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | var_numeric_md          | OT_DICT               | Numeric metadata (a    |</span>
<span class="sd">    |                         |                       | dictionary with lists  |</span>
<span class="sd">    |                         |                       | of reals) about        |</span>
<span class="sd">    |                         |                       | variables to be passed |</span>
<span class="sd">    |                         |                       | to BONMIN              |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>
<span class="sd">    | var_string_md           | OT_DICT               | String metadata (a     |</span>
<span class="sd">    |                         |                       | dictionary with lists  |</span>
<span class="sd">    |                         |                       | of strings) about      |</span>
<span class="sd">    |                         |                       | variables to be passed |</span>
<span class="sd">    |                         |                       | to BONMIN              |</span>
<span class="sd">    +-------------------------+-----------------------+------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    ipopt</span>
<span class="sd">    -----</span>



<span class="sd">    When in warmstart mode, output NLPSOL_LAM_X may be used as input</span>

<span class="sd">    NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) ==</span>
<span class="sd">    output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will</span>
<span class="sd">    differ.</span>

<span class="sd">    For a good tutorial on IPOPT,</span>
<span class="sd">    seehttp://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf</span>

<span class="sd">    A good resource about the algorithms in IPOPT is: Wachter and L. T. Biegler,</span>
<span class="sd">    On the Implementation of an Interior-Point Filter Line-Search Algorithm for</span>
<span class="sd">    Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp.</span>
<span class="sd">    25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center,</span>
<span class="sd">    Yorktown, USA</span>

<span class="sd">    Caveats: with default options, multipliers for the decision variables are</span>
<span class="sd">    wrong for equality constraints. Change the &#39;fixed_variable_treatment&#39; to</span>
<span class="sd">    &#39;make_constraint&#39; or &#39;relax_bounds&#39; to obtain correct results.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    |            Id            |    Type     |           Description           |</span>
<span class="sd">    +==========================+=============+=================================+</span>
<span class="sd">    | clip_inactive_lam        | OT_BOOL     | Explicitly set Lagrange         |</span>
<span class="sd">    |                          |             | multipliers to 0 when bound is  |</span>
<span class="sd">    |                          |             | deemed inactive (default:       |</span>
<span class="sd">    |                          |             | false).                         |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | con_integer_md           | OT_DICT     | Integer metadata (a dictionary  |</span>
<span class="sd">    |                          |             | with lists of integers) about   |</span>
<span class="sd">    |                          |             | constraints to be passed to     |</span>
<span class="sd">    |                          |             | IPOPT                           |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | con_numeric_md           | OT_DICT     | Numeric metadata (a dictionary  |</span>
<span class="sd">    |                          |             | with lists of reals) about      |</span>
<span class="sd">    |                          |             | constraints to be passed to     |</span>
<span class="sd">    |                          |             | IPOPT                           |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | con_string_md            | OT_DICT     | String metadata (a dictionary   |</span>
<span class="sd">    |                          |             | with lists of strings) about    |</span>
<span class="sd">    |                          |             | constraints to be passed to     |</span>
<span class="sd">    |                          |             | IPOPT                           |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | convexify_margin         | OT_DOUBLE   | When using a convexification    |</span>
<span class="sd">    |                          |             | strategy, make sure that the    |</span>
<span class="sd">    |                          |             | smallest eigenvalue is at least |</span>
<span class="sd">    |                          |             | this (default: 1e-7).           |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | convexify_strategy       | OT_STRING   | NONE|regularize|eigen-reflect   |</span>
<span class="sd">    |                          |             | |eigen-clip. Strategy to        |</span>
<span class="sd">    |                          |             | convexify the Lagrange Hessian  |</span>
<span class="sd">    |                          |             | before passing it to the        |</span>
<span class="sd">    |                          |             | solver.                         |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | grad_f                   | OT_FUNCTION | Function for calculating the    |</span>
<span class="sd">    |                          |             | gradient of the objective       |</span>
<span class="sd">    |                          |             | (column, autogenerated by       |</span>
<span class="sd">    |                          |             | default)                        |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | hess_lag                 | OT_FUNCTION | Function for calculating the    |</span>
<span class="sd">    |                          |             | Hessian of the Lagrangian       |</span>
<span class="sd">    |                          |             | (autogenerated by default)      |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | inactive_lam_strategy    | OT_STRING   | Strategy to detect if a bound   |</span>
<span class="sd">    |                          |             | is inactive. RELTOL: use        |</span>
<span class="sd">    |                          |             | solver-defined constraint       |</span>
<span class="sd">    |                          |             | tolerance *                     |</span>
<span class="sd">    |                          |             | inactive_lam_value|abstol: use  |</span>
<span class="sd">    |                          |             | inactive_lam_value              |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | inactive_lam_value       | OT_DOUBLE   | Value used in                   |</span>
<span class="sd">    |                          |             | inactive_lam_strategy (default: |</span>
<span class="sd">    |                          |             | 10).                            |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | ipopt                    | OT_DICT     | Options to be passed to IPOPT   |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | jac_g                    | OT_FUNCTION | Function for calculating the    |</span>
<span class="sd">    |                          |             | Jacobian of the constraints     |</span>
<span class="sd">    |                          |             | (autogenerated by default)      |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | max_iter_eig             | OT_DOUBLE   | Maximum number of iterations to |</span>
<span class="sd">    |                          |             | compute an eigenvalue           |</span>
<span class="sd">    |                          |             | decomposition (default: 50).    |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | pass_nonlinear_variables | OT_BOOL     | Pass list of variables entering |</span>
<span class="sd">    |                          |             | nonlinearly to IPOPT            |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | var_integer_md           | OT_DICT     | Integer metadata (a dictionary  |</span>
<span class="sd">    |                          |             | with lists of integers) about   |</span>
<span class="sd">    |                          |             | variables to be passed to IPOPT |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | var_numeric_md           | OT_DICT     | Numeric metadata (a dictionary  |</span>
<span class="sd">    |                          |             | with lists of reals) about      |</span>
<span class="sd">    |                          |             | variables to be passed to IPOPT |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>
<span class="sd">    | var_string_md            | OT_DICT     | String metadata (a dictionary   |</span>
<span class="sd">    |                          |             | with lists of strings) about    |</span>
<span class="sd">    |                          |             | variables to be passed to IPOPT |</span>
<span class="sd">    +--------------------------+-------------+---------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    knitro</span>
<span class="sd">    ------</span>



<span class="sd">    KNITRO interface</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +--------------------------+--------------------+--------------------------+</span>
<span class="sd">    |            Id            |        Type        |       Description        |</span>
<span class="sd">    +==========================+====================+==========================+</span>
<span class="sd">    | complem_variables        | OT_INTVECTORVECTOR | List of complementary    |</span>
<span class="sd">    |                          |                    | constraints on simple    |</span>
<span class="sd">    |                          |                    | bounds. Pair (i, j)      |</span>
<span class="sd">    |                          |                    | encodes complementarity  |</span>
<span class="sd">    |                          |                    | between the bounds on    |</span>
<span class="sd">    |                          |                    | variable i and variable  |</span>
<span class="sd">    |                          |                    | j.                       |</span>
<span class="sd">    +--------------------------+--------------------+--------------------------+</span>
<span class="sd">    | contype                  | OT_INTVECTOR       | Type of constraint       |</span>
<span class="sd">    +--------------------------+--------------------+--------------------------+</span>
<span class="sd">    | detect_linear_constraint | OT_BOOL            | Detect type of           |</span>
<span class="sd">    | s                        |                    | constraints              |</span>
<span class="sd">    +--------------------------+--------------------+--------------------------+</span>
<span class="sd">    | knitro                   | OT_DICT            | Options to be passed to  |</span>
<span class="sd">    |                          |                    | KNITRO                   |</span>
<span class="sd">    +--------------------------+--------------------+--------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    snopt</span>
<span class="sd">    -----</span>



<span class="sd">    SNOPT interface</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------+-----------+---------------------------------------------+</span>
<span class="sd">    |  Id   |   Type    |                 Description                 |</span>
<span class="sd">    +=======+===========+=============================================+</span>
<span class="sd">    | snopt | OT_DICT   | Options to be passed to SNOPT               |</span>
<span class="sd">    +-------+-----------+---------------------------------------------+</span>
<span class="sd">    | start | OT_STRING | Warm-start options for Worhp: cold|warm|hot |</span>
<span class="sd">    +-------+-----------+---------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    worhp</span>
<span class="sd">    -----</span>



<span class="sd">    WORHP interface</span>

<span class="sd">    Designed for Worhp 1.12</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------+---------+-------------------------------+</span>
<span class="sd">    |  Id   |  Type   |          Description          |</span>
<span class="sd">    +=======+=========+===============================+</span>
<span class="sd">    | worhp | OT_DICT | Options to be passed to WORHP |</span>
<span class="sd">    +-------+---------+-------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    qrsqp</span>
<span class="sd">    -----</span>



<span class="sd">    A textbook SQPMethod</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    scpgen</span>
<span class="sd">    ------</span>



<span class="sd">    A structure-exploiting sequential quadratic programming (to be come</span>
<span class="sd">    sequential convex programming) method for nonlinear programming.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    |          Id           |      Type       |          Description           |</span>
<span class="sd">    +=======================+=================+================================+</span>
<span class="sd">    | beta                  | OT_DOUBLE       | Line-search parameter,         |</span>
<span class="sd">    |                       |                 | restoration factor of stepsize |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | c1                    | OT_DOUBLE       | Armijo condition, coefficient  |</span>
<span class="sd">    |                       |                 | of decrease in merit           |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | codegen               | OT_BOOL         | C-code generation              |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | hessian_approximation | OT_STRING       | gauss-newton|exact             |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | lbfgs_memory          | OT_INT          | Size of L-BFGS memory.         |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | max_iter              | OT_INT          | Maximum number of SQP          |</span>
<span class="sd">    |                       |                 | iterations                     |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | max_iter_ls           | OT_INT          | Maximum number of linesearch   |</span>
<span class="sd">    |                       |                 | iterations                     |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | merit_memsize         | OT_INT          | Size of memory to store        |</span>
<span class="sd">    |                       |                 | history of merit function      |</span>
<span class="sd">    |                       |                 | values                         |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | merit_start           | OT_DOUBLE       | Lower bound for the merit      |</span>
<span class="sd">    |                       |                 | function parameter             |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | name_x                | OT_STRINGVECTOR | Names of the variables.        |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | print_header          | OT_BOOL         | Print the header with problem  |</span>
<span class="sd">    |                       |                 | statistics                     |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | print_x               | OT_INTVECTOR    | Which variables to print.      |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | qpsol                 | OT_STRING       | The QP solver to be used by    |</span>
<span class="sd">    |                       |                 | the SQP method                 |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | qpsol_options         | OT_DICT         | Options to be passed to the QP |</span>
<span class="sd">    |                       |                 | solver                         |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | reg_threshold         | OT_DOUBLE       | Threshold for the              |</span>
<span class="sd">    |                       |                 | regularization.                |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | regularize            | OT_BOOL         | Automatic regularization of    |</span>
<span class="sd">    |                       |                 | Lagrange Hessian.              |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | tol_du                | OT_DOUBLE       | Stopping criterion for dual    |</span>
<span class="sd">    |                       |                 | infeasability                  |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | tol_pr                | OT_DOUBLE       | Stopping criterion for primal  |</span>
<span class="sd">    |                       |                 | infeasibility                  |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | tol_pr_step           | OT_DOUBLE       | Stopping criterion for the     |</span>
<span class="sd">    |                       |                 | step size                      |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>
<span class="sd">    | tol_reg               | OT_DOUBLE       | Stopping criterion for         |</span>
<span class="sd">    |                       |                 | regularization                 |</span>
<span class="sd">    +-----------------------+-----------------+--------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    sqpmethod</span>
<span class="sd">    ---------</span>



<span class="sd">    A textbook SQPMethod</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    |          Id           |    Type     |            Description             |</span>
<span class="sd">    +=======================+=============+====================================+</span>
<span class="sd">    | beta                  | OT_DOUBLE   | Line-search parameter, restoration |</span>
<span class="sd">    |                       |             | factor of stepsize                 |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | c1                    | OT_DOUBLE   | Armijo condition, coefficient of   |</span>
<span class="sd">    |                       |             | decrease in merit                  |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | convexify_margin      | OT_DOUBLE   | When using a convexification       |</span>
<span class="sd">    |                       |             | strategy, make sure that the       |</span>
<span class="sd">    |                       |             | smallest eigenvalue is at least    |</span>
<span class="sd">    |                       |             | this (default: 1e-7).              |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | convexify_strategy    | OT_STRING   | NONE|regularize|eigen-reflect      |</span>
<span class="sd">    |                       |             | |eigen-clip. Strategy to convexify |</span>
<span class="sd">    |                       |             | the Lagrange Hessian before        |</span>
<span class="sd">    |                       |             | passing it to the solver.          |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | hess_lag              | OT_FUNCTION | Function for calculating the       |</span>
<span class="sd">    |                       |             | Hessian of the Lagrangian          |</span>
<span class="sd">    |                       |             | (autogenerated by default)         |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | hessian_approximation | OT_STRING   | limited-memory|exact               |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | jac_fg                | OT_FUNCTION | Function for calculating the       |</span>
<span class="sd">    |                       |             | gradient of the objective and      |</span>
<span class="sd">    |                       |             | Jacobian of the constraints        |</span>
<span class="sd">    |                       |             | (autogenerated by default)         |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | lbfgs_memory          | OT_INT      | Size of L-BFGS memory.             |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | max_iter              | OT_INT      | Maximum number of SQP iterations   |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | max_iter_eig          | OT_DOUBLE   | Maximum number of iterations to    |</span>
<span class="sd">    |                       |             | compute an eigenvalue              |</span>
<span class="sd">    |                       |             | decomposition (default: 50).       |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | max_iter_ls           | OT_INT      | Maximum number of linesearch       |</span>
<span class="sd">    |                       |             | iterations                         |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | merit_memory          | OT_INT      | Size of memory to store history of |</span>
<span class="sd">    |                       |             | merit function values              |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | min_iter              | OT_INT      | Minimum number of SQP iterations   |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | min_step_size         | OT_DOUBLE   | The size (inf-norm) of the step    |</span>
<span class="sd">    |                       |             | size should not become smaller     |</span>
<span class="sd">    |                       |             | than this.                         |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | print_header          | OT_BOOL     | Print the header with problem      |</span>
<span class="sd">    |                       |             | statistics                         |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | print_iteration       | OT_BOOL     | Print the iterations               |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | print_status          | OT_BOOL     | Print a status message after       |</span>
<span class="sd">    |                       |             | solving                            |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | qpsol                 | OT_STRING   | The QP solver to be used by the    |</span>
<span class="sd">    |                       |             | SQP method [qpoases]               |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | qpsol_options         | OT_DICT     | Options to be passed to the QP     |</span>
<span class="sd">    |                       |             | solver                             |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | tol_du                | OT_DOUBLE   | Stopping criterion for dual        |</span>
<span class="sd">    |                       |             | infeasability                      |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>
<span class="sd">    | tol_pr                | OT_DOUBLE   | Stopping criterion for primal      |</span>
<span class="sd">    |                       |             | infeasibility                      |</span>
<span class="sd">    +-----------------------+-------------+------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joel Andersson</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get NLP solver input scheme name by index.</span>

<span class="sd">      nlpsol_in() -&gt; [str]</span>
<span class="sd">      nlpsol_in(int ind) -&gt; str</span>


<span class="sd">    &gt;Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)</span>

<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    |   Full name   | Short  |                   Description                   |</span>
<span class="sd">    +===============+========+=================================================+</span>
<span class="sd">    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |</span>
<span class="sd">    |               |        | default -inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |</span>
<span class="sd">    |               |        | default +inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |</span>
<span class="sd">    |               |        | guess (nx x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |</span>
<span class="sd">    |               |        | guess (ng x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>



<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      nlpsol_in(int ind)</span>



<span class="sd">    Get NLP solver input scheme name by index.</span>

<span class="sd">    &gt;Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)</span>

<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    |   Full name   | Short  |                   Description                   |</span>
<span class="sd">    +===============+========+=================================================+</span>
<span class="sd">    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |</span>
<span class="sd">    |               |        | default -inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |</span>
<span class="sd">    |               |        | default +inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |</span>
<span class="sd">    |               |        | guess (nx x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |</span>
<span class="sd">    |               |        | guess (ng x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      nlpsol_in()</span>



<span class="sd">    Get input scheme of NLP solvers.</span>

<span class="sd">    &gt;Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)</span>

<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    |   Full name   | Short  |                   Description                   |</span>
<span class="sd">    +===============+========+=================================================+</span>
<span class="sd">    | NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |</span>
<span class="sd">    |               |        | default -inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |</span>
<span class="sd">    |               |        | default +inf.                                   |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |</span>
<span class="sd">    |               |        | guess (nx x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |</span>
<span class="sd">    |               |        | guess (ng x 1)                                  |</span>
<span class="sd">    +---------------+--------+-------------------------------------------------+</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get output scheme name by index.</span>

<span class="sd">      nlpsol_out() -&gt; [str]</span>
<span class="sd">      nlpsol_out(int ind) -&gt; str</span>


<span class="sd">    &gt;Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)</span>

<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    |  Full name   | Short |                    Description                    |</span>
<span class="sd">    +==============+=======+===================================================+</span>
<span class="sd">    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |</span>
<span class="sd">    |              |       | x 1)                                              |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |</span>
<span class="sd">    |              |       | solution (nx x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |</span>
<span class="sd">    |              |       | solution (ng x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |</span>
<span class="sd">    |              |       | solution (np x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>



<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      nlpsol_out(int ind)</span>



<span class="sd">    Get output scheme name by index.</span>

<span class="sd">    &gt;Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)</span>

<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    |  Full name   | Short |                    Description                    |</span>
<span class="sd">    +==============+=======+===================================================+</span>
<span class="sd">    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |</span>
<span class="sd">    |              |       | x 1)                                              |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |</span>
<span class="sd">    |              |       | solution (nx x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |</span>
<span class="sd">    |              |       | solution (ng x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |</span>
<span class="sd">    |              |       | solution (np x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      nlpsol_out()</span>



<span class="sd">    Get NLP solver output scheme of NLP solvers.</span>

<span class="sd">    &gt;Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)</span>

<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    |  Full name   | Short |                    Description                    |</span>
<span class="sd">    +==============+=======+===================================================+</span>
<span class="sd">    | NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |</span>
<span class="sd">    |              |       | 1)                                                |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |</span>
<span class="sd">    |              |       | x 1)                                              |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |</span>
<span class="sd">    |              |       | solution (nx x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |</span>
<span class="sd">    |              |       | solution (ng x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>
<span class="sd">    | NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |</span>
<span class="sd">    |              |       | solution (np x 1)                                 |</span>
<span class="sd">    +--------------+-------+---------------------------------------------------+</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Number of NLP solver inputs.</span>

<span class="sd">    nlpsol_n_in() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Number of NLP solver outputs.</span>

<span class="sd">    nlpsol_n_out() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_default_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Default input for an NLP solver.</span>

<span class="sd">    nlpsol_default_in() -&gt; [float]</span>
<span class="sd">    nlpsol_default_in(int ind) -&gt; float</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_default_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string,std::allocator&lt; std::string &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all options for a plugin.</span>

<span class="sd">    nlpsol_options(str name) -&gt; [str]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_option_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get type info for a particular option.</span>

<span class="sd">    nlpsol_option_type(str name, str op) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_option_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nlpsol_option_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get documentation for a particular option.</span>

<span class="sd">    nlpsol_option_info(str name, str op) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nlpsol_option_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_nlpsol(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_nlpsol(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_nlpsol(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_nlpsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">      rootfinder(str name, str solver, dict:SX rfp, dict opts) -&gt; Function</span>
<span class="sd">      rootfinder(str name, str solver, dict:MX rfp, dict opts) -&gt; Function</span>
<span class="sd">      rootfinder(str name, str solver, Function f, dict opts) -&gt; Function</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      rootfinder(str name, str solver, dict:SX rfp, dict opts)</span>



<span class="sd">    Create a solver for rootfinding problems Takes a function where one of the</span>
<span class="sd">    inputs is unknown and one of the outputs is a residual function that is</span>
<span class="sd">    always zero, defines a new function where the the unknown input has been</span>
<span class="sd">    replaced by a guess for the unknown and the residual output has been</span>
<span class="sd">    replaced by the calculated value for the input.</span>

<span class="sd">    For a function [y0, y1, ...,yi, .., yn] = F(x0, x1, ..., xj, ..., xm), where</span>
<span class="sd">    xj is unknown and yi=0, defines a new function [y0, y1, ...,xj, .., yn] =</span>
<span class="sd">    G(x0, x1, ..., xj_guess, ..., xm),</span>

<span class="sd">    xj and yi must have the same dimension and d(yi)/d(xj) must be invertable.</span>

<span class="sd">    By default, the first input is unknown and the first output is the residual.</span>

<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | common_options   | OT_DICT         | Options for      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | auto-generated   | nction           |</span>
<span class="sd">    |                  |                 | functions        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | constraints      | OT_INTVECTOR    | Constrain the    | casadi::Rootfind |</span>
<span class="sd">    |                  |                 | unknowns. 0      | er               |</span>
<span class="sd">    |                  |                 | (default): no    |                  |</span>
<span class="sd">    |                  |                 | constraint on    |                  |</span>
<span class="sd">    |                  |                 | ui, 1: ui &gt;=     |                  |</span>
<span class="sd">    |                  |                 | 0.0, -1: ui &lt;=   |                  |</span>
<span class="sd">    |                  |                 | 0.0, 2: ui &gt;     |                  |</span>
<span class="sd">    |                  |                 | 0.0, -2: ui &lt;    |                  |</span>
<span class="sd">    |                  |                 | 0.0.             |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | error_on_fail    | OT_BOOL         | When the         | casadi::Rootfind |</span>
<span class="sd">    |                  |                 | numerical        | er               |</span>
<span class="sd">    |                  |                 | process returns  |                  |</span>
<span class="sd">    |                  |                 | unsuccessfully,  |                  |</span>
<span class="sd">    |                  |                 | raise an error   |                  |</span>
<span class="sd">    |                  |                 | (default false). |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | expand           | OT_BOOL         | Replace MX with  | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | SX expressions   | nction           |</span>
<span class="sd">    |                  |                 | in problem       |                  |</span>
<span class="sd">    |                  |                 | formulation      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | implicit_input   | OT_INT          | Index of the     | casadi::Rootfind |</span>
<span class="sd">    |                  |                 | input that       | er               |</span>
<span class="sd">    |                  |                 | corresponds to   |                  |</span>
<span class="sd">    |                  |                 | the actual root- |                  |</span>
<span class="sd">    |                  |                 | finding          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | implicit_output  | OT_INT          | Index of the     | casadi::Rootfind |</span>
<span class="sd">    |                  |                 | output that      | er               |</span>
<span class="sd">    |                  |                 | corresponds to   |                  |</span>
<span class="sd">    |                  |                 | the actual root- |                  |</span>
<span class="sd">    |                  |                 | finding          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jacobian_functio | OT_FUNCTION     | Function object  | casadi::Rootfind |</span>
<span class="sd">    | n                |                 | for calculating  | er               |</span>
<span class="sd">    |                  |                 | the Jacobian     |                  |</span>
<span class="sd">    |                  |                 | (autogenerated   |                  |</span>
<span class="sd">    |                  |                 | by default)      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | linear_solver    | OT_STRING       | User-defined     | casadi::Rootfind |</span>
<span class="sd">    |                  |                 | linear solver    | er               |</span>
<span class="sd">    |                  |                 | class. Needed    |                  |</span>
<span class="sd">    |                  |                 | for              |                  |</span>
<span class="sd">    |                  |                 | sensitivities.   |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | linear_solver_op | OT_DICT         | Options to be    | casadi::Rootfind |</span>
<span class="sd">    | tions            |                 | passed to the    | er               |</span>
<span class="sd">    |                  |                 | linear solver.   |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | problem          | nction           |</span>
<span class="sd">    |                  |                 | functions to be  |                  |</span>
<span class="sd">    |                  |                 | monitored        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | show_eval_warnin | OT_BOOL         | Show warnings    | casadi::OracleFu |</span>
<span class="sd">    | gs               |                 | generated from   | nction           |</span>
<span class="sd">    |                  |                 | function         |                  |</span>
<span class="sd">    |                  |                 | evaluations      |                  |</span>
<span class="sd">    |                  |                 | [true]           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | specific_options | OT_DICT         | Options for      | casadi::OracleFu |</span>
<span class="sd">    |                  |                 | specific auto-   | nction           |</span>
<span class="sd">    |                  |                 | generated        |                  |</span>
<span class="sd">    |                  |                 | functions,       |                  |</span>
<span class="sd">    |                  |                 | overwriting the  |                  |</span>
<span class="sd">    |                  |                 | defaults from    |                  |</span>
<span class="sd">    |                  |                 | common_options.  |                  |</span>
<span class="sd">    |                  |                 | Nested           |                  |</span>
<span class="sd">    |                  |                 | dictionary.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    &gt;Input scheme: casadi::RootfinderInput (ROOTFINDER_NUM_IN = 2)</span>

<span class="sd">    +---------------+-------+---------------------------------+</span>
<span class="sd">    |   Full name   | Short |           Description           |</span>
<span class="sd">    +===============+=======+=================================+</span>
<span class="sd">    | ROOTFINDER_X0 | x0    | Initial guess for the solution. |</span>
<span class="sd">    +---------------+-------+---------------------------------+</span>
<span class="sd">    | ROOTFINDER_P  | p     | Parameters.                     |</span>
<span class="sd">    +---------------+-------+---------------------------------+</span>

<span class="sd">    &gt;Output scheme: casadi::RootfinderOutput (ROOTFINDER_NUM_OUT = 1)</span>

<span class="sd">    +--------------+-------+--------------------------------------+</span>
<span class="sd">    |  Full name   | Short |             Description              |</span>
<span class="sd">    +==============+=======+======================================+</span>
<span class="sd">    | ROOTFINDER_X | x     | Solution to the system of equations. |</span>
<span class="sd">    +--------------+-------+--------------------------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - kinsol</span>

<span class="sd">    - fast_newton</span>

<span class="sd">    - nlpsol</span>

<span class="sd">    - newton</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Rootfinder.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    kinsol</span>
<span class="sd">    ------</span>



<span class="sd">    KINSOL interface from the Sundials suite</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    |            Id             |      Type       |        Description         |</span>
<span class="sd">    +===========================+=================+============================+</span>
<span class="sd">    | abstol                    | OT_DOUBLE       | Stopping criterion         |</span>
<span class="sd">    |                           |                 | tolerance                  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | disable_internal_warnings | OT_BOOL         | Disable KINSOL internal    |</span>
<span class="sd">    |                           |                 | warning messages           |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | exact_jacobian            | OT_BOOL         | Use exact Jacobian         |</span>
<span class="sd">    |                           |                 | information                |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | f_scale                   | OT_DOUBLEVECTOR | Equation scaling factors   |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | iterative_solver          | OT_STRING       | gmres|bcgstab|tfqmr        |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | linear_solver_type        | OT_STRING       | dense|banded|iterative|use |</span>
<span class="sd">    |                           |                 | r_defined                  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | lower_bandwidth           | OT_INT          | Lower bandwidth for banded |</span>
<span class="sd">    |                           |                 | linear solvers             |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_iter                  | OT_INT          | Maximum number of Newton   |</span>
<span class="sd">    |                           |                 | iterations. Putting 0 sets |</span>
<span class="sd">    |                           |                 | the default value of       |</span>
<span class="sd">    |                           |                 | KinSol.                    |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | max_krylov                | OT_INT          | Maximum Krylov space       |</span>
<span class="sd">    |                           |                 | dimension                  |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | pretype                   | OT_STRING       | Type of preconditioner     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | strategy                  | OT_STRING       | Globalization strategy     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | u_scale                   | OT_DOUBLEVECTOR | Variable scaling factors   |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | upper_bandwidth           | OT_INT          | Upper bandwidth for banded |</span>
<span class="sd">    |                           |                 | linear solvers             |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>
<span class="sd">    | use_preconditioner        | OT_BOOL         | Precondition an iterative  |</span>
<span class="sd">    |                           |                 | solver                     |</span>
<span class="sd">    +---------------------------+-----------------+----------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    fast_newton</span>
<span class="sd">    -----------</span>



<span class="sd">    Implements simple newton iterations to solve an implicit function.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------+-----------+-------------------------------------------------+</span>
<span class="sd">    |     Id     |   Type    |                   Description                   |</span>
<span class="sd">    +============+===========+=================================================+</span>
<span class="sd">    | abstol     | OT_DOUBLE | Stopping criterion tolerance on ||g||__inf)     |</span>
<span class="sd">    +------------+-----------+-------------------------------------------------+</span>
<span class="sd">    | abstolStep | OT_DOUBLE | Stopping criterion tolerance on step size       |</span>
<span class="sd">    +------------+-----------+-------------------------------------------------+</span>
<span class="sd">    | max_iter   | OT_INT    | Maximum number of Newton iterations to perform  |</span>
<span class="sd">    |            |           | before returning.                               |</span>
<span class="sd">    +------------+-----------+-------------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    nlpsol</span>
<span class="sd">    ------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    newton</span>
<span class="sd">    ------</span>



<span class="sd">    Implements simple newton iterations to solve an implicit function.</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    |       Id        |   Type    |                Description                 |</span>
<span class="sd">    +=================+===========+============================================+</span>
<span class="sd">    | abstol          | OT_DOUBLE | Stopping criterion tolerance on max(|F|)   |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | abstolStep      | OT_DOUBLE | Stopping criterion tolerance on step size  |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | line_search     | OT_BOOL   | Enable line-search (default: true)         |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | max_iter        | OT_INT    | Maximum number of Newton iterations to     |</span>
<span class="sd">    |                 |           | perform before returning.                  |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>
<span class="sd">    | print_iteration | OT_BOOL   | Print information about each iteration     |</span>
<span class="sd">    +-----------------+-----------+--------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joel Andersson</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      rootfinder(str name, str solver, dict:MX rfp, dict opts)</span>
<span class="sd">      rootfinder(str name, str solver, Function f, dict opts)</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get rootfinder input scheme name by index.</span>

<span class="sd">      rootfinder_in() -&gt; [str]</span>
<span class="sd">      rootfinder_in(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      rootfinder_in(int ind)</span>



<span class="sd">    Get rootfinder input scheme name by index.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      rootfinder_in()</span>



<span class="sd">    Get rootfinder input scheme.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get rootfinder output scheme name by index.</span>

<span class="sd">      rootfinder_out() -&gt; [str]</span>
<span class="sd">      rootfinder_out(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      rootfinder_out(int ind)</span>



<span class="sd">    Get rootfinder output scheme name by index.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      rootfinder_out()</span>



<span class="sd">    Get rootfinder output scheme.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Number of rootfinder inputs.</span>

<span class="sd">    rootfinder_n_in() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Number of rootfinder outputs.</span>

<span class="sd">    rootfinder_n_out() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string,std::allocator&lt; std::string &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all options for a plugin.</span>

<span class="sd">    rootfinder_options(str name) -&gt; [str]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_option_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get type info for a particular option.</span>

<span class="sd">    rootfinder_option_type(str name, str op) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_option_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rootfinder_option_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get documentation for a particular option.</span>

<span class="sd">    rootfinder_option_info(str name, str op) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rootfinder_option_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_rootfinder(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_rootfinder(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_rootfinder(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_rootfinder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Linsol</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Linear solver Create a solver for linear systems of equations Solves the</span>


<span class="sd">    linear system A*X = B or A^T*X = B for X with A square and non- singular.</span>

<span class="sd">    If A is structurally singular, an error will be thrown during init. If A is</span>
<span class="sd">    numerically singular, the prepare step will fail.</span>

<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - csparsecholesky</span>

<span class="sd">    - csparse</span>

<span class="sd">    - ma27</span>

<span class="sd">    - lapacklu</span>

<span class="sd">    - lapackqr</span>

<span class="sd">    - mumps</span>

<span class="sd">    - ldl</span>

<span class="sd">    - qr</span>

<span class="sd">    - tridiag</span>

<span class="sd">    - symbolicqr</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Linsol.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    csparsecholesky</span>
<span class="sd">    ---------------</span>



<span class="sd">    Linsol with CSparseCholesky Interface</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    csparse</span>
<span class="sd">    -------</span>



<span class="sd">    Linsol with CSparse Interface</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    ma27</span>
<span class="sd">    ----</span>



<span class="sd">    Interface to the sparse direct linear solver MA27 Works for symmetric</span>
<span class="sd">    indefinite systems Partly adopted from qpOASES 3.2 Joel Andersson</span>

<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    lapacklu</span>
<span class="sd">    --------</span>



<span class="sd">    This class solves the linear system A.x=b by making an LU factorization of</span>
<span class="sd">    A: A = L.U, with L lower and U upper triangular</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------------------+---------+----------------------------------+</span>
<span class="sd">    |             Id              |  Type   |           Description            |</span>
<span class="sd">    +=============================+=========+==================================+</span>
<span class="sd">    | allow_equilibration_failure | OT_BOOL | Non-fatal error when             |</span>
<span class="sd">    |                             |         | equilibration fails              |</span>
<span class="sd">    +-----------------------------+---------+----------------------------------+</span>
<span class="sd">    | equilibration               | OT_BOOL | Equilibrate the matrix           |</span>
<span class="sd">    +-----------------------------+---------+----------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    lapackqr</span>
<span class="sd">    --------</span>



<span class="sd">    This class solves the linear system A.x=b by making an QR factorization of</span>
<span class="sd">    A: A = Q.R, with Q orthogonal and R upper triangular</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------+--------+------------------------------------------------------+</span>
<span class="sd">    |    Id    |  Type  |                     Description                      |</span>
<span class="sd">    +==========+========+======================================================+</span>
<span class="sd">    | max_nrhs | OT_INT | Maximum number of right-hand-sides that get          |</span>
<span class="sd">    |          |        | processed in a single pass [default:10].             |</span>
<span class="sd">    +----------+--------+------------------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    mumps</span>
<span class="sd">    -----</span>



<span class="sd">    Interface to the sparse direct linear solver MUMPS Works for symmetric</span>
<span class="sd">    indefinite systems Joel Andersson</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------+---------+-------------------+</span>
<span class="sd">    |    Id     |  Type   |    Description    |</span>
<span class="sd">    +===========+=========+===================+</span>
<span class="sd">    | posdef    | OT_BOOL | Positive definite |</span>
<span class="sd">    +-----------+---------+-------------------+</span>
<span class="sd">    | symmetric | OT_BOOL | Symmetric matrix  |</span>
<span class="sd">    +-----------+---------+-------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    ldl</span>
<span class="sd">    ---</span>



<span class="sd">    Linear solver using sparse direct LDL factorization</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    qr --</span>



<span class="sd">    Linear solver using sparse direct QR factorization</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    tridiag</span>
<span class="sd">    -------</span>



<span class="sd">    Linear solver for tridiagonal matrices</span>

<span class="sd">    --------------------------------------------------------------------------------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    symbolicqr</span>
<span class="sd">    ----------</span>



<span class="sd">    Linear solver for sparse least-squares problems Inspired</span>
<span class="sd">    fromhttps://github.com/scipy/scipy/blob/v0.14.0/scipy/sparse/linalg/isolve/lsqr.py#L96</span>

<span class="sd">    Linsol based on QR factorization with sparsity pattern based reordering</span>
<span class="sd">    without partial pivoting</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------+---------+----------------------------------------------------+</span>
<span class="sd">    |  Id   |  Type   |                    Description                     |</span>
<span class="sd">    +=======+=========+====================================================+</span>
<span class="sd">    | fopts | OT_DICT | Options to be passed to generated function objects |</span>
<span class="sd">    +-------+---------+----------------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: linsol.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Linsol</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Linsol</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_plugin(str name) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">has_plugin</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">has_plugin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        load_plugin(str name)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">load_plugin</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">load_plugin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        doc(str name) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">doc</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plugin_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query plugin name.</span>

<span class="sd">        plugin_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_plugin_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity const &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get linear system sparsity.</span>

<span class="sd">        sparsity(self) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sfact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Symbolic factorization of the linear system, e.g. selecting pivots.</span>

<span class="sd">        sfact(self, DM A)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_sfact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nfact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numeric factorization of the linear system.</span>

<span class="sd">        nfact(self, DM A)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_nfact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve linear system of equations</span>

<span class="sd">        solve(self, DM A, DM B, bool tr) -&gt; DM</span>
<span class="sd">        solve(self, MX A, MX B, bool tr) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">neig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of negative eigenvalues Not available for all solvers.</span>

<span class="sd">        neig(self, DM A) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_neig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix rank Not available for all solvers.</span>

<span class="sd">        rank(self, DM A) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all statistics obtained at the end of the last evaluate call.</span>

<span class="sd">        stats(self, int mem) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          Linsol()</span>
<span class="sd">          Linsol(Linsol other)</span>
<span class="sd">          Linsol(str name, str solver, Sparsity sp, dict opts)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Linsol(Linsol other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Linsol()</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Linsol(str name, str solver, Sparsity sp, dict opts)</span>



<span class="sd">        Constructor.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Linsol</span>
<span class="n">Linsol_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_swigregister</span>
<span class="n">Linsol_swigregister</span><span class="p">(</span><span class="n">Linsol</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Linsol_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Linsol_has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    has_plugin(str name) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Linsol_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    load_plugin(str name)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Linsol_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    doc(str name) -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Linsol_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">has_linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_linsol(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_linsol(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_linsol(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_linsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dplesol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DMVector&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">      dplesol([DM] A, [DM] V, str solver, dict opts) -&gt; [DM]</span>
<span class="sd">      dplesol(MX A, MX V, str solver, dict opts) -&gt; MX</span>
<span class="sd">      dplesol([MX] A, [MX] V, str solver, dict opts) -&gt; [MX]</span>
<span class="sd">      dplesol(str name, str solver, dict:Sparsity st, dict opts) -&gt; Function</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      dplesol([DM] A, [DM] V, str solver, dict opts)</span>
<span class="sd">      dplesol(MX A, MX V, str solver, dict opts)</span>
<span class="sd">      dplesol([MX] A, [MX] V, str solver, dict opts)</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      dplesol(str name, str solver, dict:Sparsity st, dict opts)</span>



<span class="sd">    Discrete periodic Lyapunov Equation solver Given matrices $A_k$ and</span>
<span class="sd">    symmetric $V_k, k = 0..K-1$</span>

<span class="sd">    ::</span>

<span class="sd">      A_k in R^(n x n)</span>
<span class="sd">      V_k in R^n</span>


<span class="sd">    provides all of $P_k$ that satisfy:</span>

<span class="sd">    ::</span>

<span class="sd">      P_0 = A_(K-1)*P_(K-1)*A_(K-1)&#39; + V_k</span>
<span class="sd">      P_k+1 = A_k*P_k*A_k&#39; + V_k  for k = 1..K-1</span>




<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for derivative   | Internal         |</span>
<span class="sd">    |                  |                 | calculation.When |                  |</span>
<span class="sd">    |                  |                 | there is an      |                  |</span>
<span class="sd">    |                  |                 | option of either |                  |</span>
<span class="sd">    |                  |                 | using forward or |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | directional      |                  |</span>
<span class="sd">    |                  |                 | derivatives, the |                  |</span>
<span class="sd">    |                  |                 | condition ad_wei |                  |</span>
<span class="sd">    |                  |                 | ght*nf&lt;=(1-ad_we |                  |</span>
<span class="sd">    |                  |                 | ight)*na is used |                  |</span>
<span class="sd">    |                  |                 | where nf and na  |                  |</span>
<span class="sd">    |                  |                 | are estimates of |                  |</span>
<span class="sd">    |                  |                 | the number of    |                  |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | mode directional |                  |</span>
<span class="sd">    |                  |                 | derivatives      |                  |</span>
<span class="sd">    |                  |                 | needed. By       |                  |</span>
<span class="sd">    |                  |                 | default,         |                  |</span>
<span class="sd">    |                  |                 | ad_weight is     |                  |</span>
<span class="sd">    |                  |                 | calculated       |                  |</span>
<span class="sd">    |                  |                 | automatically,   |                  |</span>
<span class="sd">    |                  |                 | but this can be  |                  |</span>
<span class="sd">    |                  |                 | overridden by    |                  |</span>
<span class="sd">    |                  |                 | setting this     |                  |</span>
<span class="sd">    |                  |                 | option. In       |                  |</span>
<span class="sd">    |                  |                 | particular, 0    |                  |</span>
<span class="sd">    |                  |                 | means forcing    |                  |</span>
<span class="sd">    |                  |                 | forward mode and |                  |</span>
<span class="sd">    |                  |                 | 1 forcing        |                  |</span>
<span class="sd">    |                  |                 | reverse mode.    |                  |</span>
<span class="sd">    |                  |                 | Leave unset for  |                  |</span>
<span class="sd">    |                  |                 | (class specific) |                  |</span>
<span class="sd">    |                  |                 | heuristics.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for sparsity     | Internal         |</span>
<span class="sd">    |                  |                 | pattern          |                  |</span>
<span class="sd">    |                  |                 | calculation calc |                  |</span>
<span class="sd">    |                  |                 | ulation.Override |                  |</span>
<span class="sd">    |                  |                 | s default        |                  |</span>
<span class="sd">    |                  |                 | behavior. Set to |                  |</span>
<span class="sd">    |                  |                 | 0 and 1 to force |                  |</span>
<span class="sd">    |                  |                 | forward and      |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | respectively.    |                  |</span>
<span class="sd">    |                  |                 | Cf. option       |                  |</span>
<span class="sd">    |                  |                 | &quot;ad_weight&quot;.     |                  |</span>
<span class="sd">    |                  |                 | When set to -1,  |                  |</span>
<span class="sd">    |                  |                 | sparsity is      |                  |</span>
<span class="sd">    |                  |                 | completely       |                  |</span>
<span class="sd">    |                  |                 | ignored and      |                  |</span>
<span class="sd">    |                  |                 | dense matrices   |                  |</span>
<span class="sd">    |                  |                 | are used.        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler plugin  | Internal         |</span>
<span class="sd">    |                  |                 | to be used.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | const_dim        | OT_BOOL         | Assume constant  | casadi::Dple     |</span>
<span class="sd">    |                  |                 | dimension of P   |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |</span>
<span class="sd">    |                  |                 | CasADi&#39;s AD. Use | Internal         |</span>
<span class="sd">    |                  |                 | together with    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;:   |                  |</span>
<span class="sd">    |                  |                 | 0. Note: Highly  |                  |</span>
<span class="sd">    |                  |                 | experimental.    |                  |</span>
<span class="sd">    |                  |                 | Syntax may break |                  |</span>
<span class="sd">    |                  |                 | often.           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |</span>
<span class="sd">    |                  |                 | a derivative of  | Internal         |</span>
<span class="sd">    |                  |                 | another          |                  |</span>
<span class="sd">    |                  |                 | function. The    |                  |</span>
<span class="sd">    |                  |                 | type of          |                  |</span>
<span class="sd">    |                  |                 | derivative       |                  |</span>
<span class="sd">    |                  |                 | (directional     |                  |</span>
<span class="sd">    |                  |                 | derivative,      |                  |</span>
<span class="sd">    |                  |                 | Jacobian) is     |                  |</span>
<span class="sd">    |                  |                 | inferred from    |                  |</span>
<span class="sd">    |                  |                 | the function     |                  |</span>
<span class="sd">    |                  |                 | name.            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump             | OT_BOOL         | Dump function to | casadi::Function |</span>
<span class="sd">    |                  |                 | file upon first  | Internal         |</span>
<span class="sd">    |                  |                 | evaluation.      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_dir         | OT_STRING       | Directory to     | casadi::Function |</span>
<span class="sd">    |                  |                 | dump             | Internal         |</span>
<span class="sd">    |                  |                 | inputs/outputs   |                  |</span>
<span class="sd">    |                  |                 | to. Make sure    |                  |</span>
<span class="sd">    |                  |                 | the directory    |                  |</span>
<span class="sd">    |                  |                 | exists [.]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_format      | OT_STRING       | Choose file      | casadi::Function |</span>
<span class="sd">    |                  |                 | format to dump   | Internal         |</span>
<span class="sd">    |                  |                 | matrices. See    |                  |</span>
<span class="sd">    |                  |                 | DM.from_file     |                  |</span>
<span class="sd">    |                  |                 | [mtx]            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | to file          |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs to file  |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_fd        | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation by   |                  |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | differencing.    |                  |</span>
<span class="sd">    |                  |                 | [default:        |                  |</span>
<span class="sd">    |                  |                 | false]]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_forward   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using forward    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobians of all |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | outputs with     |                  |</span>
<span class="sd">    |                  |                 | respect to all   |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | inputs - if      |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_reverse   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | transposed       |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using reverse    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | eps_unstable     | OT_DOUBLE       | A margin for     | casadi::Dple     |</span>
<span class="sd">    |                  |                 | unstability      |                  |</span>
<span class="sd">    |                  |                 | detection        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | error_unstable   | OT_BOOL         | Throw an         | casadi::Dple     |</span>
<span class="sd">    |                  |                 | exception when   |                  |</span>
<span class="sd">    |                  |                 | it is detected   |                  |</span>
<span class="sd">    |                  |                 | that             |                  |</span>
<span class="sd">    |                  |                 | Product(A_i,     |                  |</span>
<span class="sd">    |                  |                 | i=N..1)has       |                  |</span>
<span class="sd">    |                  |                 | eigenvalues      |                  |</span>
<span class="sd">    |                  |                 | greater than     |                  |</span>
<span class="sd">    |                  |                 | 1-eps_unstable   |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_method        | OT_STRING       | Method for       | casadi::Function |</span>
<span class="sd">    |                  |                 | finite           | Internal         |</span>
<span class="sd">    |                  |                 | differencing     |                  |</span>
<span class="sd">    |                  |                 | [default         |                  |</span>
<span class="sd">    |                  |                 | &#39;central&#39;]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_options       | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | difference       |                  |</span>
<span class="sd">    |                  |                 | instance         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | forward_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | forward mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option           | Internal         |</span>
<span class="sd">    |                  |                 | (ignored):       |                  |</span>
<span class="sd">    |                  |                 | Statistics are   |                  |</span>
<span class="sd">    |                  |                 | now always       |                  |</span>
<span class="sd">    |                  |                 | collected.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when the         | Internal         |</span>
<span class="sd">    |                  |                 | numerical values |                  |</span>
<span class="sd">    |                  |                 | of the inputs    |                  |</span>
<span class="sd">    |                  |                 | don&#39;t make sense |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each input if it | Internal         |</span>
<span class="sd">    |                  |                 | should be        |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each output if   | Internal         |</span>
<span class="sd">    |                  |                 | it should be     |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |</span>
<span class="sd">    |                  |                 | for a number of  | Internal         |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | directions, it   |                  |</span>
<span class="sd">    |                  |                 | may be cheaper   |                  |</span>
<span class="sd">    |                  |                 | to compute first |                  |</span>
<span class="sd">    |                  |                 | the full         |                  |</span>
<span class="sd">    |                  |                 | jacobian and     |                  |</span>
<span class="sd">    |                  |                 | then multiply    |                  |</span>
<span class="sd">    |                  |                 | with seeds,      |                  |</span>
<span class="sd">    |                  |                 | rather than      |                  |</span>
<span class="sd">    |                  |                 | obtain the       |                  |</span>
<span class="sd">    |                  |                 | requested        |                  |</span>
<span class="sd">    |                  |                 | directions in a  |                  |</span>
<span class="sd">    |                  |                 | straightforward  |                  |</span>
<span class="sd">    |                  |                 | manner. Casadi   |                  |</span>
<span class="sd">    |                  |                 | uses a heuristic |                  |</span>
<span class="sd">    |                  |                 | to decide which  |                  |</span>
<span class="sd">    |                  |                 | is cheaper. A    |                  |</span>
<span class="sd">    |                  |                 | high value of    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;    |                  |</span>
<span class="sd">    |                  |                 | makes it less    |                  |</span>
<span class="sd">    |                  |                 | likely for the   |                  |</span>
<span class="sd">    |                  |                 | heurstic to      |                  |</span>
<span class="sd">    |                  |                 | chose the full   |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy. The    |                  |</span>
<span class="sd">    |                  |                 | special value -1 |                  |</span>
<span class="sd">    |                  |                 | indicates never  |                  |</span>
<span class="sd">    |                  |                 | to use the full  |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler to      | Internal         |</span>
<span class="sd">    |                  |                 | speed up the     |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |</span>
<span class="sd">    |                  |                 | temporary source | Internal         |</span>
<span class="sd">    |                  |                 | file that jit    |                  |</span>
<span class="sd">    |                  |                 | creates.         |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_name         | OT_STRING       | The file name    | casadi::Function |</span>
<span class="sd">    |                  |                 | used to write    | Internal         |</span>
<span class="sd">    |                  |                 | out code. The    |                  |</span>
<span class="sd">    |                  |                 | actual file      |                  |</span>
<span class="sd">    |                  |                 | names used       |                  |</span>
<span class="sd">    |                  |                 | depend on &#39;jit_t |                  |</span>
<span class="sd">    |                  |                 | emp_suffix&#39; and  |                  |</span>
<span class="sd">    |                  |                 | include          |                  |</span>
<span class="sd">    |                  |                 | extensions.      |                  |</span>
<span class="sd">    |                  |                 | Default:         |                  |</span>
<span class="sd">    |                  |                 | &#39;jit_tmp&#39;        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_options      | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | jit compiler.    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_serialize    | OT_STRING       | Specify          | casadi::Function |</span>
<span class="sd">    |                  |                 | behaviour when   | Internal         |</span>
<span class="sd">    |                  |                 | serializing a    |                  |</span>
<span class="sd">    |                  |                 | jitted function: |                  |</span>
<span class="sd">    |                  |                 | SOURCE|link|embe |                  |</span>
<span class="sd">    |                  |                 | d.               |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |</span>
<span class="sd">    |                  |                 | (seemingly       | Internal         |</span>
<span class="sd">    |                  |                 | random) filename |                  |</span>
<span class="sd">    |                  |                 | suffix for       |                  |</span>
<span class="sd">    |                  |                 | generated code   |                  |</span>
<span class="sd">    |                  |                 | and libraries.   |                  |</span>
<span class="sd">    |                  |                 | This is desired  |                  |</span>
<span class="sd">    |                  |                 | for thread-      |                  |</span>
<span class="sd">    |                  |                 | safety. This     |                  |</span>
<span class="sd">    |                  |                 | behaviour may    |                  |</span>
<span class="sd">    |                  |                 | defeat caching   |                  |</span>
<span class="sd">    |                  |                 | compiler         |                  |</span>
<span class="sd">    |                  |                 | wrappers.        |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |</span>
<span class="sd">    |                  |                 | maximum number   | Internal         |</span>
<span class="sd">    |                  |                 | of directions    |                  |</span>
<span class="sd">    |                  |                 | for derivative   |                  |</span>
<span class="sd">    |                  |                 | functions.       |                  |</span>
<span class="sd">    |                  |                 | Overrules the    |                  |</span>
<span class="sd">    |                  |                 | builtin optimize |                  |</span>
<span class="sd">    |                  |                 | d_num_dir.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | pos_def          | OT_BOOL         | Assume P         | casadi::Dple     |</span>
<span class="sd">    |                  |                 | positive         |                  |</span>
<span class="sd">    |                  |                 | definite         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_in         | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_out        | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs          |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_time       | OT_BOOL         | print            | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time. Implies    |                  |</span>
<span class="sd">    |                  |                 | record_time.     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | record_time      | OT_BOOL         | record           | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time, for        |                  |</span>
<span class="sd">    |                  |                 | retrieval with   |                  |</span>
<span class="sd">    |                  |                 | stats().         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when NaN or Inf  | Internal         |</span>
<span class="sd">    |                  |                 | appears during   |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | reverse_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |</span>
<span class="sd">    |                  |                 | field that can   | Internal         |</span>
<span class="sd">    |                  |                 | be used to       |                  |</span>
<span class="sd">    |                  |                 | identify the     |                  |</span>
<span class="sd">    |                  |                 | function or pass |                  |</span>
<span class="sd">    |                  |                 | additional       |                  |</span>
<span class="sd">    |                  |                 | information      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | verbose          | OT_BOOL         | Verbose          | casadi::Function |</span>
<span class="sd">    |                  |                 | evaluation  for  | Internal         |</span>
<span class="sd">    |                  |                 | debugging        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    &gt;Input scheme: casadi::DpleInput (DPLE_NUM_IN = 2)</span>

<span class="sd">    +-----------+-------+------------------------------------------------------+</span>
<span class="sd">    | Full name | Short |                     Description                      |</span>
<span class="sd">    +===========+=======+======================================================+</span>
<span class="sd">    | DPLE_A    | a     | A matrices (horzcat when const_dim, diagcat          |</span>
<span class="sd">    |           |       | otherwise) [a].                                      |</span>
<span class="sd">    +-----------+-------+------------------------------------------------------+</span>
<span class="sd">    | DPLE_V    | v     | V matrices (horzcat when const_dim, diagcat          |</span>
<span class="sd">    |           |       | otherwise) [v].                                      |</span>
<span class="sd">    +-----------+-------+------------------------------------------------------+</span>

<span class="sd">    &gt;Output scheme: casadi::DpleOutput (DPLE_NUM_OUT = 1)</span>

<span class="sd">    +-----------+-------+------------------------------------------------------+</span>
<span class="sd">    | Full name | Short |                     Description                      |</span>
<span class="sd">    +===========+=======+======================================================+</span>
<span class="sd">    | DPLE_P    | p     | Lyapunov matrix (horzcat when const_dim, diagcat     |</span>
<span class="sd">    |           |       | otherwise) (Cholesky of P if pos_def) [p].           |</span>
<span class="sd">    +-----------+-------+------------------------------------------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - slicot</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Dple.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    slicot</span>
<span class="sd">    ------</span>



<span class="sd">    An efficient solver for Discrete Periodic Lyapunov Equations using SLICOT</span>

<span class="sd">    Uses Periodic Schur Decomposition (&#39;psd&#39;) and does not assume positive</span>
<span class="sd">    definiteness. Based on Periodic Lyapunov equations: some applications and</span>
<span class="sd">    new algorithms. Int. J. Control, vol. 67, pp. 69-87, 1997.</span>

<span class="sd">    Overview of the method: J. Gillis Practical Methods for Approximate Robust</span>
<span class="sd">    Periodic Optimal Control ofNonlinear Mechanical Systems, PhD Thesis,</span>
<span class="sd">    KULeuven, 2015</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------------+-----------+--------------------------------------+</span>
<span class="sd">    |          Id           |   Type    |             Description              |</span>
<span class="sd">    +=======================+===========+======================================+</span>
<span class="sd">    | linear_solver         | OT_STRING | User-defined linear solver class.    |</span>
<span class="sd">    |                       |           | Needed for sensitivities.            |</span>
<span class="sd">    +-----------------------+-----------+--------------------------------------+</span>
<span class="sd">    | linear_solver_options | OT_DICT   | Options to be passed to the linear   |</span>
<span class="sd">    |                       |           | solver.                              |</span>
<span class="sd">    +-----------------------+-----------+--------------------------------------+</span>
<span class="sd">    | psd_num_zero          | OT_DOUBLE | Numerical zero used in Periodic      |</span>
<span class="sd">    |                       |           | Schur decomposition with slicot.This |</span>
<span class="sd">    |                       |           | option is needed when your systems   |</span>
<span class="sd">    |                       |           | has Floquet multiplierszero or close |</span>
<span class="sd">    |                       |           | to zero                              |</span>
<span class="sd">    +-----------------------+-----------+--------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joris Gillis</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">dplesol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dple_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get DPLE input scheme name by index.</span>

<span class="sd">      dple_in() -&gt; [str]</span>
<span class="sd">      dple_in(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      dple_in()</span>



<span class="sd">    Get input scheme of DPLE solvers.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      dple_in(int ind)</span>



<span class="sd">    Get DPLE input scheme name by index.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">dple_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dple_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get DPLE output scheme name by index.</span>

<span class="sd">      dple_out() -&gt; [str]</span>
<span class="sd">      dple_out(int ind) -&gt; str</span>




<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      dple_out()</span>



<span class="sd">    Get output scheme of DPLE solvers.</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      dple_out(int ind)</span>



<span class="sd">    Get DPLE output scheme name by index.</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">dple_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dple_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of QP solver inputs.</span>

<span class="sd">    dple_n_in() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">dple_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dple_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of QP solver outputs.</span>

<span class="sd">    dple_n_out() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">dple_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_dple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_dple(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_dple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_dple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_dple(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_dple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_dple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_dple(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_dple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">expmsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Performs a matrix exponentiation expm(A)</span>

<span class="sd">      expmsol(str name, str solver, Sparsity A, dict opts) -&gt; Function</span>


<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for derivative   | Internal         |</span>
<span class="sd">    |                  |                 | calculation.When |                  |</span>
<span class="sd">    |                  |                 | there is an      |                  |</span>
<span class="sd">    |                  |                 | option of either |                  |</span>
<span class="sd">    |                  |                 | using forward or |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | directional      |                  |</span>
<span class="sd">    |                  |                 | derivatives, the |                  |</span>
<span class="sd">    |                  |                 | condition ad_wei |                  |</span>
<span class="sd">    |                  |                 | ght*nf&lt;=(1-ad_we |                  |</span>
<span class="sd">    |                  |                 | ight)*na is used |                  |</span>
<span class="sd">    |                  |                 | where nf and na  |                  |</span>
<span class="sd">    |                  |                 | are estimates of |                  |</span>
<span class="sd">    |                  |                 | the number of    |                  |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | mode directional |                  |</span>
<span class="sd">    |                  |                 | derivatives      |                  |</span>
<span class="sd">    |                  |                 | needed. By       |                  |</span>
<span class="sd">    |                  |                 | default,         |                  |</span>
<span class="sd">    |                  |                 | ad_weight is     |                  |</span>
<span class="sd">    |                  |                 | calculated       |                  |</span>
<span class="sd">    |                  |                 | automatically,   |                  |</span>
<span class="sd">    |                  |                 | but this can be  |                  |</span>
<span class="sd">    |                  |                 | overridden by    |                  |</span>
<span class="sd">    |                  |                 | setting this     |                  |</span>
<span class="sd">    |                  |                 | option. In       |                  |</span>
<span class="sd">    |                  |                 | particular, 0    |                  |</span>
<span class="sd">    |                  |                 | means forcing    |                  |</span>
<span class="sd">    |                  |                 | forward mode and |                  |</span>
<span class="sd">    |                  |                 | 1 forcing        |                  |</span>
<span class="sd">    |                  |                 | reverse mode.    |                  |</span>
<span class="sd">    |                  |                 | Leave unset for  |                  |</span>
<span class="sd">    |                  |                 | (class specific) |                  |</span>
<span class="sd">    |                  |                 | heuristics.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for sparsity     | Internal         |</span>
<span class="sd">    |                  |                 | pattern          |                  |</span>
<span class="sd">    |                  |                 | calculation calc |                  |</span>
<span class="sd">    |                  |                 | ulation.Override |                  |</span>
<span class="sd">    |                  |                 | s default        |                  |</span>
<span class="sd">    |                  |                 | behavior. Set to |                  |</span>
<span class="sd">    |                  |                 | 0 and 1 to force |                  |</span>
<span class="sd">    |                  |                 | forward and      |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | respectively.    |                  |</span>
<span class="sd">    |                  |                 | Cf. option       |                  |</span>
<span class="sd">    |                  |                 | &quot;ad_weight&quot;.     |                  |</span>
<span class="sd">    |                  |                 | When set to -1,  |                  |</span>
<span class="sd">    |                  |                 | sparsity is      |                  |</span>
<span class="sd">    |                  |                 | completely       |                  |</span>
<span class="sd">    |                  |                 | ignored and      |                  |</span>
<span class="sd">    |                  |                 | dense matrices   |                  |</span>
<span class="sd">    |                  |                 | are used.        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler plugin  | Internal         |</span>
<span class="sd">    |                  |                 | to be used.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | const_A          | OT_BOOL         | Assume A is      | casadi::Expm     |</span>
<span class="sd">    |                  |                 | constant.        |                  |</span>
<span class="sd">    |                  |                 | Default: false.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |</span>
<span class="sd">    |                  |                 | CasADi&#39;s AD. Use | Internal         |</span>
<span class="sd">    |                  |                 | together with    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;:   |                  |</span>
<span class="sd">    |                  |                 | 0. Note: Highly  |                  |</span>
<span class="sd">    |                  |                 | experimental.    |                  |</span>
<span class="sd">    |                  |                 | Syntax may break |                  |</span>
<span class="sd">    |                  |                 | often.           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |</span>
<span class="sd">    |                  |                 | a derivative of  | Internal         |</span>
<span class="sd">    |                  |                 | another          |                  |</span>
<span class="sd">    |                  |                 | function. The    |                  |</span>
<span class="sd">    |                  |                 | type of          |                  |</span>
<span class="sd">    |                  |                 | derivative       |                  |</span>
<span class="sd">    |                  |                 | (directional     |                  |</span>
<span class="sd">    |                  |                 | derivative,      |                  |</span>
<span class="sd">    |                  |                 | Jacobian) is     |                  |</span>
<span class="sd">    |                  |                 | inferred from    |                  |</span>
<span class="sd">    |                  |                 | the function     |                  |</span>
<span class="sd">    |                  |                 | name.            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump             | OT_BOOL         | Dump function to | casadi::Function |</span>
<span class="sd">    |                  |                 | file upon first  | Internal         |</span>
<span class="sd">    |                  |                 | evaluation.      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_dir         | OT_STRING       | Directory to     | casadi::Function |</span>
<span class="sd">    |                  |                 | dump             | Internal         |</span>
<span class="sd">    |                  |                 | inputs/outputs   |                  |</span>
<span class="sd">    |                  |                 | to. Make sure    |                  |</span>
<span class="sd">    |                  |                 | the directory    |                  |</span>
<span class="sd">    |                  |                 | exists [.]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_format      | OT_STRING       | Choose file      | casadi::Function |</span>
<span class="sd">    |                  |                 | format to dump   | Internal         |</span>
<span class="sd">    |                  |                 | matrices. See    |                  |</span>
<span class="sd">    |                  |                 | DM.from_file     |                  |</span>
<span class="sd">    |                  |                 | [mtx]            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | to file          |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs to file  |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_fd        | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation by   |                  |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | differencing.    |                  |</span>
<span class="sd">    |                  |                 | [default:        |                  |</span>
<span class="sd">    |                  |                 | false]]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_forward   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using forward    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobians of all |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | outputs with     |                  |</span>
<span class="sd">    |                  |                 | respect to all   |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | inputs - if      |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_reverse   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | transposed       |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using reverse    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_method        | OT_STRING       | Method for       | casadi::Function |</span>
<span class="sd">    |                  |                 | finite           | Internal         |</span>
<span class="sd">    |                  |                 | differencing     |                  |</span>
<span class="sd">    |                  |                 | [default         |                  |</span>
<span class="sd">    |                  |                 | &#39;central&#39;]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_options       | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | difference       |                  |</span>
<span class="sd">    |                  |                 | instance         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | forward_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | forward mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option           | Internal         |</span>
<span class="sd">    |                  |                 | (ignored):       |                  |</span>
<span class="sd">    |                  |                 | Statistics are   |                  |</span>
<span class="sd">    |                  |                 | now always       |                  |</span>
<span class="sd">    |                  |                 | collected.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when the         | Internal         |</span>
<span class="sd">    |                  |                 | numerical values |                  |</span>
<span class="sd">    |                  |                 | of the inputs    |                  |</span>
<span class="sd">    |                  |                 | don&#39;t make sense |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each input if it | Internal         |</span>
<span class="sd">    |                  |                 | should be        |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each output if   | Internal         |</span>
<span class="sd">    |                  |                 | it should be     |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |</span>
<span class="sd">    |                  |                 | for a number of  | Internal         |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | directions, it   |                  |</span>
<span class="sd">    |                  |                 | may be cheaper   |                  |</span>
<span class="sd">    |                  |                 | to compute first |                  |</span>
<span class="sd">    |                  |                 | the full         |                  |</span>
<span class="sd">    |                  |                 | jacobian and     |                  |</span>
<span class="sd">    |                  |                 | then multiply    |                  |</span>
<span class="sd">    |                  |                 | with seeds,      |                  |</span>
<span class="sd">    |                  |                 | rather than      |                  |</span>
<span class="sd">    |                  |                 | obtain the       |                  |</span>
<span class="sd">    |                  |                 | requested        |                  |</span>
<span class="sd">    |                  |                 | directions in a  |                  |</span>
<span class="sd">    |                  |                 | straightforward  |                  |</span>
<span class="sd">    |                  |                 | manner. Casadi   |                  |</span>
<span class="sd">    |                  |                 | uses a heuristic |                  |</span>
<span class="sd">    |                  |                 | to decide which  |                  |</span>
<span class="sd">    |                  |                 | is cheaper. A    |                  |</span>
<span class="sd">    |                  |                 | high value of    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;    |                  |</span>
<span class="sd">    |                  |                 | makes it less    |                  |</span>
<span class="sd">    |                  |                 | likely for the   |                  |</span>
<span class="sd">    |                  |                 | heurstic to      |                  |</span>
<span class="sd">    |                  |                 | chose the full   |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy. The    |                  |</span>
<span class="sd">    |                  |                 | special value -1 |                  |</span>
<span class="sd">    |                  |                 | indicates never  |                  |</span>
<span class="sd">    |                  |                 | to use the full  |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler to      | Internal         |</span>
<span class="sd">    |                  |                 | speed up the     |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |</span>
<span class="sd">    |                  |                 | temporary source | Internal         |</span>
<span class="sd">    |                  |                 | file that jit    |                  |</span>
<span class="sd">    |                  |                 | creates.         |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_name         | OT_STRING       | The file name    | casadi::Function |</span>
<span class="sd">    |                  |                 | used to write    | Internal         |</span>
<span class="sd">    |                  |                 | out code. The    |                  |</span>
<span class="sd">    |                  |                 | actual file      |                  |</span>
<span class="sd">    |                  |                 | names used       |                  |</span>
<span class="sd">    |                  |                 | depend on &#39;jit_t |                  |</span>
<span class="sd">    |                  |                 | emp_suffix&#39; and  |                  |</span>
<span class="sd">    |                  |                 | include          |                  |</span>
<span class="sd">    |                  |                 | extensions.      |                  |</span>
<span class="sd">    |                  |                 | Default:         |                  |</span>
<span class="sd">    |                  |                 | &#39;jit_tmp&#39;        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_options      | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | jit compiler.    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_serialize    | OT_STRING       | Specify          | casadi::Function |</span>
<span class="sd">    |                  |                 | behaviour when   | Internal         |</span>
<span class="sd">    |                  |                 | serializing a    |                  |</span>
<span class="sd">    |                  |                 | jitted function: |                  |</span>
<span class="sd">    |                  |                 | SOURCE|link|embe |                  |</span>
<span class="sd">    |                  |                 | d.               |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |</span>
<span class="sd">    |                  |                 | (seemingly       | Internal         |</span>
<span class="sd">    |                  |                 | random) filename |                  |</span>
<span class="sd">    |                  |                 | suffix for       |                  |</span>
<span class="sd">    |                  |                 | generated code   |                  |</span>
<span class="sd">    |                  |                 | and libraries.   |                  |</span>
<span class="sd">    |                  |                 | This is desired  |                  |</span>
<span class="sd">    |                  |                 | for thread-      |                  |</span>
<span class="sd">    |                  |                 | safety. This     |                  |</span>
<span class="sd">    |                  |                 | behaviour may    |                  |</span>
<span class="sd">    |                  |                 | defeat caching   |                  |</span>
<span class="sd">    |                  |                 | compiler         |                  |</span>
<span class="sd">    |                  |                 | wrappers.        |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |</span>
<span class="sd">    |                  |                 | maximum number   | Internal         |</span>
<span class="sd">    |                  |                 | of directions    |                  |</span>
<span class="sd">    |                  |                 | for derivative   |                  |</span>
<span class="sd">    |                  |                 | functions.       |                  |</span>
<span class="sd">    |                  |                 | Overrules the    |                  |</span>
<span class="sd">    |                  |                 | builtin optimize |                  |</span>
<span class="sd">    |                  |                 | d_num_dir.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_in         | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_out        | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs          |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_time       | OT_BOOL         | print            | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time. Implies    |                  |</span>
<span class="sd">    |                  |                 | record_time.     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | record_time      | OT_BOOL         | record           | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time, for        |                  |</span>
<span class="sd">    |                  |                 | retrieval with   |                  |</span>
<span class="sd">    |                  |                 | stats().         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when NaN or Inf  | Internal         |</span>
<span class="sd">    |                  |                 | appears during   |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | reverse_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |</span>
<span class="sd">    |                  |                 | field that can   | Internal         |</span>
<span class="sd">    |                  |                 | be used to       |                  |</span>
<span class="sd">    |                  |                 | identify the     |                  |</span>
<span class="sd">    |                  |                 | function or pass |                  |</span>
<span class="sd">    |                  |                 | additional       |                  |</span>
<span class="sd">    |                  |                 | information      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | verbose          | OT_BOOL         | Verbose          | casadi::Function |</span>
<span class="sd">    |                  |                 | evaluation  for  | Internal         |</span>
<span class="sd">    |                  |                 | debugging        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - slicot</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Expm.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    slicot</span>
<span class="sd">    ------</span>





<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joris Gillis</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">expmsol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">expm_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of expm solver inputs.</span>

<span class="sd">    expm_n_in() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">expm_n_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">expm_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the number of expm solver outputs.</span>

<span class="sd">    expm_n_out() -&gt; int</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">expm_n_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_expm(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_expm(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_expm(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Parametric variant of interpolant.</span>

<span class="sd">      interpolant(str name, str solver, [[float]] grid, int m, dict opts) -&gt; Function</span>
<span class="sd">      interpolant(str name, str solver, [int] grid_dims, int m, dict opts) -&gt; Function</span>
<span class="sd">      interpolant(str name, str solver, [[float]] grid, [float] values, dict opts) -&gt; Function</span>
<span class="sd">      interpolant(str name, str solver, [int] grid_dims, [float] values, dict opts) -&gt; Function</span>


<span class="sd">    The resulting function will have an additional argument for the grid</span>

<span class="sd">    By default, derivatives wrt the coefficients are not supported (zero). Some</span>
<span class="sd">    interpolant plugins may support the inline=true which enables correct</span>
<span class="sd">    derivatives</span>



<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      interpolant(str name, str solver, [[float]] grid, int m, dict opts)</span>



<span class="sd">    Parametric variant of interpolant.</span>

<span class="sd">    The resulting function will have an additional argument for the coefficients</span>

<span class="sd">    By default, derivatives wrt the coefficients are not supported (zero). Some</span>
<span class="sd">    interpolant plugins may support the inline=true which enables correct</span>
<span class="sd">    derivatives</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      interpolant(str name, str solver, [int] grid_dims, int m, dict opts)</span>



<span class="sd">    Parametric variant of interpolant.</span>

<span class="sd">    The resulting function will have additional arguments for the grid and</span>
<span class="sd">    coefficients</span>

<span class="sd">    By default, derivatives wrt the coefficients are not supported (zero). Some</span>
<span class="sd">    interpolant plugins may support the inline=true which enables correct</span>
<span class="sd">    derivatives</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      interpolant(str name, str solver, [[float]] grid, [float] values, dict opts)</span>



<span class="sd">    An interpolant function for lookup table data</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    name:  label for the resulting Function</span>

<span class="sd">    solver:  name of the plugin</span>

<span class="sd">    grid:  collection of 1D grids whose outer product defines the full N-D</span>
<span class="sd">    rectangular grid</span>

<span class="sd">    values:  flattened vector of all values for all gridpoints</span>

<span class="sd">    Syntax 1D</span>

<span class="sd">    ::</span>

<span class="sd">      * # Python</span>
<span class="sd">      * xgrid = np.linspace(1,6,6)</span>
<span class="sd">      * V = [-1,-1,-2,-3,0,2]</span>
<span class="sd">      * LUT = casadi.interpolant(&quot;LUT&quot;,&quot;bspline&quot;,[xgrid],V)</span>
<span class="sd">      * print(LUT(2.5))</span>
<span class="sd">      * </span>



<span class="sd">    ::</span>

<span class="sd">      * % Matlab</span>
<span class="sd">      * xgrid = 1:6;</span>
<span class="sd">      * V = [-1 -1 -2 -3 0 2];</span>
<span class="sd">      * LUT = casadi.interpolant(&#39;LUT&#39;,&#39;bspline&#39;,{xgrid},V);</span>
<span class="sd">      * LUT(2.5)</span>
<span class="sd">      * </span>



<span class="sd">    Syntax 2D</span>

<span class="sd">    ::</span>

<span class="sd">      * # Python</span>
<span class="sd">      * xgrid = np.linspace(-5,5,11)</span>
<span class="sd">      * ygrid = np.linspace(-4,4,9)</span>
<span class="sd">      * X,Y = np.meshgrid(xgrid,ygrid,indexing=&#39;ij&#39;)</span>
<span class="sd">      * R = np.sqrt(5*X**2 + Y**2)+ 1</span>
<span class="sd">      * data = np.sin(R)/R</span>
<span class="sd">      * data_flat = data.ravel(order=&#39;F&#39;)</span>
<span class="sd">      * LUT = casadi.interpolant(&#39;name&#39;,&#39;bspline&#39;,[xgrid,ygrid],data_flat)</span>
<span class="sd">      * print(LUT([0.5,1]))</span>
<span class="sd">      * \\enverbatim</span>
<span class="sd">      * \\verbatim</span>
<span class="sd">      * % Matlab</span>
<span class="sd">      * xgrid = -5:1:5;</span>
<span class="sd">      * ygrid = -4:1:4;</span>
<span class="sd">      * R = sqrt(5*X.^2 + Y.^2)+ 1;</span>
<span class="sd">      * V = sin(R)./(R);</span>
<span class="sd">      * LUT = interpolant(&#39;LUT&#39;,&#39;bspline&#39;,{xgrid, ygrid},V(:));</span>
<span class="sd">      * LUT([0.5 1])</span>
<span class="sd">      * </span>



<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    |        Id        |      Type       |   Description    |     Used in      |</span>
<span class="sd">    +==================+=================+==================+==================+</span>
<span class="sd">    | ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for derivative   | Internal         |</span>
<span class="sd">    |                  |                 | calculation.When |                  |</span>
<span class="sd">    |                  |                 | there is an      |                  |</span>
<span class="sd">    |                  |                 | option of either |                  |</span>
<span class="sd">    |                  |                 | using forward or |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | directional      |                  |</span>
<span class="sd">    |                  |                 | derivatives, the |                  |</span>
<span class="sd">    |                  |                 | condition ad_wei |                  |</span>
<span class="sd">    |                  |                 | ght*nf&lt;=(1-ad_we |                  |</span>
<span class="sd">    |                  |                 | ight)*na is used |                  |</span>
<span class="sd">    |                  |                 | where nf and na  |                  |</span>
<span class="sd">    |                  |                 | are estimates of |                  |</span>
<span class="sd">    |                  |                 | the number of    |                  |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | mode directional |                  |</span>
<span class="sd">    |                  |                 | derivatives      |                  |</span>
<span class="sd">    |                  |                 | needed. By       |                  |</span>
<span class="sd">    |                  |                 | default,         |                  |</span>
<span class="sd">    |                  |                 | ad_weight is     |                  |</span>
<span class="sd">    |                  |                 | calculated       |                  |</span>
<span class="sd">    |                  |                 | automatically,   |                  |</span>
<span class="sd">    |                  |                 | but this can be  |                  |</span>
<span class="sd">    |                  |                 | overridden by    |                  |</span>
<span class="sd">    |                  |                 | setting this     |                  |</span>
<span class="sd">    |                  |                 | option. In       |                  |</span>
<span class="sd">    |                  |                 | particular, 0    |                  |</span>
<span class="sd">    |                  |                 | means forcing    |                  |</span>
<span class="sd">    |                  |                 | forward mode and |                  |</span>
<span class="sd">    |                  |                 | 1 forcing        |                  |</span>
<span class="sd">    |                  |                 | reverse mode.    |                  |</span>
<span class="sd">    |                  |                 | Leave unset for  |                  |</span>
<span class="sd">    |                  |                 | (class specific) |                  |</span>
<span class="sd">    |                  |                 | heuristics.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |</span>
<span class="sd">    |                  |                 | for sparsity     | Internal         |</span>
<span class="sd">    |                  |                 | pattern          |                  |</span>
<span class="sd">    |                  |                 | calculation calc |                  |</span>
<span class="sd">    |                  |                 | ulation.Override |                  |</span>
<span class="sd">    |                  |                 | s default        |                  |</span>
<span class="sd">    |                  |                 | behavior. Set to |                  |</span>
<span class="sd">    |                  |                 | 0 and 1 to force |                  |</span>
<span class="sd">    |                  |                 | forward and      |                  |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | respectively.    |                  |</span>
<span class="sd">    |                  |                 | Cf. option       |                  |</span>
<span class="sd">    |                  |                 | &quot;ad_weight&quot;.     |                  |</span>
<span class="sd">    |                  |                 | When set to -1,  |                  |</span>
<span class="sd">    |                  |                 | sparsity is      |                  |</span>
<span class="sd">    |                  |                 | completely       |                  |</span>
<span class="sd">    |                  |                 | ignored and      |                  |</span>
<span class="sd">    |                  |                 | dense matrices   |                  |</span>
<span class="sd">    |                  |                 | are used.        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | batch_x          | OT_INT          | Evaluate a batch | casadi::Interpol |</span>
<span class="sd">    |                  |                 | of different     | ant              |</span>
<span class="sd">    |                  |                 | inputs at once   |                  |</span>
<span class="sd">    |                  |                 | (default 1).     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | compiler         | OT_STRING       | Just-in-time     | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler plugin  | Internal         |</span>
<span class="sd">    |                  |                 | to be used.      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |</span>
<span class="sd">    |                  |                 | CasADi&#39;s AD. Use | Internal         |</span>
<span class="sd">    |                  |                 | together with    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;:   |                  |</span>
<span class="sd">    |                  |                 | 0. Note: Highly  |                  |</span>
<span class="sd">    |                  |                 | experimental.    |                  |</span>
<span class="sd">    |                  |                 | Syntax may break |                  |</span>
<span class="sd">    |                  |                 | often.           |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |</span>
<span class="sd">    |                  |                 | a derivative of  | Internal         |</span>
<span class="sd">    |                  |                 | another          |                  |</span>
<span class="sd">    |                  |                 | function. The    |                  |</span>
<span class="sd">    |                  |                 | type of          |                  |</span>
<span class="sd">    |                  |                 | derivative       |                  |</span>
<span class="sd">    |                  |                 | (directional     |                  |</span>
<span class="sd">    |                  |                 | derivative,      |                  |</span>
<span class="sd">    |                  |                 | Jacobian) is     |                  |</span>
<span class="sd">    |                  |                 | inferred from    |                  |</span>
<span class="sd">    |                  |                 | the function     |                  |</span>
<span class="sd">    |                  |                 | name.            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump             | OT_BOOL         | Dump function to | casadi::Function |</span>
<span class="sd">    |                  |                 | file upon first  | Internal         |</span>
<span class="sd">    |                  |                 | evaluation.      |                  |</span>
<span class="sd">    |                  |                 | [false]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_dir         | OT_STRING       | Directory to     | casadi::Function |</span>
<span class="sd">    |                  |                 | dump             | Internal         |</span>
<span class="sd">    |                  |                 | inputs/outputs   |                  |</span>
<span class="sd">    |                  |                 | to. Make sure    |                  |</span>
<span class="sd">    |                  |                 | the directory    |                  |</span>
<span class="sd">    |                  |                 | exists [.]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_format      | OT_STRING       | Choose file      | casadi::Function |</span>
<span class="sd">    |                  |                 | format to dump   | Internal         |</span>
<span class="sd">    |                  |                 | matrices. See    |                  |</span>
<span class="sd">    |                  |                 | DM.from_file     |                  |</span>
<span class="sd">    |                  |                 | [mtx]            |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | to file          |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs to file  |                  |</span>
<span class="sd">    |                  |                 | (readable with   |                  |</span>
<span class="sd">    |                  |                 | DM.from_file )   |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_fd        | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation by   |                  |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | differencing.    |                  |</span>
<span class="sd">    |                  |                 | [default:        |                  |</span>
<span class="sd">    |                  |                 | false]]          |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_forward   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using forward    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | Jacobians of all |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | outputs with     |                  |</span>
<span class="sd">    |                  |                 | respect to all   |                  |</span>
<span class="sd">    |                  |                 | differentiable   |                  |</span>
<span class="sd">    |                  |                 | inputs - if      |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | enable_reverse   | OT_BOOL         | Enable           | casadi::Function |</span>
<span class="sd">    |                  |                 | derivative       | Internal         |</span>
<span class="sd">    |                  |                 | calculation      |                  |</span>
<span class="sd">    |                  |                 | using generated  |                  |</span>
<span class="sd">    |                  |                 | functions for    |                  |</span>
<span class="sd">    |                  |                 | transposed       |                  |</span>
<span class="sd">    |                  |                 | Jacobian-times-  |                  |</span>
<span class="sd">    |                  |                 | vector products  |                  |</span>
<span class="sd">    |                  |                 | - typically      |                  |</span>
<span class="sd">    |                  |                 | using reverse    |                  |</span>
<span class="sd">    |                  |                 | mode AD - if     |                  |</span>
<span class="sd">    |                  |                 | available.       |                  |</span>
<span class="sd">    |                  |                 | [default: true]  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_method        | OT_STRING       | Method for       | casadi::Function |</span>
<span class="sd">    |                  |                 | finite           | Internal         |</span>
<span class="sd">    |                  |                 | differencing     |                  |</span>
<span class="sd">    |                  |                 | [default         |                  |</span>
<span class="sd">    |                  |                 | &#39;central&#39;]       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | fd_options       | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | finite           |                  |</span>
<span class="sd">    |                  |                 | difference       |                  |</span>
<span class="sd">    |                  |                 | instance         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | forward_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | forward mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option           | Internal         |</span>
<span class="sd">    |                  |                 | (ignored):       |                  |</span>
<span class="sd">    |                  |                 | Statistics are   |                  |</span>
<span class="sd">    |                  |                 | now always       |                  |</span>
<span class="sd">    |                  |                 | collected.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | inline           | OT_BOOL         | Implement the    | casadi::Interpol |</span>
<span class="sd">    |                  |                 | lookup table in  | ant              |</span>
<span class="sd">    |                  |                 | MX primitives.   |                  |</span>
<span class="sd">    |                  |                 | Useful when you  |                  |</span>
<span class="sd">    |                  |                 | need derivatives |                  |</span>
<span class="sd">    |                  |                 | with respect to  |                  |</span>
<span class="sd">    |                  |                 | grid and/or      |                  |</span>
<span class="sd">    |                  |                 | coefficients.    |                  |</span>
<span class="sd">    |                  |                 | Such derivatives |                  |</span>
<span class="sd">    |                  |                 | are              |                  |</span>
<span class="sd">    |                  |                 | fundamentally    |                  |</span>
<span class="sd">    |                  |                 | dense, so use    |                  |</span>
<span class="sd">    |                  |                 | with caution.    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when the         | Internal         |</span>
<span class="sd">    |                  |                 | numerical values |                  |</span>
<span class="sd">    |                  |                 | of the inputs    |                  |</span>
<span class="sd">    |                  |                 | don&#39;t make sense |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each input if it | Internal         |</span>
<span class="sd">    |                  |                 | should be        |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |</span>
<span class="sd">    |                  |                 | each output if   | Internal         |</span>
<span class="sd">    |                  |                 | it should be     |                  |</span>
<span class="sd">    |                  |                 | differentiable.  |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |</span>
<span class="sd">    |                  |                 | for a number of  | Internal         |</span>
<span class="sd">    |                  |                 | forward/reverse  |                  |</span>
<span class="sd">    |                  |                 | directions, it   |                  |</span>
<span class="sd">    |                  |                 | may be cheaper   |                  |</span>
<span class="sd">    |                  |                 | to compute first |                  |</span>
<span class="sd">    |                  |                 | the full         |                  |</span>
<span class="sd">    |                  |                 | jacobian and     |                  |</span>
<span class="sd">    |                  |                 | then multiply    |                  |</span>
<span class="sd">    |                  |                 | with seeds,      |                  |</span>
<span class="sd">    |                  |                 | rather than      |                  |</span>
<span class="sd">    |                  |                 | obtain the       |                  |</span>
<span class="sd">    |                  |                 | requested        |                  |</span>
<span class="sd">    |                  |                 | directions in a  |                  |</span>
<span class="sd">    |                  |                 | straightforward  |                  |</span>
<span class="sd">    |                  |                 | manner. Casadi   |                  |</span>
<span class="sd">    |                  |                 | uses a heuristic |                  |</span>
<span class="sd">    |                  |                 | to decide which  |                  |</span>
<span class="sd">    |                  |                 | is cheaper. A    |                  |</span>
<span class="sd">    |                  |                 | high value of    |                  |</span>
<span class="sd">    |                  |                 | &#39;jac_penalty&#39;    |                  |</span>
<span class="sd">    |                  |                 | makes it less    |                  |</span>
<span class="sd">    |                  |                 | likely for the   |                  |</span>
<span class="sd">    |                  |                 | heurstic to      |                  |</span>
<span class="sd">    |                  |                 | chose the full   |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy. The    |                  |</span>
<span class="sd">    |                  |                 | special value -1 |                  |</span>
<span class="sd">    |                  |                 | indicates never  |                  |</span>
<span class="sd">    |                  |                 | to use the full  |                  |</span>
<span class="sd">    |                  |                 | Jacobian         |                  |</span>
<span class="sd">    |                  |                 | strategy         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit              | OT_BOOL         | Use just-in-time | casadi::Function |</span>
<span class="sd">    |                  |                 | compiler to      | Internal         |</span>
<span class="sd">    |                  |                 | speed up the     |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |</span>
<span class="sd">    |                  |                 | temporary source | Internal         |</span>
<span class="sd">    |                  |                 | file that jit    |                  |</span>
<span class="sd">    |                  |                 | creates.         |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_name         | OT_STRING       | The file name    | casadi::Function |</span>
<span class="sd">    |                  |                 | used to write    | Internal         |</span>
<span class="sd">    |                  |                 | out code. The    |                  |</span>
<span class="sd">    |                  |                 | actual file      |                  |</span>
<span class="sd">    |                  |                 | names used       |                  |</span>
<span class="sd">    |                  |                 | depend on &#39;jit_t |                  |</span>
<span class="sd">    |                  |                 | emp_suffix&#39; and  |                  |</span>
<span class="sd">    |                  |                 | include          |                  |</span>
<span class="sd">    |                  |                 | extensions.      |                  |</span>
<span class="sd">    |                  |                 | Default:         |                  |</span>
<span class="sd">    |                  |                 | &#39;jit_tmp&#39;        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_options      | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to the    | Internal         |</span>
<span class="sd">    |                  |                 | jit compiler.    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_serialize    | OT_STRING       | Specify          | casadi::Function |</span>
<span class="sd">    |                  |                 | behaviour when   | Internal         |</span>
<span class="sd">    |                  |                 | serializing a    |                  |</span>
<span class="sd">    |                  |                 | jitted function: |                  |</span>
<span class="sd">    |                  |                 | SOURCE|link|embe |                  |</span>
<span class="sd">    |                  |                 | d.               |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |</span>
<span class="sd">    |                  |                 | (seemingly       | Internal         |</span>
<span class="sd">    |                  |                 | random) filename |                  |</span>
<span class="sd">    |                  |                 | suffix for       |                  |</span>
<span class="sd">    |                  |                 | generated code   |                  |</span>
<span class="sd">    |                  |                 | and libraries.   |                  |</span>
<span class="sd">    |                  |                 | This is desired  |                  |</span>
<span class="sd">    |                  |                 | for thread-      |                  |</span>
<span class="sd">    |                  |                 | safety. This     |                  |</span>
<span class="sd">    |                  |                 | behaviour may    |                  |</span>
<span class="sd">    |                  |                 | defeat caching   |                  |</span>
<span class="sd">    |                  |                 | compiler         |                  |</span>
<span class="sd">    |                  |                 | wrappers.        |                  |</span>
<span class="sd">    |                  |                 | Default: true    |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | lookup_mode      | OT_STRINGVECTOR | Specifies, for   | casadi::Interpol |</span>
<span class="sd">    |                  |                 | each grid        | ant              |</span>
<span class="sd">    |                  |                 | dimenion, the    |                  |</span>
<span class="sd">    |                  |                 | lookup algorithm |                  |</span>
<span class="sd">    |                  |                 | used to find the |                  |</span>
<span class="sd">    |                  |                 | correct index.   |                  |</span>
<span class="sd">    |                  |                 | &#39;linear&#39; uses a  |                  |</span>
<span class="sd">    |                  |                 | for-loop +       |                  |</span>
<span class="sd">    |                  |                 | break; (default  |                  |</span>
<span class="sd">    |                  |                 | when             |                  |</span>
<span class="sd">    |                  |                 | #knots&lt;=100),    |                  |</span>
<span class="sd">    |                  |                 | &#39;exact&#39; uses     |                  |</span>
<span class="sd">    |                  |                 | floored division |                  |</span>
<span class="sd">    |                  |                 | (only for        |                  |</span>
<span class="sd">    |                  |                 | uniform grids),  |                  |</span>
<span class="sd">    |                  |                 | &#39;binary&#39; uses a  |                  |</span>
<span class="sd">    |                  |                 | binary search.   |                  |</span>
<span class="sd">    |                  |                 | (default when    |                  |</span>
<span class="sd">    |                  |                 | #knots&gt;100).     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | max_num_dir      | OT_INT          | Specify the      | casadi::Function |</span>
<span class="sd">    |                  |                 | maximum number   | Internal         |</span>
<span class="sd">    |                  |                 | of directions    |                  |</span>
<span class="sd">    |                  |                 | for derivative   |                  |</span>
<span class="sd">    |                  |                 | functions.       |                  |</span>
<span class="sd">    |                  |                 | Overrules the    |                  |</span>
<span class="sd">    |                  |                 | builtin optimize |                  |</span>
<span class="sd">    |                  |                 | d_num_dir.       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |</span>
<span class="sd">    |                  |                 |                  | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |</span>
<span class="sd">    |                  |                 | option (ignored) | Internal         |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_in         | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of inputs | Internal         |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_out        | OT_BOOL         | Print numerical  | casadi::Function |</span>
<span class="sd">    |                  |                 | values of        | Internal         |</span>
<span class="sd">    |                  |                 | outputs          |                  |</span>
<span class="sd">    |                  |                 | [default: false] |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | print_time       | OT_BOOL         | print            | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time. Implies    |                  |</span>
<span class="sd">    |                  |                 | record_time.     |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | record_time      | OT_BOOL         | record           | casadi::Function |</span>
<span class="sd">    |                  |                 | information      | Internal         |</span>
<span class="sd">    |                  |                 | about execution  |                  |</span>
<span class="sd">    |                  |                 | time, for        |                  |</span>
<span class="sd">    |                  |                 | retrieval with   |                  |</span>
<span class="sd">    |                  |                 | stats().         |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |</span>
<span class="sd">    |                  |                 | when NaN or Inf  | Internal         |</span>
<span class="sd">    |                  |                 | appears during   |                  |</span>
<span class="sd">    |                  |                 | evaluation       |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | reverse_options  | OT_DICT         | Options to be    | casadi::Function |</span>
<span class="sd">    |                  |                 | passed to a      | Internal         |</span>
<span class="sd">    |                  |                 | reverse mode     |                  |</span>
<span class="sd">    |                  |                 | constructor      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |</span>
<span class="sd">    |                  |                 | field that can   | Internal         |</span>
<span class="sd">    |                  |                 | be used to       |                  |</span>
<span class="sd">    |                  |                 | identify the     |                  |</span>
<span class="sd">    |                  |                 | function or pass |                  |</span>
<span class="sd">    |                  |                 | additional       |                  |</span>
<span class="sd">    |                  |                 | information      |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>
<span class="sd">    | verbose          | OT_BOOL         | Verbose          | casadi::Function |</span>
<span class="sd">    |                  |                 | evaluation  for  | Internal         |</span>
<span class="sd">    |                  |                 | debugging        |                  |</span>
<span class="sd">    +------------------+-----------------+------------------+------------------+</span>

<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - bspline</span>

<span class="sd">    - linear</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Interpolant.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    bspline</span>
<span class="sd">    -------</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-----------------------+--------------+-----------------------------------+</span>
<span class="sd">    |          Id           |     Type     |            Description            |</span>
<span class="sd">    +=======================+==============+===================================+</span>
<span class="sd">    | algorithm             | OT_STRING    | Algorithm used for fitting the    |</span>
<span class="sd">    |                       |              | data: &#39;not_a_knot&#39; (default, same |</span>
<span class="sd">    |                       |              | as Matlab), &#39;smooth_linear&#39;.      |</span>
<span class="sd">    +-----------------------+--------------+-----------------------------------+</span>
<span class="sd">    | degree                | OT_INTVECTOR | Sets, for each grid dimension,    |</span>
<span class="sd">    |                       |              | the degree of the spline.         |</span>
<span class="sd">    +-----------------------+--------------+-----------------------------------+</span>
<span class="sd">    | linear_solver         | OT_STRING    | Solver used for constructing the  |</span>
<span class="sd">    |                       |              | coefficient tensor.               |</span>
<span class="sd">    +-----------------------+--------------+-----------------------------------+</span>
<span class="sd">    | linear_solver_options | OT_DICT      | Options to be passed to the       |</span>
<span class="sd">    |                       |              | linear solver.                    |</span>
<span class="sd">    +-----------------------+--------------+-----------------------------------+</span>
<span class="sd">    | smooth_linear_frac    | OT_DOUBLE    | When &#39;smooth_linear&#39; algorithm is |</span>
<span class="sd">    |                       |              | active, determines sharpness      |</span>
<span class="sd">    |                       |              | between 0 (sharp, as linear       |</span>
<span class="sd">    |                       |              | interpolation) and 0.5            |</span>
<span class="sd">    |                       |              | (smooth).Default value is 0.1.    |</span>
<span class="sd">    +-----------------------+--------------+-----------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    linear</span>
<span class="sd">    ------</span>



<span class="sd">    &gt;List of available options</span>

<span class="sd">    +-------------+-----------------+------------------------------------------+</span>
<span class="sd">    |     Id      |      Type       |               Description                |</span>
<span class="sd">    +=============+=================+==========================================+</span>
<span class="sd">    | lookup_mode | OT_STRINGVECTOR | Sets, for each grid dimenion, the lookup |</span>
<span class="sd">    |             |                 | algorithm used to find the correct       |</span>
<span class="sd">    |             |                 | index. &#39;linear&#39; uses a for-loop + break; |</span>
<span class="sd">    |             |                 | &#39;exact&#39; uses floored division (only for  |</span>
<span class="sd">    |             |                 | uniform grids).                          |</span>
<span class="sd">    +-------------+-----------------+------------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joel Andersson</span>



<span class="sd">    .............</span>


<span class="sd">    .......</span>

<span class="sd">    ::</span>

<span class="sd">      interpolant(str name, str solver, [int] grid_dims, [float] values, dict opts)</span>



<span class="sd">    Parametric variant of interpolant.</span>

<span class="sd">    The resulting function will have an additional argument for the grid</span>

<span class="sd">    By default, derivatives wrt the coefficients are not supported (zero). Some</span>
<span class="sd">    interpolant plugins may support the inline=true which enables correct</span>
<span class="sd">    derivatives</span>



<span class="sd">    .............</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a particular plugin is available.</span>

<span class="sd">    has_interpolant(str name) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">has_interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explicitly load a plugin dynamically.</span>

<span class="sd">    load_interpolant(str name)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">load_interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">doc_interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the documentation string for a plugin.</span>

<span class="sd">    doc_interpolant(str name) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">doc_interpolant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">CodeGenerator</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Helper class for C code generation.</span>



<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: code_generator.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CodeGenerator</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CodeGenerator</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>

<span class="sd">        CodeGenerator(str name, dict opts)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_CodeGenerator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a function (name generated)</span>

<span class="sd">        add(self, Function f, bool with_jac_sparsity)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CodeGenerator_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a file, return code as string.</span>

<span class="sd">        dump(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CodeGenerator_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Generate file(s) The &quot;prefix&quot; argument will be prepended to the generated</span>

<span class="sd">          generate(self, str prefix) -&gt; str</span>

<span class="sd">        files and may be a directory or a file prefix. returns the filename.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CodeGenerator_generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_include</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Add an include file optionally using a relative path &quot;...&quot; instead of an</span>

<span class="sd">          add_include(self, str new_include, bool relative_path, str use_ifdef)</span>

<span class="sd">        absolute path &lt;...&gt;</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CodeGenerator_add_include</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_CodeGenerator</span>
<span class="n">CodeGenerator_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CodeGenerator_swigregister</span>
<span class="n">CodeGenerator_swigregister</span><span class="p">(</span><span class="n">CodeGenerator</span><span class="p">)</span>

<span class="n">FLAG</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FLAG</span>

<span class="k">def</span> <span class="nf">_horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    _horzcat([Sparsity] v) -&gt; Sparsity</span>
<span class="sd">    _horzcat([DM] v) -&gt; DM</span>
<span class="sd">    _horzcat([SX] v) -&gt; SX</span>
<span class="sd">    _horzcat([MX] v) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">_horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_vertcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    _vertcat([Sparsity] v) -&gt; Sparsity</span>
<span class="sd">    _vertcat([DM] v) -&gt; DM</span>
<span class="sd">    _vertcat([SX] v) -&gt; SX</span>
<span class="sd">    _vertcat([MX] v) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">_vertcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">horzsplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    horzsplit(Sparsity v, int incr) -&gt; [Sparsity]</span>
<span class="sd">    horzsplit(DM v, int incr) -&gt; [DM]</span>
<span class="sd">    horzsplit(SX v, int incr) -&gt; [SX]</span>
<span class="sd">    horzsplit(MX v, int incr) -&gt; [MX]</span>
<span class="sd">    horzsplit(Sparsity v, [int] offset) -&gt; [Sparsity]</span>
<span class="sd">    horzsplit(DM v, [int] offset) -&gt; [DM]</span>
<span class="sd">    horzsplit(SX v, [int] offset) -&gt; [SX]</span>
<span class="sd">    horzsplit(MX v, [int] offset) -&gt; [MX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">horzsplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    offset([Sparsity] v, bool vert) -&gt; [int]</span>
<span class="sd">    offset([DM] v, bool vert) -&gt; [int]</span>
<span class="sd">    offset([SX] v, bool vert) -&gt; [int]</span>
<span class="sd">    offset([MX] v, bool vert) -&gt; [int]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vertsplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    vertsplit(Sparsity v, int incr) -&gt; [Sparsity]</span>
<span class="sd">    vertsplit(DM v, int incr) -&gt; [DM]</span>
<span class="sd">    vertsplit(SX v, int incr) -&gt; [SX]</span>
<span class="sd">    vertsplit(MX v, int incr) -&gt; [MX]</span>
<span class="sd">    vertsplit(Sparsity v, [int] offset) -&gt; [Sparsity]</span>
<span class="sd">    vertsplit(DM v, [int] offset) -&gt; [DM]</span>
<span class="sd">    vertsplit(SX v, [int] offset) -&gt; [SX]</span>
<span class="sd">    vertsplit(MX v, [int] offset) -&gt; [MX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">vertsplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">blocksplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    blocksplit(Sparsity x, int vert_incr, int horz_incr) -&gt; [[Sparsity]]</span>
<span class="sd">    blocksplit(DM x, int vert_incr, int horz_incr) -&gt; [[DM]]</span>
<span class="sd">    blocksplit(SX x, int vert_incr, int horz_incr) -&gt; [[SX]]</span>
<span class="sd">    blocksplit(MX x, int vert_incr, int horz_incr) -&gt; [[MX]]</span>
<span class="sd">    blocksplit(Sparsity x, [int] vert_offset, [int] horz_offset) -&gt; [[Sparsity]]</span>
<span class="sd">    blocksplit(DM x, [int] vert_offset, [int] horz_offset) -&gt; [[DM]]</span>
<span class="sd">    blocksplit(SX x, [int] vert_offset, [int] horz_offset) -&gt; [[SX]]</span>
<span class="sd">    blocksplit(MX x, [int] vert_offset, [int] horz_offset) -&gt; [[MX]]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">blocksplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_diagcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    _diagcat([Sparsity] A) -&gt; Sparsity</span>
<span class="sd">    _diagcat([DM] A) -&gt; DM</span>
<span class="sd">    _diagcat([SX] A) -&gt; SX</span>
<span class="sd">    _diagcat([MX] A) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">_diagcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">diagsplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    diagsplit(Sparsity x, int incr) -&gt; [Sparsity]</span>
<span class="sd">    diagsplit(DM x, int incr) -&gt; [DM]</span>
<span class="sd">    diagsplit(SX x, int incr) -&gt; [SX]</span>
<span class="sd">    diagsplit(MX x, int incr) -&gt; [MX]</span>
<span class="sd">    diagsplit(Sparsity x, [int] output_offset) -&gt; [Sparsity]</span>
<span class="sd">    diagsplit(DM x, [int] output_offset) -&gt; [DM]</span>
<span class="sd">    diagsplit(SX x, [int] output_offset) -&gt; [SX]</span>
<span class="sd">    diagsplit(MX x, [int] output_offset) -&gt; [MX]</span>
<span class="sd">    diagsplit(Sparsity x, int incr1, int incr2) -&gt; [Sparsity]</span>
<span class="sd">    diagsplit(Sparsity x, [int] output_offset1, [int] output_offset2) -&gt; [Sparsity]</span>
<span class="sd">    diagsplit(DM x, int incr1, int incr2) -&gt; [DM]</span>
<span class="sd">    diagsplit(DM x, [int] output_offset1, [int] output_offset2) -&gt; [DM]</span>
<span class="sd">    diagsplit(SX x, int incr1, int incr2) -&gt; [SX]</span>
<span class="sd">    diagsplit(SX x, [int] output_offset1, [int] output_offset2) -&gt; [SX]</span>
<span class="sd">    diagsplit(MX x, int incr1, int incr2) -&gt; [MX]</span>
<span class="sd">    diagsplit(MX x, [int] output_offset1, [int] output_offset2) -&gt; [MX]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">diagsplit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_veccat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    _veccat([Sparsity] x) -&gt; Sparsity</span>
<span class="sd">    _veccat([DM] x) -&gt; DM</span>
<span class="sd">    _veccat([SX] x) -&gt; SX</span>
<span class="sd">    _veccat([MX] x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">_veccat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mtimes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    mtimes([Sparsity] args) -&gt; Sparsity</span>
<span class="sd">    mtimes([DM] args) -&gt; DM</span>
<span class="sd">    mtimes([SX] args) -&gt; SX</span>
<span class="sd">    mtimes([MX] args) -&gt; MX</span>
<span class="sd">    mtimes(Sparsity x, Sparsity y) -&gt; Sparsity</span>
<span class="sd">    mtimes(DM x, DM y) -&gt; DM</span>
<span class="sd">    mtimes(SX x, SX y) -&gt; SX</span>
<span class="sd">    mtimes(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mtimes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mac</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    mac(Sparsity X, Sparsity Y, Sparsity Z) -&gt; Sparsity</span>
<span class="sd">    mac(DM X, DM Y, DM Z) -&gt; DM</span>
<span class="sd">    mac(SX X, SX Y, SX Z) -&gt; SX</span>
<span class="sd">    mac(MX X, MX Y, MX Z) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mac</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Transpose the matrix and get the reordering of the non-zero entries.</span>

<span class="sd">      transpose(Sparsity X) -&gt; Sparsity</span>
<span class="sd">      transpose(DM X) -&gt; DM</span>
<span class="sd">      transpose(SX X) -&gt; SX</span>
<span class="sd">      transpose(MX X) -&gt; MX</span>


<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    mapping:  the non-zeros of the original matrix for each non-zero of the new</span>
<span class="sd">    matrix</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    vec(Sparsity a) -&gt; Sparsity</span>
<span class="sd">    vec(DM a) -&gt; DM</span>
<span class="sd">    vec(SX a) -&gt; SX</span>
<span class="sd">    vec(MX a) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">vec</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    reshape(Sparsity a, (int,int) rc) -&gt; Sparsity</span>
<span class="sd">    reshape(Sparsity a, Sparsity sp) -&gt; Sparsity</span>
<span class="sd">    reshape(DM a, (int,int) rc) -&gt; DM</span>
<span class="sd">    reshape(DM a, Sparsity sp) -&gt; DM</span>
<span class="sd">    reshape(SX a, (int,int) rc) -&gt; SX</span>
<span class="sd">    reshape(SX a, Sparsity sp) -&gt; SX</span>
<span class="sd">    reshape(MX a, (int,int) rc) -&gt; MX</span>
<span class="sd">    reshape(MX a, Sparsity sp) -&gt; MX</span>
<span class="sd">    reshape(Sparsity a, int nrow, int ncol) -&gt; Sparsity</span>
<span class="sd">    reshape(DM a, int nrow, int ncol) -&gt; DM</span>
<span class="sd">    reshape(SX a, int nrow, int ncol) -&gt; SX</span>
<span class="sd">    reshape(MX a, int nrow, int ncol) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sprank</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sprank(Sparsity A) -&gt; int</span>
<span class="sd">    sprank(DM A) -&gt; int</span>
<span class="sd">    sprank(SX A) -&gt; int</span>
<span class="sd">    sprank(MX A) -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sprank</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">norm_0_mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    norm_0_mul(Sparsity x, Sparsity y) -&gt; int</span>
<span class="sd">    norm_0_mul(DM x, DM y) -&gt; int</span>
<span class="sd">    norm_0_mul(SX x, SX y) -&gt; int</span>
<span class="sd">    norm_0_mul(MX x, MX y) -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">norm_0_mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">triu</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    triu(Sparsity a, bool includeDiagonal) -&gt; Sparsity</span>
<span class="sd">    triu(DM a, bool includeDiagonal) -&gt; DM</span>
<span class="sd">    triu(SX a, bool includeDiagonal) -&gt; SX</span>
<span class="sd">    triu(MX a, bool includeDiagonal) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tril</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    tril(Sparsity a, bool includeDiagonal) -&gt; Sparsity</span>
<span class="sd">    tril(DM a, bool includeDiagonal) -&gt; DM</span>
<span class="sd">    tril(SX a, bool includeDiagonal) -&gt; SX</span>
<span class="sd">    tril(MX a, bool includeDiagonal) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">kron</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    kron(Sparsity a, Sparsity b) -&gt; Sparsity</span>
<span class="sd">    kron(DM a, DM b) -&gt; DM</span>
<span class="sd">    kron(SX a, SX b) -&gt; SX</span>
<span class="sd">    kron(MX a, MX b) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">repmat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    repmat(Sparsity A, int n, int m) -&gt; Sparsity</span>
<span class="sd">    repmat(Sparsity A, (int,int) rc) -&gt; Sparsity</span>
<span class="sd">    repmat(DM A, int n, int m) -&gt; DM</span>
<span class="sd">    repmat(DM A, (int,int) rc) -&gt; DM</span>
<span class="sd">    repmat(SX A, int n, int m) -&gt; SX</span>
<span class="sd">    repmat(SX A, (int,int) rc) -&gt; SX</span>
<span class="sd">    repmat(MX A, int n, int m) -&gt; MX</span>
<span class="sd">    repmat(MX A, (int,int) rc) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sum2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sum2(Sparsity x) -&gt; Sparsity</span>
<span class="sd">    sum2(DM x) -&gt; DM</span>
<span class="sd">    sum2(SX x) -&gt; SX</span>
<span class="sd">    sum2(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sum2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sum1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sum1(Sparsity x) -&gt; Sparsity</span>
<span class="sd">    sum1(DM x) -&gt; DM</span>
<span class="sd">    sum1(SX x) -&gt; SX</span>
<span class="sd">    sum1(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sum1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    plus(float x, float y) -&gt; float</span>
<span class="sd">    plus(DM x, DM y) -&gt; DM</span>
<span class="sd">    plus(SX x, SX y) -&gt; SX</span>
<span class="sd">    plus(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">minus</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    minus(float x, float y) -&gt; float</span>
<span class="sd">    minus(DM x, DM y) -&gt; DM</span>
<span class="sd">    minus(SX x, SX y) -&gt; SX</span>
<span class="sd">    minus(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">minus</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    times(float x, float y) -&gt; float</span>
<span class="sd">    times(DM x, DM y) -&gt; DM</span>
<span class="sd">    times(SX x, SX y) -&gt; SX</span>
<span class="sd">    times(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rdivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    rdivide(float x, float y) -&gt; float</span>
<span class="sd">    rdivide(DM x, DM y) -&gt; DM</span>
<span class="sd">    rdivide(SX x, SX y) -&gt; SX</span>
<span class="sd">    rdivide(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rdivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ldivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    ldivide(float x, float y) -&gt; float</span>
<span class="sd">    ldivide(DM x, DM y) -&gt; DM</span>
<span class="sd">    ldivide(SX x, SX y) -&gt; SX</span>
<span class="sd">    ldivide(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ldivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    lt(float x, float y) -&gt; float</span>
<span class="sd">    lt(DM x, DM y) -&gt; DM</span>
<span class="sd">    lt(SX x, SX y) -&gt; SX</span>
<span class="sd">    lt(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">le</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    le(float x, float y) -&gt; float</span>
<span class="sd">    le(DM x, DM y) -&gt; DM</span>
<span class="sd">    le(SX x, SX y) -&gt; SX</span>
<span class="sd">    le(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    gt(float x, float y) -&gt; float</span>
<span class="sd">    gt(DM x, DM y) -&gt; DM</span>
<span class="sd">    gt(SX x, SX y) -&gt; SX</span>
<span class="sd">    gt(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    ge(float x, float y) -&gt; float</span>
<span class="sd">    ge(DM x, DM y) -&gt; DM</span>
<span class="sd">    ge(SX x, SX y) -&gt; SX</span>
<span class="sd">    ge(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    eq(float x, float y) -&gt; float</span>
<span class="sd">    eq(DM x, DM y) -&gt; DM</span>
<span class="sd">    eq(SX x, SX y) -&gt; SX</span>
<span class="sd">    eq(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ne</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    ne(float x, float y) -&gt; float</span>
<span class="sd">    ne(DM x, DM y) -&gt; DM</span>
<span class="sd">    ne(SX x, SX y) -&gt; SX</span>
<span class="sd">    ne(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logic_and</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    logic_and(float x, float y) -&gt; float</span>
<span class="sd">    logic_and(DM x, DM y) -&gt; DM</span>
<span class="sd">    logic_and(SX x, SX y) -&gt; SX</span>
<span class="sd">    logic_and(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_and</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logic_or</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    logic_or(float x, float y) -&gt; float</span>
<span class="sd">    logic_or(DM x, DM y) -&gt; DM</span>
<span class="sd">    logic_or(SX x, SX y) -&gt; SX</span>
<span class="sd">    logic_or(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_or</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logic_not</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    logic_not(float x) -&gt; float</span>
<span class="sd">    logic_not(DM x) -&gt; DM</span>
<span class="sd">    logic_not(SX x) -&gt; SX</span>
<span class="sd">    logic_not(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_not</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fabs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    fabs(float x) -&gt; float</span>
<span class="sd">    fabs(DM x) -&gt; DM</span>
<span class="sd">    fabs(SX x) -&gt; SX</span>
<span class="sd">    fabs(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sqrt(float x) -&gt; float</span>
<span class="sd">    sqrt(DM x) -&gt; DM</span>
<span class="sd">    sqrt(SX x) -&gt; SX</span>
<span class="sd">    sqrt(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sin(float x) -&gt; float</span>
<span class="sd">    sin(DM x) -&gt; DM</span>
<span class="sd">    sin(SX x) -&gt; SX</span>
<span class="sd">    sin(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    cos(float x) -&gt; float</span>
<span class="sd">    cos(DM x) -&gt; DM</span>
<span class="sd">    cos(SX x) -&gt; SX</span>
<span class="sd">    cos(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    tan(float x) -&gt; float</span>
<span class="sd">    tan(DM x) -&gt; DM</span>
<span class="sd">    tan(SX x) -&gt; SX</span>
<span class="sd">    tan(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">atan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    atan(float x) -&gt; float</span>
<span class="sd">    atan(DM x) -&gt; DM</span>
<span class="sd">    atan(SX x) -&gt; SX</span>
<span class="sd">    atan(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">asin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    asin(float x) -&gt; float</span>
<span class="sd">    asin(DM x) -&gt; DM</span>
<span class="sd">    asin(SX x) -&gt; SX</span>
<span class="sd">    asin(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">acos</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    acos(float x) -&gt; float</span>
<span class="sd">    acos(DM x) -&gt; DM</span>
<span class="sd">    acos(SX x) -&gt; SX</span>
<span class="sd">    acos(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    tanh(float x) -&gt; float</span>
<span class="sd">    tanh(DM x) -&gt; DM</span>
<span class="sd">    tanh(SX x) -&gt; SX</span>
<span class="sd">    tanh(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sinh(float x) -&gt; float</span>
<span class="sd">    sinh(DM x) -&gt; DM</span>
<span class="sd">    sinh(SX x) -&gt; SX</span>
<span class="sd">    sinh(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    cosh(float x) -&gt; float</span>
<span class="sd">    cosh(DM x) -&gt; DM</span>
<span class="sd">    cosh(SX x) -&gt; SX</span>
<span class="sd">    cosh(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">atanh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    atanh(float x) -&gt; float</span>
<span class="sd">    atanh(DM x) -&gt; DM</span>
<span class="sd">    atanh(SX x) -&gt; SX</span>
<span class="sd">    atanh(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atanh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">asinh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    asinh(float x) -&gt; float</span>
<span class="sd">    asinh(DM x) -&gt; DM</span>
<span class="sd">    asinh(SX x) -&gt; SX</span>
<span class="sd">    asinh(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">asinh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">acosh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    acosh(float x) -&gt; float</span>
<span class="sd">    acosh(DM x) -&gt; DM</span>
<span class="sd">    acosh(SX x) -&gt; SX</span>
<span class="sd">    acosh(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">acosh</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    exp(float x) -&gt; float</span>
<span class="sd">    exp(DM x) -&gt; DM</span>
<span class="sd">    exp(SX x) -&gt; SX</span>
<span class="sd">    exp(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    log(float x) -&gt; float</span>
<span class="sd">    log(DM x) -&gt; DM</span>
<span class="sd">    log(SX x) -&gt; SX</span>
<span class="sd">    log(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    log10(float x) -&gt; float</span>
<span class="sd">    log10(DM x) -&gt; DM</span>
<span class="sd">    log10(SX x) -&gt; SX</span>
<span class="sd">    log10(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    floor(float x) -&gt; float</span>
<span class="sd">    floor(DM x) -&gt; DM</span>
<span class="sd">    floor(SX x) -&gt; SX</span>
<span class="sd">    floor(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    ceil(float x) -&gt; float</span>
<span class="sd">    ceil(DM x) -&gt; DM</span>
<span class="sd">    ceil(SX x) -&gt; SX</span>
<span class="sd">    ceil(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">erf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    erf(float x) -&gt; float</span>
<span class="sd">    erf(DM x) -&gt; DM</span>
<span class="sd">    erf(SX x) -&gt; SX</span>
<span class="sd">    erf(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">erfinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    erfinv(float x) -&gt; float</span>
<span class="sd">    erfinv(DM x) -&gt; DM</span>
<span class="sd">    erfinv(SX x) -&gt; SX</span>
<span class="sd">    erfinv(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">erfinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    sign(float x) -&gt; float</span>
<span class="sd">    sign(DM x) -&gt; DM</span>
<span class="sd">    sign(SX x) -&gt; SX</span>
<span class="sd">    sign(MX x) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    power(float x, float n) -&gt; float</span>
<span class="sd">    power(DM x, DM n) -&gt; DM</span>
<span class="sd">    power(SX x, SX n) -&gt; SX</span>
<span class="sd">    power(MX x, MX n) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mod</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    mod(float x, float y) -&gt; float</span>
<span class="sd">    mod(DM x, DM y) -&gt; DM</span>
<span class="sd">    mod(SX x, SX y) -&gt; SX</span>
<span class="sd">    mod(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    fmod(float x, float y) -&gt; float</span>
<span class="sd">    fmod(DM x, DM y) -&gt; DM</span>
<span class="sd">    fmod(SX x, SX y) -&gt; SX</span>
<span class="sd">    fmod(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    atan2(float x, float y) -&gt; float</span>
<span class="sd">    atan2(DM x, DM y) -&gt; DM</span>
<span class="sd">    atan2(SX x, SX y) -&gt; SX</span>
<span class="sd">    atan2(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    fmin(float x, float y) -&gt; float</span>
<span class="sd">    fmin(DM x, DM y) -&gt; DM</span>
<span class="sd">    fmin(SX x, SX y) -&gt; SX</span>
<span class="sd">    fmin(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    fmax(float x, float y) -&gt; float</span>
<span class="sd">    fmax(DM x, DM y) -&gt; DM</span>
<span class="sd">    fmax(SX x, SX y) -&gt; SX</span>
<span class="sd">    fmax(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplify an expression.</span>

<span class="sd">    simplify(float x) -&gt; float</span>
<span class="sd">    simplify(DM x) -&gt; DM</span>
<span class="sd">    simplify(SX x) -&gt; SX</span>
<span class="sd">    simplify(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    is_equal(float x, float y, int depth) -&gt; bool</span>
<span class="sd">    is_equal(DM x, DM y, int depth) -&gt; bool</span>
<span class="sd">    is_equal(SX x, SX y, int depth) -&gt; bool</span>
<span class="sd">    is_equal(MX x, MX y, int depth) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">copysign</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    copysign(float x, float y) -&gt; float</span>
<span class="sd">    copysign(DM x, DM y) -&gt; DM</span>
<span class="sd">    copysign(SX x, SX y) -&gt; SX</span>
<span class="sd">    copysign(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">constpow</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    constpow(float x, float y) -&gt; float</span>
<span class="sd">    constpow(DM x, DM y) -&gt; DM</span>
<span class="sd">    constpow(SX x, SX y) -&gt; SX</span>
<span class="sd">    constpow(MX x, MX y) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">constpow</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mpower</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix power x^n.</span>

<span class="sd">    mpower(DM x, DM n) -&gt; DM</span>
<span class="sd">    mpower(SX x, SX n) -&gt; SX</span>
<span class="sd">    mpower(MX x, MX n) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mpower</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mrdivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix divide (cf. slash &#39;/&#39; in MATLAB)</span>

<span class="sd">    mrdivide(DM x, DM y) -&gt; DM</span>
<span class="sd">    mrdivide(SX x, SX y) -&gt; SX</span>
<span class="sd">    mrdivide(MX x, MX y) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mrdivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mldivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix divide (cf. backslash &#39;\\&#39; in MATLAB)</span>

<span class="sd">    mldivide(DM x, DM y) -&gt; DM</span>
<span class="sd">    mldivide(SX x, SX y) -&gt; SX</span>
<span class="sd">    mldivide(MX x, MX y) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mldivide</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">symvar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get symbols present in expression.</span>

<span class="sd">      symvar(DM x) -&gt; [DM]</span>
<span class="sd">      symvar(SX x) -&gt; [SX]</span>
<span class="sd">      symvar(MX x) -&gt; [MX]</span>


<span class="sd">    Returned vector is ordered according to the order of variable()/parameter()</span>
<span class="sd">    calls used to create the variables</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">symvar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bilin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate bilinear form x^T A y.</span>

<span class="sd">    bilin(DM A, DM x, DM y) -&gt; DM</span>
<span class="sd">    bilin(SX A, SX x, SX y) -&gt; SX</span>
<span class="sd">    bilin(MX A, MX x, MX y) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">bilin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rank1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a rank-1 update to a matrix A Calculates A + 1/2 * alpha * x*y&#39;.</span>

<span class="sd">    rank1(DM A, DM alpha, DM x, DM y) -&gt; DM</span>
<span class="sd">    rank1(SX A, SX alpha, SX x, SX y) -&gt; SX</span>
<span class="sd">    rank1(MX A, MX alpha, MX x, MX y) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rank1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sumsqr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate sum of squares: sum_ij X_ij^2.</span>

<span class="sd">    sumsqr(DM X) -&gt; DM</span>
<span class="sd">    sumsqr(SX X) -&gt; SX</span>
<span class="sd">    sumsqr(MX X) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sumsqr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matlab&#39;s linspace command.</span>

<span class="sd">    linspace(DM a, DM b, int nsteps) -&gt; DM</span>
<span class="sd">    linspace(SX a, SX b, int nsteps) -&gt; SX</span>
<span class="sd">    linspace(MX a, MX b, int nsteps) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">interp1d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Performs 1d linear interpolation.</span>

<span class="sd">      interp1d([float] x, DM v, [float] xq, str mode, bool equidistant) -&gt; DM</span>
<span class="sd">      interp1d([float] x, SX v, [float] xq, str mode, bool equidistant) -&gt; SX</span>
<span class="sd">      interp1d([float] x, MX v, [float] xq, str mode, bool equidistant) -&gt; MX</span>


<span class="sd">    The data-points to be interpolated are given as (x[i], v[i]). xq[j] is used</span>
<span class="sd">    as interplating value</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">soc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Construct second-order-convex.</span>

<span class="sd">      soc(DM x, DM y) -&gt; DM</span>
<span class="sd">      soc(SX x, SX y) -&gt; SX</span>
<span class="sd">      soc(MX x, MX y) -&gt; MX</span>


<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    x:  vector expression of size n</span>

<span class="sd">    y:  scalar expression</span>

<span class="sd">    soc(x,y) computes [y*eye(n) x; x&#39; y]</span>

<span class="sd">    soc(x,y) positive semi definite &lt;=&gt; || x ||_2 &lt;= y</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">soc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matlab&#39;s cross command.</span>

<span class="sd">    cross(DM a, DM b, int dim) -&gt; DM</span>
<span class="sd">    cross(SX a, SX b, int dim) -&gt; SX</span>
<span class="sd">    cross(MX a, MX b, int dim) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a skew symmetric matrix from a 3-vector.</span>

<span class="sd">    skew(DM a) -&gt; DM</span>
<span class="sd">    skew(SX a) -&gt; SX</span>
<span class="sd">    skew(MX a) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">inv_skew</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the 3-vector progenitor of a skew symmetric matrix.</span>

<span class="sd">    inv_skew(DM a) -&gt; DM</span>
<span class="sd">    inv_skew(SX a) -&gt; SX</span>
<span class="sd">    inv_skew(MX a) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">inv_skew</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix determinant (experimental)</span>

<span class="sd">    det(DM A) -&gt; DM</span>
<span class="sd">    det(SX A) -&gt; SX</span>
<span class="sd">    det(MX A) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">inv_minor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix inverse (experimental)</span>

<span class="sd">    inv_minor(DM A) -&gt; DM</span>
<span class="sd">    inv_minor(SX A) -&gt; SX</span>
<span class="sd">    inv_minor(MX A) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">inv_minor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix inverse.</span>

<span class="sd">    inv(DM A) -&gt; DM</span>
<span class="sd">    inv(SX A) -&gt; SX</span>
<span class="sd">    inv(MX A) -&gt; MX</span>
<span class="sd">    inv(DM A, str lsolver, dict opts) -&gt; DM</span>
<span class="sd">    inv(SX A, str lsolver, dict opts) -&gt; SX</span>
<span class="sd">    inv(MX A, str lsolver, dict opts) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix trace.</span>

<span class="sd">    trace(DM a) -&gt; DM</span>
<span class="sd">    trace(SX a) -&gt; SX</span>
<span class="sd">    trace(MX a) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tril2symm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a lower triangular matrix to a symmetric one.</span>

<span class="sd">    tril2symm(DM a) -&gt; DM</span>
<span class="sd">    tril2symm(SX a) -&gt; SX</span>
<span class="sd">    tril2symm(MX a) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tril2symm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">triu2symm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a upper triangular matrix to a symmetric one.</span>

<span class="sd">    triu2symm(DM a) -&gt; DM</span>
<span class="sd">    triu2symm(SX a) -&gt; SX</span>
<span class="sd">    triu2symm(MX a) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">triu2symm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">norm_fro</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Frobenius norm.</span>

<span class="sd">    norm_fro(DM x) -&gt; DM</span>
<span class="sd">    norm_fro(SX x) -&gt; SX</span>
<span class="sd">    norm_fro(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">norm_fro</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">norm_2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2-norm</span>

<span class="sd">    norm_2(DM x) -&gt; DM</span>
<span class="sd">    norm_2(SX x) -&gt; SX</span>
<span class="sd">    norm_2(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">norm_2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">norm_1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1-norm</span>

<span class="sd">    norm_1(DM x) -&gt; DM</span>
<span class="sd">    norm_1(SX x) -&gt; SX</span>
<span class="sd">    norm_1(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">norm_1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">norm_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infinity-norm.</span>

<span class="sd">    norm_inf(DM x) -&gt; DM</span>
<span class="sd">    norm_inf(SX x) -&gt; SX</span>
<span class="sd">    norm_inf(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">norm_inf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inner product of two matrices with x and y matrices of the same dimension.</span>

<span class="sd">    dot(DM x, DM y) -&gt; DM</span>
<span class="sd">    dot(SX x, SX y) -&gt; SX</span>
<span class="sd">    dot(MX x, MX y) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nullspace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Computes the nullspace of a matrix A.</span>

<span class="sd">      nullspace(DM A) -&gt; DM</span>
<span class="sd">      nullspace(SX A) -&gt; SX</span>
<span class="sd">      nullspace(MX A) -&gt; MX</span>


<span class="sd">    Finds Z m-by-(m-n) such that AZ = 0 with A n-by-m with m &gt; n</span>

<span class="sd">    Assumes A is full rank</span>

<span class="sd">    Inspired by Numerical Methods in Scientific Computing by Ake Bjorck</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">nullspace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">polyval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a polynomial with coefficients p in x.</span>

<span class="sd">    polyval(DM p, DM x) -&gt; DM</span>
<span class="sd">    polyval(SX p, SX x) -&gt; SX</span>
<span class="sd">    polyval(MX p, MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create diagonal sparsity pattern.</span>

<span class="sd">    diag(DM A) -&gt; DM</span>
<span class="sd">    diag(SX A) -&gt; SX</span>
<span class="sd">    diag(MX A) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unite</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Union of two sparsity patterns.</span>

<span class="sd">    unite(DM A, DM B) -&gt; DM</span>
<span class="sd">    unite(SX A, SX B) -&gt; SX</span>
<span class="sd">    unite(MX A, MX B) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">unite</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">densify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make the matrix dense and assign nonzeros to a value.</span>

<span class="sd">    densify(DM x) -&gt; DM</span>
<span class="sd">    densify(SX x) -&gt; SX</span>
<span class="sd">    densify(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">densify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a new matrix with a given sparsity pattern but with the nonzeros</span>

<span class="sd">      project(DM A, Sparsity sp, bool intersect) -&gt; DM</span>
<span class="sd">      project(SX A, Sparsity sp, bool intersect) -&gt; SX</span>
<span class="sd">      project(MX A, Sparsity sp, bool intersect) -&gt; MX</span>

<span class="sd">    taken from an existing matrix.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">if_else</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Branching on MX nodes Ternary operator, &quot;cond ? if_true : if_false&quot;.</span>

<span class="sd">    if_else(DM cond, DM if_true, DM if_false, bool short_circuit) -&gt; DM</span>
<span class="sd">    if_else(SX cond, SX if_true, SX if_false, bool short_circuit) -&gt; SX</span>
<span class="sd">    if_else(MX cond, MX if_true, MX if_false, bool short_circuit) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a switch.</span>

<span class="sd">      conditional(DM ind, [DM] x, DM x_default, bool short_circuit) -&gt; DM</span>
<span class="sd">      conditional(SX ind, [SX] x, SX x_default, bool short_circuit) -&gt; SX</span>
<span class="sd">      conditional(MX ind, [MX] x, MX x_default, bool short_circuit) -&gt; MX</span>


<span class="sd">    If the condition</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    ind:  evaluates to the integer k, where 0&lt;=k&lt;f.size(), then x[k] will be</span>
<span class="sd">    returned, otherwise</span>

<span class="sd">    x_default:  will be returned.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">depends_on</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if expression depends on the argument The argument must be symbolic.</span>

<span class="sd">    depends_on(DM f, DM arg) -&gt; bool</span>
<span class="sd">    depends_on(SX f, SX arg) -&gt; bool</span>
<span class="sd">    depends_on(MX f, MX arg) -&gt; bool</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">depends_on</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the QP.</span>

<span class="sd">    solve(DM A, DM b) -&gt; DM</span>
<span class="sd">    solve(SX A, SX b) -&gt; SX</span>
<span class="sd">    solve(MX A, MX b) -&gt; MX</span>
<span class="sd">    solve(DM A, DM b, str lsolver, dict opts) -&gt; DM</span>
<span class="sd">    solve(SX A, SX b, str lsolver, dict opts) -&gt; SX</span>
<span class="sd">    solve(MX A, MX b, str lsolver, dict opts) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Computes the Moore-Penrose pseudo-inverse.</span>

<span class="sd">      pinv(DM A) -&gt; DM</span>
<span class="sd">      pinv(SX A) -&gt; SX</span>
<span class="sd">      pinv(MX A) -&gt; MX</span>
<span class="sd">      pinv(DM A, str lsolver, dict opts) -&gt; DM</span>
<span class="sd">      pinv(SX A, str lsolver, dict opts) -&gt; SX</span>
<span class="sd">      pinv(MX A, str lsolver, dict opts) -&gt; MX</span>


<span class="sd">    If the matrix A is fat (size1&gt;size2), mul(A, pinv(A)) is unity. If the</span>
<span class="sd">    matrix A is slender (size2&lt;size1), mul(pinv(A), A) is unity.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">expm_const</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    expm_const(DM A, DM t) -&gt; DM</span>
<span class="sd">    expm_const(SX A, SX t) -&gt; SX</span>
<span class="sd">    expm_const(MX A, MX t) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">expm_const</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    expm(DM A) -&gt; DM</span>
<span class="sd">    expm(SX A) -&gt; SX</span>
<span class="sd">    expm(MX A) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Jacobian.</span>

<span class="sd">    jacobian(DM ex, DM arg, dict opts) -&gt; DM</span>
<span class="sd">    jacobian(SX ex, SX arg, dict opts) -&gt; SX</span>
<span class="sd">    jacobian(MX ex, MX arg, dict opts) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">jtimes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Calculate the Jacobian and multiply by a vector from the right This is</span>

<span class="sd">      jtimes(DM ex, DM arg, DM v, bool tr) -&gt; DM</span>
<span class="sd">      jtimes(SX ex, SX arg, SX v, bool tr) -&gt; SX</span>
<span class="sd">      jtimes(MX ex, MX arg, MX v, bool tr) -&gt; MX</span>

<span class="sd">    equivalent to mul(jacobian(ex, arg), v) or mul(jacobian(ex, arg).T, v) for</span>
<span class="sd">    tr set to false and true respectively. If contrast to these expressions, it</span>
<span class="sd">    will use directional derivatives which is typically (but not necessarily)</span>
<span class="sd">    more efficient if the complete Jacobian is not needed and v has few rows.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">jtimes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linearize an expression.</span>

<span class="sd">    linearize(DM f, DM x, DM x0) -&gt; DM</span>
<span class="sd">    linearize(SX f, SX x, SX x0) -&gt; SX</span>
<span class="sd">    linearize(MX f, MX x, MX x0) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">which_depends</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; bool,std::allocator&lt; bool &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find out which variables enter with some order.</span>

<span class="sd">    which_depends(DM expr, DM var, int order, bool tr) -&gt; [bool]</span>
<span class="sd">    which_depends(SX expr, SX var, int order, bool tr) -&gt; [bool]</span>
<span class="sd">    which_depends(MX expr, MX var, int order, bool tr) -&gt; [bool]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">which_depends</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Is expr linear in var?</span>

<span class="sd">      is_linear(DM expr, DM var) -&gt; bool</span>
<span class="sd">      is_linear(SX expr, SX var) -&gt; bool</span>
<span class="sd">      is_linear(MX expr, MX var) -&gt; bool</span>


<span class="sd">    False negatives are possible (an expression may not be recognised as linear</span>
<span class="sd">    while it really is), false positives not.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">is_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_quadratic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Is expr quadratic in var?</span>

<span class="sd">      is_quadratic(DM expr, DM var) -&gt; bool</span>
<span class="sd">      is_quadratic(SX expr, SX var) -&gt; bool</span>
<span class="sd">      is_quadratic(MX expr, MX var) -&gt; bool</span>


<span class="sd">    False negatives are possible (an expression may not be recognised as</span>
<span class="sd">    quadratic while it really is), false positives not.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">is_quadratic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Jacobian.</span>

<span class="sd">    gradient(DM ex, DM arg) -&gt; DM</span>
<span class="sd">    gradient(SX ex, SX arg) -&gt; SX</span>
<span class="sd">    gradient(MX ex, MX arg) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">tangent</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Jacobian.</span>

<span class="sd">    tangent(DM ex, DM arg) -&gt; DM</span>
<span class="sd">    tangent(SX ex, SX arg) -&gt; SX</span>
<span class="sd">    tangent(MX ex, MX arg) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">tangent</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    hessian(DM ex, DM arg) -&gt; (DM , DM OUTPUT1)</span>
<span class="sd">    hessian(SX ex, SX arg) -&gt; (SX , SX OUTPUT1)</span>
<span class="sd">    hessian(MX ex, MX arg) -&gt; (MX , MX OUTPUT1)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quadratic_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Recognizes quadratic form in scalar expression.</span>

<span class="sd">      quadratic_coeff(DM ex, DM arg, bool check) -&gt; (DM OUTPUT1, DM OUTPUT2, DM OUTPUT3)</span>
<span class="sd">      quadratic_coeff(SX ex, SX arg, bool check) -&gt; (SX OUTPUT1, SX OUTPUT2, SX OUTPUT3)</span>
<span class="sd">      quadratic_coeff(MX ex, MX arg, bool check) -&gt; (MX OUTPUT1, MX OUTPUT2, MX OUTPUT3)</span>


<span class="sd">    1/2*x&#39; A x + b&#39; x + c</span>

<span class="sd">    e = 0.5*bilin(A,x,x)+dot(b,x)+c</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    check[in]:  When true (default), A is checked to be independent of x.</span>
<span class="sd">    Provided to deal with false positive dependency checks.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">quadratic_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Recognizes linear form in vector expression.</span>

<span class="sd">      linear_coeff(DM ex, DM arg, bool check) -&gt; (DM OUTPUT1, DM OUTPUT2)</span>
<span class="sd">      linear_coeff(SX ex, SX arg, bool check) -&gt; (SX OUTPUT1, SX OUTPUT2)</span>
<span class="sd">      linear_coeff(MX ex, MX arg, bool check) -&gt; (MX OUTPUT1, MX OUTPUT2)</span>


<span class="sd">    A x + b</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    check[in]:  When true (default)m, A is checked to be independent of x.</span>
<span class="sd">    Provided to deal with false positive dependency checks.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">linear_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    n_nodes(DM A) -&gt; int</span>
<span class="sd">    n_nodes(SX A) -&gt; int</span>
<span class="sd">    n_nodes(MX A) -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">print_operator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a string representation for a binary MatType, using custom arguments.</span>

<span class="sd">    print_operator(DM xb, [str] args) -&gt; str</span>
<span class="sd">    print_operator(SX xb, [str] args) -&gt; str</span>
<span class="sd">    print_operator(MX xb, [str] args) -&gt; str</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">print_operator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">repsum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a repeated matrix, computes the sum of repeated parts.</span>

<span class="sd">    repsum(DM A, int n, int m) -&gt; DM</span>
<span class="sd">    repsum(SX A, int n, int m) -&gt; SX</span>
<span class="sd">    repsum(MX A, int n, int m) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">repsum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns difference (n-th order) along given axis (MATLAB convention)</span>

<span class="sd">    diff(DM A, int n, int axis) -&gt; DM</span>
<span class="sd">    diff(SX A, int n, int axis) -&gt; SX</span>
<span class="sd">    diff(MX A, int n, int axis) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns cumulative sum along given axis (MATLAB convention)</span>

<span class="sd">    cumsum(DM A, int axis) -&gt; DM</span>
<span class="sd">    cumsum(SX A, int axis) -&gt; SX</span>
<span class="sd">    cumsum(MX A, int axis) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">einstein</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Computes an einstein dense tensor contraction.</span>

<span class="sd">      einstein(DM A, DM B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; DM</span>
<span class="sd">      einstein(SX A, SX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; SX</span>
<span class="sd">      einstein(MX A, MX B, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; MX</span>
<span class="sd">      einstein(DM A, DM B, DM C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; DM</span>
<span class="sd">      einstein(SX A, SX B, SX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; SX</span>
<span class="sd">      einstein(MX A, MX B, MX C, [int] dim_a, [int] dim_b, [int] dim_c, [int] a, [int] b, [int] c) -&gt; MX</span>


<span class="sd">    Computes the product: C_c = A_a + B_b where a b c are index/einstein</span>
<span class="sd">    notation in an encoded form</span>

<span class="sd">    For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj</span>

<span class="sd">    The encoded form uses strictly negative numbers to indicate labels. For the</span>
<span class="sd">    above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">einstein</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mmin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smallest element in a matrix.</span>

<span class="sd">    mmin(DM x) -&gt; DM</span>
<span class="sd">    mmin(SX x) -&gt; SX</span>
<span class="sd">    mmin(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mmin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mmax</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Largest element in a matrix.</span>

<span class="sd">    mmax(DM x) -&gt; DM</span>
<span class="sd">    mmax(SX x) -&gt; SX</span>
<span class="sd">    mmax(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mmax</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DM&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Evaluates the expression numerically.</span>

<span class="sd">      evalf(DM x) -&gt; DM</span>
<span class="sd">      evalf(SX x) -&gt; DM</span>
<span class="sd">      evalf(MX x) -&gt; DM</span>


<span class="sd">    An error is raised when the expression contains symbols</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Forward directional derivative.</span>

<span class="sd">    forward([DM] ex, [DM] arg, [[DM]] v, dict opts) -&gt; [[DM]]</span>
<span class="sd">    forward([SX] ex, [SX] arg, [[SX]] v, dict opts) -&gt; [[SX]]</span>
<span class="sd">    forward([MX] ex, [MX] arg, [[MX]] v, dict opts) -&gt; [[MX]]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;,std::allocator&lt; std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse directional derivative.</span>

<span class="sd">    reverse([DM] ex, [DM] arg, [[DM]] v, dict opts) -&gt; [[DM]]</span>
<span class="sd">    reverse([SX] ex, [SX] arg, [[SX]] v, dict opts) -&gt; [[SX]]</span>
<span class="sd">    reverse([MX] ex, [MX] arg, [[MX]] v, dict opts) -&gt; [[MX]]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substitute variable var with expression expr in multiple expressions.</span>

<span class="sd">    substitute(DM ex, DM v, DM vdef) -&gt; DM</span>
<span class="sd">    substitute([DM] ex, [DM] v, [DM] vdef) -&gt; [DM]</span>
<span class="sd">    substitute(SX ex, SX v, SX vdef) -&gt; SX</span>
<span class="sd">    substitute([SX] ex, [SX] v, [SX] vdef) -&gt; [SX]</span>
<span class="sd">    substitute(MX ex, MX v, MX vdef) -&gt; MX</span>
<span class="sd">    substitute([MX] ex, [MX] v, [MX] vdef) -&gt; [MX]</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">substitute_inplace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &amp;, std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Inplace substitution with piggyback expressions Substitute variables v out</span>

<span class="sd">      substitute_inplace([DM] v, bool reverse) -&gt; ([DM] INOUT1, [DM] INOUT2)</span>
<span class="sd">      substitute_inplace([SX] v, bool reverse) -&gt; ([SX] INOUT1, [SX] INOUT2)</span>
<span class="sd">      substitute_inplace([MX] v, bool reverse) -&gt; ([MX] INOUT1, [MX] INOUT2)</span>

<span class="sd">    of the expressions vdef sequentially, as well as out of a number of other</span>
<span class="sd">    expressions piggyback.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">substitute_inplace</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">shared</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &amp;, std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &amp;, std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a shared (owning) reference.</span>

<span class="sd">    shared([DM] ex, str v_prefix, str v_suffix) -&gt; ([DM] OUTPUT1, [DM] OUTPUT2, [DM] OUTPUT3)</span>
<span class="sd">    shared([SX] ex, str v_prefix, str v_suffix) -&gt; ([SX] OUTPUT1, [SX] OUTPUT2, [SX] OUTPUT3)</span>
<span class="sd">    shared([MX] ex, str v_prefix, str v_suffix) -&gt; ([MX] OUTPUT1, [MX] OUTPUT2, [MX] OUTPUT3)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">blockcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    blockcat([[DM]] v) -&gt; DM</span>
<span class="sd">    blockcat([[SX]] v) -&gt; SX</span>
<span class="sd">    blockcat([[MX]] v) -&gt; MX</span>
<span class="sd">    blockcat(Sparsity A, Sparsity B, Sparsity C, Sparsity D) -&gt; Sparsity</span>
<span class="sd">    blockcat(DM A, DM B, DM C, DM D) -&gt; DM</span>
<span class="sd">    blockcat(SX A, SX B, SX C, SX D) -&gt; SX</span>
<span class="sd">    blockcat(MX A, MX B, MX C, MX D) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">blockcat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logic_all</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a vector of indices (nested slice)</span>

<span class="sd">    logic_all(DM x) -&gt; DM</span>
<span class="sd">    logic_all(SX x) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_all</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logic_any</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns true only if any element in the matrix is true.</span>

<span class="sd">    logic_any(DM x) -&gt; DM</span>
<span class="sd">    logic_any(SX x) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">logic_any</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">adj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix adjoint.</span>

<span class="sd">    adj(DM A) -&gt; DM</span>
<span class="sd">    adj(SX A) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">adj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">minor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the (i,j) minor matrix.</span>

<span class="sd">    minor(DM x, int i, int j) -&gt; DM</span>
<span class="sd">    minor(SX x, int i, int j) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cofactor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the (i,j) cofactor matrix.</span>

<span class="sd">    cofactor(DM x, int i, int j) -&gt; DM</span>
<span class="sd">    cofactor(SX x, int i, int j) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">cofactor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">qr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      QR factorization using the modified Gram-Schmidt algorithm More stable than</span>

<span class="sd">      qr(DM A) -&gt; (DM OUTPUT1, DM OUTPUT2)</span>
<span class="sd">      qr(SX A) -&gt; (SX OUTPUT1, SX OUTPUT2)</span>

<span class="sd">    the classical Gram-Schmidt, but may break down if the rows of A are nearly</span>
<span class="sd">    linearly dependent See J. Demmel: Applied Numerical Linear Algebra</span>
<span class="sd">    (algorithm 3.1.). Note that in SWIG, Q and R are returned by value.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">qr_sparse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;, std::vector&lt; casadi_int &gt; &amp;, std::vector&lt; casadi_int &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Symbolic QR factorization Returns the sparsity pattern of V (compact</span>

<span class="sd">      qr_sparse(DM A, bool amd) -&gt; (DM OUTPUT1, DM OUTPUT2, DM OUTPUT3, [int] OUTPUT4, [int] OUTPUT5)</span>
<span class="sd">      qr_sparse(SX A, bool amd) -&gt; (SX OUTPUT1, SX OUTPUT2, SX OUTPUT3, [int] OUTPUT4, [int] OUTPUT5)</span>

<span class="sd">    representation of Q) and R as well as vectors needed for the numerical</span>
<span class="sd">    factorization and solution. The implementation is a modified version of</span>
<span class="sd">    CSparse Copyright(c) Timothy A. Davis, 2006-2009 Licensed as a derivative</span>
<span class="sd">    work under the GNU LGPL.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">qr_sparse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">qr_solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve using a sparse QR factorization.</span>

<span class="sd">    qr_solve(DM b, DM v, DM r, DM beta, [int] prinv, [int] pc, bool tr) -&gt; DM</span>
<span class="sd">    qr_solve(SX b, SX v, SX r, SX beta, [int] prinv, [int] pc, bool tr) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">qr_solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ldl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;, std::vector&lt; casadi_int &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Symbolic LDL factorization Returns the sparsity pattern of L^T.</span>

<span class="sd">      ldl(DM A, bool amd) -&gt; (DM OUTPUT1, DM OUTPUT2, [int] OUTPUT3)</span>
<span class="sd">      ldl(SX A, bool amd) -&gt; (SX OUTPUT1, SX OUTPUT2, [int] OUTPUT3)</span>


<span class="sd">    The implementation is a modified version of LDL Copyright(c) Timothy A.</span>
<span class="sd">    Davis, 2005-2013 Licensed as a derivative work under the GNU LGPL</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ldl</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ldl_solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve using a sparse LDL^T factorization.</span>

<span class="sd">    ldl_solve(DM b, DM D, DM LT, [int] p) -&gt; DM</span>
<span class="sd">    ldl_solve(SX b, SX D, SX LT, [int] p) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ldl_solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">chol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Obtain a Cholesky factorisation of a matrix Performs and LDL transformation</span>

<span class="sd">      chol(DM A) -&gt; DM</span>
<span class="sd">      chol(SX A) -&gt; SX</span>

<span class="sd">    [L,D] = ldl(A) and returns diag(sqrt(D))*L&#39;.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">chol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">norm_inf_mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inf-norm of a Matrix-Matrix product.</span>

<span class="sd">    norm_inf_mul(DM x, DM y) -&gt; DM</span>
<span class="sd">    norm_inf_mul(SX x, SX y) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">norm_inf_mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sparsify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a matrix sparse by removing numerical zeros.</span>

<span class="sd">    sparsify(DM A, float tol) -&gt; DM</span>
<span class="sd">    sparsify(SX A, float tol) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">sparsify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt; &amp;, casadi::Matrix&lt; casadi::SXElem &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand the expression as a weighted sum (with constant weights)</span>

<span class="sd">    expand(DM ex) -&gt; (DM OUTPUT1, DM OUTPUT2)</span>
<span class="sd">    expand(SX ex) -&gt; (SX OUTPUT1, SX OUTPUT2)</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pw_const</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a piecewise constant function Create a piecewise constant function</span>

<span class="sd">      pw_const(DM t, DM tval, DM val) -&gt; DM</span>
<span class="sd">      pw_const(SX t, SX tval, SX val) -&gt; SX</span>

<span class="sd">    with n=val.size() intervals.</span>

<span class="sd">    Inputs:</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    t:  a scalar variable (e.g. time)</span>

<span class="sd">    tval:  vector with the discrete values of t at the interval transitions</span>
<span class="sd">    (length n-1)</span>

<span class="sd">    val:  vector with the value of the function for each interval (length n)</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">pw_const</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pw_lin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      t a scalar variable (e.g. time)</span>

<span class="sd">      pw_lin(DM t, DM tval, DM val) -&gt; DM</span>
<span class="sd">      pw_lin(SX t, SX tval, SX val) -&gt; SX</span>


<span class="sd">    Create a piecewise linear function Create a piecewise linear function:</span>

<span class="sd">    Inputs: tval vector with the the discrete values of t (monotonically</span>
<span class="sd">    increasing) val vector with the corresponding function values (same length</span>
<span class="sd">    as tval)</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">pw_lin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Heaviside function.</span>

<span class="sd">      heaviside(DM x) -&gt; DM</span>
<span class="sd">      heaviside(SX x) -&gt; SX</span>


<span class="sd">    \\[ \\begin {cases} H(x) = 0 &amp; x&lt;0 \\\\ H(x) = 1/2 &amp; x=0 \\\\</span>
<span class="sd">    H(x) = 1 &amp; x&gt;0 \\\\ \\end {cases} \\]</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">heaviside</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rectangle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      rectangle function</span>

<span class="sd">      rectangle(DM x) -&gt; DM</span>
<span class="sd">      rectangle(SX x) -&gt; SX</span>


<span class="sd">    \\[ \\begin {cases} \\Pi(x) = 1 &amp; |x| &lt; 1/2 \\\\ \\Pi(x) = 1/2 &amp;</span>
<span class="sd">    |x| = 1/2 \\\\ \\Pi(x) = 0 &amp; |x| &gt; 1/2 \\\\ \\end {cases} \\]</span>

<span class="sd">    Also called: gate function, block function, band function, pulse function,</span>
<span class="sd">    window function</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      triangle function</span>

<span class="sd">      triangle(DM x) -&gt; DM</span>
<span class="sd">      triangle(SX x) -&gt; SX</span>


<span class="sd">    \\[ \\begin {cases} \\Lambda(x) = 0 &amp; |x| &gt;= 1 \\\\ \\Lambda(x)</span>
<span class="sd">    = 1-|x| &amp; |x| &lt; 1 \\end {cases} \\]</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ramp</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      ramp function</span>

<span class="sd">      ramp(DM x) -&gt; DM</span>
<span class="sd">      ramp(SX x) -&gt; SX</span>


<span class="sd">    \\[ \\begin {cases} R(x) = 0 &amp; x &lt;= 1 \\\\ R(x) = x &amp; x &gt; 1 \\\\</span>
<span class="sd">    \\end {cases} \\]</span>

<span class="sd">    Also called: slope function</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ramp</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gauss_quadrature</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix adjoint.</span>

<span class="sd">    gauss_quadrature(DM f, DM x, DM a, DM b, int order) -&gt; DM</span>
<span class="sd">    gauss_quadrature(SX f, SX x, SX a, SX b, int order) -&gt; SX</span>
<span class="sd">    gauss_quadrature(DM f, DM x, DM a, DM b, int order, DM w) -&gt; DM</span>
<span class="sd">    gauss_quadrature(SX f, SX x, SX a, SX b, int order, SX w) -&gt; SX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">gauss_quadrature</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">taylor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      univariate Taylor series expansion</span>

<span class="sd">      taylor(DM ex, DM x, DM a, int order) -&gt; DM</span>
<span class="sd">      taylor(SX ex, SX x, SX a, int order) -&gt; SX</span>


<span class="sd">    Calculate the Taylor expansion of expression &#39;ex&#39; up to order &#39;order&#39; with</span>
<span class="sd">    respect to variable &#39;x&#39; around the point &#39;a&#39;</span>

<span class="sd">    $(x)=f(a)+f&#39;(a)(x-a)+f&#39;&#39;(a)\\frac</span>
<span class="sd">    {(x-a)^2}{2!}+f&#39;&#39;&#39;(a)\\frac{(x-a)^3}{3!}+\\ldots$</span>

<span class="sd">    Example usage:</span>

<span class="sd">    ::</span>

<span class="sd">    &gt;&gt;   x</span>






<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">taylor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mtaylor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      multivariate Taylor series expansion</span>

<span class="sd">      mtaylor(DM ex, DM x, DM a, int order) -&gt; DM</span>
<span class="sd">      mtaylor(SX ex, SX x, SX a, int order) -&gt; SX</span>
<span class="sd">      mtaylor(DM ex, DM x, DM a, int order, [int] order_contributions) -&gt; DM</span>
<span class="sd">      mtaylor(SX ex, SX x, SX a, int order, [int] order_contributions) -&gt; SX</span>


<span class="sd">    Do Taylor expansions until the aggregated order of a term is equal to</span>
<span class="sd">    &#39;order&#39;. The aggregated order of $x^n y^m$ equals $n+m$.</span>

<span class="sd">    The argument order_contributions can denote how match each variable</span>
<span class="sd">    contributes to the aggregated order. If x=[x, y] and order_contributions=[1,</span>
<span class="sd">    2], then the aggregated order of $x^n y^m$ equals $1n+2m$.</span>

<span class="sd">    Example usage</span>

<span class="sd">    $ \\sin(b+a)+\\cos(b+a)(x-a)+\\cos(b+a)(y-b) $ $ y+x-(x^3+3y x^2+3 y^2</span>
<span class="sd">    x+y^3)/6 $ $ (-3 x^2 y-x^3)/6+y+x $</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">mtaylor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">poly_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      extracts polynomial coefficients from an expression</span>

<span class="sd">      poly_coeff(DM ex, DM x) -&gt; DM</span>
<span class="sd">      poly_coeff(SX ex, SX x) -&gt; SX</span>


<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    ex:  Scalar expression that represents a polynomial</span>

<span class="sd">    x:  Scalar symbol that the polynomial is build up with</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">poly_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">poly_roots</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Attempts to find the roots of a polynomial.</span>

<span class="sd">      poly_roots(DM p) -&gt; DM</span>
<span class="sd">      poly_roots(SX p) -&gt; SX</span>


<span class="sd">    This will only work for polynomials up to order 3 It is assumed that the</span>
<span class="sd">    roots are real.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">poly_roots</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">eig_symbolic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Attempts to find the eigenvalues of a symbolic matrix This will only work</span>

<span class="sd">      eig_symbolic(DM m) -&gt; DM</span>
<span class="sd">      eig_symbolic(SX m) -&gt; SX</span>

<span class="sd">    for up to 3x3 matrices.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">eig_symbolic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get the location of all non-zero elements as they would appear in a Dense</span>

<span class="sd">      find(MX x) -&gt; MX</span>

<span class="sd">    matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-</span>
<span class="sd">    zeros.</span>

<span class="sd">    k = A.find() A[k] will contain the elements of A that are non-zero in B</span>

<span class="sd">    Inverse of nonzeros.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">low</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find first nonzero If failed, returns the number of rows.</span>

<span class="sd">    low(MX v, MX p, dict options) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">low</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">inv_node</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse node.</span>

<span class="sd">    inv_node(MX x) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">inv_node</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">matrix_expand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Expand MX graph to SXFunction call.</span>

<span class="sd">      matrix_expand(MX e, [MX] boundary, dict options) -&gt; MX</span>
<span class="sd">      matrix_expand([MX] e, [MX] boundary, dict options) -&gt; [MX]</span>


<span class="sd">    Expand the given expression e, optionally supplying expressions contained in</span>
<span class="sd">    it at which expansion should stop.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">matrix_expand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">graph_substitute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Substitute multiple expressions in graph Substitute variable var with</span>

<span class="sd">      graph_substitute(MX ex, [MX] v, [MX] vdef) -&gt; MX</span>
<span class="sd">      graph_substitute([MX] ex, [MX] v, [MX] vdef) -&gt; [MX]</span>

<span class="sd">    expression expr in multiple expressions, preserving nodes.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">graph_substitute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bspline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find first nonzero If failed, returns the number of rows.</span>

<span class="sd">    bspline(MX x, DM coeffs, [[float]] knots, [int] degree, int m, dict opts) -&gt; MX</span>
<span class="sd">    bspline(MX x, MX coeffs, [[float]] knots, [int] degree, int m, dict opts) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">bspline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convexify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find first nonzero If failed, returns the number of rows.</span>

<span class="sd">    convexify(MX H, dict opts) -&gt; MX</span>





<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">convexify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Importer</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Importer.</span>



<span class="sd">    Just-in-time compilation of code</span>

<span class="sd">    General information</span>
<span class="sd">    ===================</span>



<span class="sd">    List of plugins</span>
<span class="sd">    ===============</span>



<span class="sd">    - clang</span>

<span class="sd">    - shell</span>

<span class="sd">    Note: some of the plugins in this list might not be available on your</span>
<span class="sd">    system. Also, there might be extra plugins available to you that are not</span>
<span class="sd">    listed here. You can obtain their documentation with</span>
<span class="sd">    Importer.doc(&quot;myextraplugin&quot;)</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    clang</span>
<span class="sd">    -----</span>



<span class="sd">    Interface to the JIT compiler CLANG</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +--------------+-----------------+-----------------------------------------+</span>
<span class="sd">    |      Id      |      Type       |               Description               |</span>
<span class="sd">    +==============+=================+=========================================+</span>
<span class="sd">    | flags        | OT_STRINGVECTOR | Compile flags for the JIT compiler.     |</span>
<span class="sd">    |              |                 | Default: None                           |</span>
<span class="sd">    +--------------+-----------------+-----------------------------------------+</span>
<span class="sd">    | include_path | OT_STRING       | Include paths for the JIT compiler. The |</span>
<span class="sd">    |              |                 | include directory shipped with CasADi   |</span>
<span class="sd">    |              |                 | will be automatically appended.         |</span>
<span class="sd">    +--------------+-----------------+-----------------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    --------------------------------------------------------------------------------</span>

<span class="sd">    shell</span>
<span class="sd">    -----</span>



<span class="sd">    Interface to the JIT compiler SHELL</span>

<span class="sd">    &gt;List of available options</span>

<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    |          Id          |      Type       |           Description           |</span>
<span class="sd">    +======================+=================+=================================+</span>
<span class="sd">    | cleanup              | OT_BOOL         | Cleanup temporary files when    |</span>
<span class="sd">    |                      |                 | unloading. Default: true        |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | compiler             | OT_STRING       | Compiler command                |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | compiler_flags       | OT_STRINGVECTOR | Alias for &#39;compiler_flags&#39;      |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | compiler_output_flag | OT_STRING       | Compiler flag to denote object  |</span>
<span class="sd">    |                      |                 | output. Default: &#39;-o &#39;          |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | compiler_setup       | OT_STRING       | Compiler setup command.         |</span>
<span class="sd">    |                      |                 | Intended to be fixed. The       |</span>
<span class="sd">    |                      |                 | &#39;flag&#39; option is the prefered   |</span>
<span class="sd">    |                      |                 | way to set custom flags.        |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | extra_suffixes       | OT_STRINGVECTOR | List of suffixes for extra      |</span>
<span class="sd">    |                      |                 | files that the compiler may     |</span>
<span class="sd">    |                      |                 | generate. Default: None         |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | flags                | OT_STRINGVECTOR | Compile flags for the JIT       |</span>
<span class="sd">    |                      |                 | compiler. Default: None         |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | folder               | OT_STRING       | Folder to put temporary objects |</span>
<span class="sd">    |                      |                 | in.                             |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | linker               | OT_STRING       | Linker command                  |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | linker_flags         | OT_STRINGVECTOR | Linker flags for the JIT        |</span>
<span class="sd">    |                      |                 | compiler. Default: None         |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | linker_output_flag   | OT_STRING       | Linker flag to denote shared    |</span>
<span class="sd">    |                      |                 | library output. Default: &#39;-o &#39;  |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | linker_setup         | OT_STRING       | Linker setup command. Intended  |</span>
<span class="sd">    |                      |                 | to be fixed. The &#39;flag&#39; option  |</span>
<span class="sd">    |                      |                 | is the prefered way to set      |</span>
<span class="sd">    |                      |                 | custom flags.                   |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | name                 | OT_STRING       | The file name used to write out |</span>
<span class="sd">    |                      |                 | compiled objects/libraries. The |</span>
<span class="sd">    |                      |                 | actual file names used depend   |</span>
<span class="sd">    |                      |                 | on &#39;temp_suffix&#39; and include    |</span>
<span class="sd">    |                      |                 | extensions. Default:            |</span>
<span class="sd">    |                      |                 | &#39;tmp_casadi_compiler_shell&#39;     |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>
<span class="sd">    | temp_suffix          | OT_BOOL         | Use a temporary (seemingly      |</span>
<span class="sd">    |                      |                 | random) filename suffix for     |</span>
<span class="sd">    |                      |                 | file names. This is desired for |</span>
<span class="sd">    |                      |                 | thread-safety. This behaviour   |</span>
<span class="sd">    |                      |                 | may defeat caching compiler     |</span>
<span class="sd">    |                      |                 | wrappers. Default: true         |</span>
<span class="sd">    +----------------------+-----------------+---------------------------------+</span>

<span class="sd">    --------------------------------------------------------------------------------</span>



<span class="sd">    Joris Gillis</span>

<span class="sd">    C++ includes: importer.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Importer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Importer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        test_cast(casadi::SharedObjectInternal const * ptr) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">test_cast</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">test_cast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_plugin(str name) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">has_plugin</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">has_plugin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        load_plugin(str name)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">load_plugin</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">load_plugin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        doc(str name) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">doc</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plugin_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query plugin name.</span>

<span class="sd">        plugin_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_plugin_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_function(self, str symname) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_has_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does a meta entry exist?</span>

<span class="sd">        has_meta(self, str cmd, int ind) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_has_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get entry as a text.</span>

<span class="sd">        get_meta(self, str cmd, int ind) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">inlined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a function is inlined.</span>

<span class="sd">        inlined(self, str symname) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_inlined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the function body, if inlined.</span>

<span class="sd">        body(self, str symname) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_body</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get library name.</span>

<span class="sd">        library(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize an object.</span>

<span class="sd">        serialize(self, casadi::SerializingStream &amp; s)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Importer&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        deserialize(casadi::DeserializingStream &amp; s) -&gt; Importer</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">deserialize</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">deserialize</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          Importer()</span>
<span class="sd">          Importer(Importer other)</span>
<span class="sd">          Importer(str name, str compiler, dict opts)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Importer(Importer other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Importer(str name, str compiler, dict opts)</span>



<span class="sd">        Importer factory.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Importer()</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Importer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Importer</span>
<span class="n">Importer_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_swigregister</span>
<span class="n">Importer_swigregister</span><span class="p">(</span><span class="n">Importer</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Importer_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Importer_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    test_cast(casadi::SharedObjectInternal const * ptr) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_test_cast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Importer_has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    has_plugin(str name) -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_has_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Importer_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    load_plugin(str name)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Importer_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    doc(str name) -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Importer_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Importer&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    deserialize(casadi::DeserializingStream &amp; s) -&gt; Importer</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Importer_deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Callback</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Callback function functionality.</span>



<span class="sd">    This class provides a public API to the FunctionInternal class that can be</span>
<span class="sd">    subclassed by the user, who is then able to implement the different virtual</span>
<span class="sd">    method. Note that the Function class also provides a public API to</span>
<span class="sd">    FunctionInternal, but only allows calling, not being called.</span>

<span class="sd">    The user is responsible for not deleting this class for the lifetime of the</span>
<span class="sd">    internal function object.</span>

<span class="sd">    Joris Gillis, Joel Andersson</span>

<span class="sd">    C++ includes: callback.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Function</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Callback</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Function</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Callback</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Copy constructor (throws an error)</span>

<span class="sd">          Callback(self)</span>
<span class="sd">          Callback(self, Callback obj)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Callback(self)</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Callback(self, Callback obj)</span>



<span class="sd">        Copy constructor (throws an error)</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Callback</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Callback</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Callback</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Construct internal object This is the step that actually construct the</span>

<span class="sd">          construct(self, str name, dict opts)</span>

<span class="sd">        internal object, as the class constructor only creates a null pointer. It</span>
<span class="sd">        should be called from the user constructor.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Initialize the object This function is called after the object construction</span>

<span class="sd">          init(self)</span>

<span class="sd">        (for the whole class hierarchy) is complete, but before the finalization</span>
<span class="sd">        step. It is called recursively for the whole class hierarchy, starting with</span>
<span class="sd">        the lowest level.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Finalize the object This function is called after the construction and init</span>

<span class="sd">          finalize(self)</span>

<span class="sd">        steps are completed, but before user functions are called. It is called</span>
<span class="sd">        recursively for the whole class hierarchy, starting with the highest level.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::DM,std::allocator&lt; casadi::DM &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Evaluate numerically, using temporary matrices and work vectors.</span>

<span class="sd">          eval(self, [DM] arg) -&gt; [DM]</span>


<span class="sd">        This signature is not thread-safe. For guaranteed thread-safety, use</span>
<span class="sd">        eval_buffer</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">eval_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          A copy-free low level interface.</span>

<span class="sd">          eval_buffer(self, double const ** arg, [int] sizes_arg, double ** res, [int] sizes_res) -&gt; int</span>


<span class="sd">        In Python, you will be passed two tuples of memoryview objects</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_eval_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_eval_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        has_eval_buffer(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_has_eval_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_n_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of inputs This function is called during construction.</span>

<span class="sd">        get_n_in(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_n_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_n_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of outputs This function is called during construction.</span>

<span class="sd">        get_n_out(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_n_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_sparsity_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity of an input This function is called during construction.</span>

<span class="sd">        get_sparsity_in(self, int i) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_sparsity_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_sparsity_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity of an output This function is called during construction.</span>

<span class="sd">        get_sparsity_out(self, int i) -&gt; Sparsity</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_sparsity_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_name_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity of an input This function is called during construction.</span>

<span class="sd">        get_name_in(self, int i) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_name_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_name_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sparsity of an output This function is called during construction.</span>

<span class="sd">        get_name_out(self, int i) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_name_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">uses_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do the derivative functions need nondifferentiated outputs?</span>

<span class="sd">        uses_output(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_uses_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Jacobian of all input elements with respect to all output elements.</span>

<span class="sd">        has_jacobian(self) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_has_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Jacobian of all input elements with respect to all output elements.</span>

<span class="sd">        get_jacobian(self, str name, [str] inames, [str] onames, dict opts) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Return function that calculates forward derivatives forward(nfwd) returns a</span>

<span class="sd">          has_forward(self, int nfwd) -&gt; bool</span>

<span class="sd">        cached instance if available, and calls  Function get_forward(casadi_int</span>
<span class="sd">        nfwd) if no cached version is available.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_has_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Return function that calculates forward derivatives forward(nfwd) returns a</span>

<span class="sd">          get_forward(self, int nfwd, str name, [str] inames, [str] onames, dict opts) -&gt; Function</span>

<span class="sd">        cached instance if available, and calls  Function get_forward(casadi_int</span>
<span class="sd">        nfwd) if no cached version is available.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Return function that calculates adjoint derivatives reverse(nadj) returns a</span>

<span class="sd">          has_reverse(self, int nadj) -&gt; bool</span>

<span class="sd">        cached instance if available, and calls  Function get_reverse(casadi_int</span>
<span class="sd">        nadj) if no cached version is available.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_has_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Return function that calculates adjoint derivatives reverse(nadj) returns a</span>

<span class="sd">          get_reverse(self, int nadj, str name, [str] inames, [str] onames, dict opts) -&gt; Function</span>

<span class="sd">        cached instance if available, and calls  Function get_reverse(casadi_int</span>
<span class="sd">        nadj) if no cached version is available.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_jacobian_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Return sparsity of Jacobian of all input elements with respect to all output</span>

<span class="sd">          has_jacobian_sparsity(self) -&gt; bool</span>

<span class="sd">        elements.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_has_jacobian_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_jacobian_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Return sparsity of Jacobian of all input elements with respect to all output</span>

<span class="sd">          get_jacobian_sparsity(self) -&gt; Sparsity</span>

<span class="sd">        elements.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_get_jacobian_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_casadi</span><span class="o">.</span><span class="n">disown_Callback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="n">Callback_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_swigregister</span>
<span class="n">Callback_swigregister</span><span class="p">(</span><span class="n">Callback</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Callback_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Callback_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GlobalOptions</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Collects global CasADi options.</span>



<span class="sd">    Note to developers: use sparingly. Global options are - in general - a</span>
<span class="sd">    rather bad idea</span>

<span class="sd">    this class must never be instantiated. Access its static members directly</span>
<span class="sd">    Joris Gillis</span>

<span class="sd">    C++ includes: global_options.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GlobalOptions</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GlobalOptions</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">setSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        setSimplificationOnTheFly(bool flag)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">setSimplificationOnTheFly</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">setSimplificationOnTheFly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        getSimplificationOnTheFly() -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">getSimplificationOnTheFly</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">getSimplificationOnTheFly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        setHierarchicalSparsity(bool flag)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">setHierarchicalSparsity</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">setHierarchicalSparsity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        getHierarchicalSparsity() -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">getHierarchicalSparsity</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">getHierarchicalSparsity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        setCasadiPath(str path)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">setCasadiPath</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">setCasadiPath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        getCasadiPath() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">getCasadiPath</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">getCasadiPath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        setCasadiIncludePath(str path)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">setCasadiIncludePath</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">setCasadiIncludePath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        getCasadiIncludePath() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">getCasadiIncludePath</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">getCasadiIncludePath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        setMaxNumDir(int ndir)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">setMaxNumDir</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">setMaxNumDir</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        getMaxNumDir() -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">getMaxNumDir</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">getMaxNumDir</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        GlobalOptions(GlobalOptions other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_GlobalOptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_GlobalOptions</span>
<span class="n">GlobalOptions_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_swigregister</span>
<span class="n">GlobalOptions_swigregister</span><span class="p">(</span><span class="n">GlobalOptions</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_setSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    setSimplificationOnTheFly(bool flag)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_getSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    getSimplificationOnTheFly() -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getSimplificationOnTheFly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_setHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    setHierarchicalSparsity(bool flag)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_getHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    getHierarchicalSparsity() -&gt; bool</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getHierarchicalSparsity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_setCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    setCasadiPath(str path)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_getCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    getCasadiPath() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getCasadiPath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_setCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    setCasadiIncludePath(str path)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_getCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    getCasadiIncludePath() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getCasadiIncludePath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_setMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    setMaxNumDir(int ndir)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_setMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">GlobalOptions_getMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    getMaxNumDir() -&gt; int</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">GlobalOptions_getMaxNumDir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CasadiMeta</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Collects global CasADi meta information.</span>



<span class="sd">    Joris Gillis</span>

<span class="sd">    C++ includes: casadi_meta.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CasadiMeta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CasadiMeta</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        version() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_version</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">version</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">git_revision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        git_revision() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_git_revision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">git_revision</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">git_revision</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">git_describe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        git_describe() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_git_describe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">git_describe</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">git_describe</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">feature_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        feature_list() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_feature_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">feature_list</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">feature_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        build_type() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_build_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">build_type</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">build_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compiler_id</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        compiler_id() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_compiler_id</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">compiler_id</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">compiler_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compiler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        compiler() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_compiler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">compiler</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">compiler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compiler_flags</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        compiler_flags() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_compiler_flags</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">compiler_flags</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">compiler_flags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">modules</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        modules() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_modules</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">modules</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">modules</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plugins</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        plugins() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_plugins</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">plugins</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">plugins</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">install_prefix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        install_prefix() -&gt; char const *</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_install_prefix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">install_prefix</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">install_prefix</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        CasadiMeta(CasadiMeta other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_CasadiMeta</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_CasadiMeta</span>
<span class="n">CasadiMeta_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_swigregister</span>
<span class="n">CasadiMeta_swigregister</span><span class="p">(</span><span class="n">CasadiMeta</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_version</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    version() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_version</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_git_revision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    git_revision() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_git_revision</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_git_describe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    git_describe() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_git_describe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_feature_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    feature_list() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_feature_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_build_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    build_type() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_build_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_compiler_id</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    compiler_id() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_compiler_id</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_compiler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    compiler() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_compiler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_compiler_flags</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    compiler_flags() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_compiler_flags</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_modules</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    modules() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_modules</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_plugins</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    plugins() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_plugins</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CasadiMeta_install_prefix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;char const *&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    install_prefix() -&gt; char const *</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CasadiMeta_install_prefix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">collocation_points</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Obtain collocation points of specific order and scheme.</span>

<span class="sd">      collocation_points(int order, str scheme) -&gt; [float]</span>


<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    order:  Which order (1 to 9 supported)</span>

<span class="sd">    scheme:  &#39;radau&#39; or &#39;legendre&#39;</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">collocation_points</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">collocation_interpolators</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; double &gt; &gt; &amp;, std::vector&lt; double &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Obtain collocation interpolating matrices.</span>

<span class="sd">      collocation_interpolators([float] tau) -&gt; ([[float]] OUTPUT, [float] OUTPUT)</span>


<span class="sd">    A collocation method poses a polynomial Pi that interpolates exactly through</span>
<span class="sd">    an initial state (0,X_0) and helper states at collocation points</span>
<span class="sd">    (tau_j,X(j)).</span>

<span class="sd">    This function computes the linear mapping between dPi/dt and coefficients</span>
<span class="sd">    Z=[X_0 X].</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    tau:  location of collocation points, as obtained from collocation_points</span>

<span class="sd">    output_C:  interpolating coefficients to obtain derivatives. Length:</span>
<span class="sd">    order+1, order+1</span>



<span class="sd">    ::</span>

<span class="sd">    dPi/dt @Z_j = (1/h) Sum_i C[j][i]*Z_i,</span>



<span class="sd">    with h the length of the integration interval.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    output_D:  interpolating coefficients to obtain end state. Length: order+1</span>



<span class="sd">    ::</span>

<span class="sd">    Pi @X_f = Sum_i D[i]*Z_i</span>






<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">collocation_interpolators</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">collocation_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt; &amp;, casadi::Matrix&lt; double &gt; &amp;, casadi::Matrix&lt; double &gt; &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Obtain collocation interpolating matrices.</span>

<span class="sd">      collocation_coeff([float] tau) -&gt; (DM OUTPUT, DM OUTPUT, DM OUTPUT)</span>


<span class="sd">    A collocation method poses a polynomial Pi that interpolates exactly through</span>
<span class="sd">    an initial state (0,X_0) and helper states at collocation points</span>
<span class="sd">    (tau_j,Xc_j) with j=1..degree.</span>

<span class="sd">    This function computes the linear mapping between dPi/dt and coefficients</span>
<span class="sd">    Z=[X_0 Xc].</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    tau:  location of collocation points (length: degree), as obtained from</span>
<span class="sd">    collocation_points</span>

<span class="sd">    C:  interpolating coefficients to obtain derivatives. Size: (degree+1)-by-</span>
<span class="sd">    degree</span>

<span class="sd">    You may find the slopes of Pi at the collocation points as</span>

<span class="sd">    ::</span>

<span class="sd">    dPi/dt @ Xc = (1/h) Z*C,</span>



<span class="sd">    with h the length of the integration interval.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    D:  interpolating coefficients to obtain end state. Size: (degree+1)-by-1</span>

<span class="sd">    You may find the end point of Pi as</span>

<span class="sd">    ::</span>

<span class="sd">    Pi @X_f = Z*D</span>



<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    B:  quadrature coefficients Size: degree-by-1</span>

<span class="sd">    Given quadrature righ-hand-sides &#39;quad&#39; evaluated at the collocation points,</span>
<span class="sd">    you may find the integrated quadratures as</span>

<span class="sd">    ::</span>

<span class="sd">    q = quad*B*h</span>






<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">collocation_coeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="n">LEGENDRE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">LEGENDRE</span>
<span class="n">RADAU</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">RADAU</span>

<span class="k">def</span> <span class="nf">simpleRK</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Construct an explicit Runge-Kutta integrator The constructed function has</span>

<span class="sd">      simpleRK(Function f, int N, int order) -&gt; Function</span>

<span class="sd">    three inputs, corresponding to initial state (x0), parameter (p) and</span>
<span class="sd">    integration time (h) and one output, corresponding to final state (xf).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    f:  ODE function with two inputs (x and p) and one output (xdot)</span>

<span class="sd">    N:  Number of integrator steps</span>

<span class="sd">    order:  Order of interpolating polynomials</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">simpleRK</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">simpleIRK</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Construct an implicit Runge-Kutta integrator using a collocation scheme The</span>

<span class="sd">      simpleIRK(Function f, int N, int order, str scheme, str solver, dict solver_options) -&gt; Function</span>

<span class="sd">    constructed function has three inputs, corresponding to initial state (x0),</span>
<span class="sd">    parameter (p) and integration time (h) and one output, corresponding to</span>
<span class="sd">    final state (xf).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    f:  ODE function with two inputs (x and p) and one output (xdot)</span>

<span class="sd">    N:  Number of integrator steps</span>

<span class="sd">    order:  Order of interpolating polynomials</span>

<span class="sd">    scheme:   Collocation scheme, as excepted by collocationPoints function.</span>

<span class="sd">    solver:  Solver plugin</span>

<span class="sd">    solver_options:  Options to be passed to the solver plugin</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">simpleIRK</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">simpleIntegrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Simplified wrapper for the Integrator class Constructs an integrator using</span>

<span class="sd">      simpleIntegrator(Function f, str integrator, dict integrator_options) -&gt; Function</span>

<span class="sd">    the same syntax as simpleRK and simpleIRK. The constructed function has</span>
<span class="sd">    three inputs, corresponding to initial state (x0), parameter (p) and</span>
<span class="sd">    integration time (h) and one output, corresponding to final state (xf).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    f:  ODE function with two inputs (x and p) and one output (xdot)</span>

<span class="sd">    N:  Number of integrator steps</span>

<span class="sd">    order:  Order of interpolating polynomials</span>

<span class="sd">    scheme:   Collocation scheme, as excepted by collocationPoints function.</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">simpleIntegrator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">detect_simple_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int &gt; &amp;, casadi::MX &amp;, casadi::MX &amp;, casadi::Function &amp;, casadi::Function &amp;&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Detect simple bounds from general constraints.</span>

<span class="sd">      detect_simple_bounds(SX xX, SX p, SX g, SX lbg, SX ubg) -&gt; ([int] OUTPUT, SX OUTPUT, SX OUTPUT, Function OUTPUT, Function OUTPUT)</span>
<span class="sd">      detect_simple_bounds(MX xX, MX p, MX g, MX lbg, MX ubg) -&gt; ([int] OUTPUT, MX OUTPUT, MX OUTPUT, Function OUTPUT, Function OUTPUT)</span>


<span class="sd">    Given parametric constraints:</span>

<span class="sd">    ::</span>

<span class="sd">      *   subject to lbg(p) &lt;= g(x,p) &lt;= ubg(p)</span>
<span class="sd">      * </span>



<span class="sd">    Returns an equivalent set</span>

<span class="sd">    ::</span>

<span class="sd">      *   subject to  lbg(p)(gi) &lt;= g(x,p)(gi) &lt;= ubg(p)(gi)</span>
<span class="sd">      *               lbx(p) &lt;= x                 &lt;= ubx(p)</span>
<span class="sd">      * </span>



<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>

<span class="sd">    lam_forward:  (lam_g,p)-&gt;(lam_sg,lam_x)</span>

<span class="sd">    lam_backward:  (lam_sg,lam_x,p)-&gt;(lam_g)</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">detect_simple_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">NlpBuilder</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      A symbolic NLP representation.</span>



<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: nlp_builder.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NlpBuilder</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NlpBuilder</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_f_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_f_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_g_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_g_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;x_lb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_lb_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">x_lb</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_lb_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;x_ub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_ub_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">x_ub</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_ub_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;g_lb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_g_lb_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">g_lb</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_g_lb_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;g_ub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_g_ub_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">g_ub</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_g_ub_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;x_init&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_init_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">x_init</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_x_init_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lambda_init&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_lambda_init_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lambda_init</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_lambda_init_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;discrete&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_discrete_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">discrete</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_discrete_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">import_nl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import an .nl file.</span>

<span class="sd">        import_nl(self, str filename, dict opts)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_import_nl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Readable name of the class.</span>

<span class="sd">        type_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a description of the object.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        NlpBuilder()</span>
<span class="sd">        NlpBuilder(NlpBuilder other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_NlpBuilder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_NlpBuilder</span>
<span class="n">NlpBuilder_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NlpBuilder_swigregister</span>
<span class="n">NlpBuilder_swigregister</span><span class="p">(</span><span class="n">NlpBuilder</span><span class="p">)</span>

<span class="n">CONSTANT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CONSTANT</span>
<span class="n">PARAMETER</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">PARAMETER</span>
<span class="n">DISCRETE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DISCRETE</span>
<span class="n">CONTINUOUS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CONTINUOUS</span>
<span class="n">INPUT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">INPUT</span>
<span class="n">OUTPUT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OUTPUT</span>
<span class="n">INTERNAL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">INTERNAL</span>
<span class="n">ALGEBRAIC</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ALGEBRAIC</span>
<span class="n">DIFFERENTIAL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DIFFERENTIAL</span>
<span class="n">NO_ALIAS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NO_ALIAS</span>
<span class="n">ALIAS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">ALIAS</span>
<span class="n">NEGATED_ALIAS</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">NEGATED_ALIAS</span>
<span class="n">CAT_UNKNOWN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_UNKNOWN</span>
<span class="n">CAT_DERIVATIVE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_DERIVATIVE</span>
<span class="n">CAT_STATE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_STATE</span>
<span class="n">CAT_DEPENDENT_CONSTANT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_DEPENDENT_CONSTANT</span>
<span class="n">CAT_INDEPENDENT_CONSTANT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_INDEPENDENT_CONSTANT</span>
<span class="n">CAT_DEPENDENT_PARAMETER</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_DEPENDENT_PARAMETER</span>
<span class="n">CAT_INDEPENDENT_PARAMETER</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_INDEPENDENT_PARAMETER</span>
<span class="n">CAT_ALGEBRAIC</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">CAT_ALGEBRAIC</span>
<span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    Variable() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        name(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_v_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_v_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_d_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_d_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;nominal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_nominal_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">nominal</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_nominal_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_start_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_start_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_min_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_min_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_max_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_max_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;guess&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_guess_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">guess</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_guess_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;derivative_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_derivative_start_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">derivative_start</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_derivative_start_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;variability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_variability_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">variability</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_variability_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;causality&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_causality_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">causality</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_causality_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_category_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_category_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;alias&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_alias_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">alias</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_alias_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_description_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_description_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;valueReference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_valueReference_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">valueReference</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_valueReference_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_unit_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_unit_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;display_unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_display_unit_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">display_unit</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_display_unit_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;free&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_free_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_free_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        disp(self, bool more)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        str(self, bool more) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        Variable()</span>
<span class="sd">        Variable(Variable other)</span>
<span class="sd">        Variable(str name, Sparsity sp)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Variable</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Variable</span>
<span class="n">Variable_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Variable_swigregister</span>
<span class="n">Variable_swigregister</span><span class="p">(</span><span class="n">Variable</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DaeBuilder</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      An initial-value problem in differential-algebraic equations.</span>



<span class="sd">    Independent variables:</span>
<span class="sd">    ======================</span>





<span class="sd">    ::</span>

<span class="sd">      t:      time</span>




<span class="sd">    Time-continuous variables:</span>
<span class="sd">    ==========================</span>





<span class="sd">    ::</span>

<span class="sd">      x:      states defined by ODE</span>
<span class="sd">      s:      implicitly defined states</span>
<span class="sd">      z:      algebraic variables</span>
<span class="sd">      u:      control signals</span>
<span class="sd">      q:      quadrature states</span>
<span class="sd">      y:      outputs</span>




<span class="sd">    Time-constant variables:</span>
<span class="sd">    ========================</span>





<span class="sd">    ::</span>

<span class="sd">      p:      free parameters</span>
<span class="sd">      d:      dependent parameters</span>




<span class="sd">    Dynamic constraints (imposed everywhere):</span>
<span class="sd">    =========================================</span>





<span class="sd">    ::</span>

<span class="sd">      ODE                    \\dot{x} ==  ode(t, x, s, z, u, p, d)</span>
<span class="sd">      DAE or implicit ODE:         0 ==  dae(t, x, s, z, u, p, d, sdot)</span>
<span class="sd">      algebraic equations:         0 ==  alg(t, x, s, z, u, p, d)</span>
<span class="sd">      quadrature equations:  \\dot{q} == quad(t, x, s, z, u, p, d)</span>
<span class="sd">      dependent parameters:        d == ddef(t, x, s, z, u, p, d)</span>
<span class="sd">      output equations:            y == ydef(t, x, s, z, u, p, d)</span>




<span class="sd">    Point constraints (imposed pointwise):</span>
<span class="sd">    ======================================</span>





<span class="sd">    ::</span>

<span class="sd">      Initial equations:           0 == init(t, x, s, z, u, p, d, sdot)</span>




<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: dae_builder.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DaeBuilder</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DaeBuilder</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_t_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_t_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_x_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_x_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;ode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_ode_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">ode</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_ode_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_ode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_ode_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_ode</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_ode_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_s_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_s_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;sdot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_sdot_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">sdot</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_sdot_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;dae&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_dae_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">dae</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_dae_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_dae&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_dae_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_dae</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_dae_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_z_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_z_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;alg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_alg_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_alg_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_alg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_alg_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_alg</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_alg_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;q&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_q_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_q_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;quad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_quad_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">quad</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_quad_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_quad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_quad_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_quad</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_quad_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;w&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_w_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_w_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;wdef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_wdef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">wdef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_wdef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_wdef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_wdef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_wdef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_wdef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_y_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_y_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;ydef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_ydef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">ydef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_ydef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_ydef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_ydef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_ydef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_ydef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_u_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_u_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_p_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_p_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_c_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_c_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;cdef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_cdef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">cdef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_cdef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_d_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_d_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;ddef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_ddef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">ddef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_ddef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lam_ddef&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_ddef_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lam_ddef</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_lam_ddef_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_aux_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_aux_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;init&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_init_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_init_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new parameter</span>

<span class="sd">        add_p(self, str name, int n) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new control.</span>

<span class="sd">        add_u(self, str name, int n) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new differential state.</span>

<span class="sd">        add_x(self, str name, int n) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; casadi::MX,casadi::MX &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a implicit state.</span>

<span class="sd">        add_s(self, str name, int n) -&gt; (MX,MX)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new algebraic variable.</span>

<span class="sd">        add_z(self, str name, int n) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new quadrature state.</span>

<span class="sd">        add_q(self, str name, int n) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new dependent parameter.</span>

<span class="sd">        add_d(self, str name, MX new_ddef) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new output.</span>

<span class="sd">        add_y(self, str name, MX new_ydef) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an ordinary differential equation.</span>

<span class="sd">        add_ode(self, str name, MX new_ode)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_ode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_dae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a differential-algebraic equation.</span>

<span class="sd">        add_dae(self, str name, MX new_dae)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_dae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_alg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an algebraic equation.</span>

<span class="sd">        add_alg(self, str name, MX new_alg)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_alg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a quadrature equation.</span>

<span class="sd">        add_quad(self, str name, MX new_quad)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_aux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an auxiliary variable.</span>

<span class="sd">        add_aux(self, str name, int n) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_aux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if dimensions match.</span>

<span class="sd">        sanity_check(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">split_dae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify and separate the algebraic variables and equations in the DAE.</span>

<span class="sd">        split_dae(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_split_dae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">eliminate_alg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate algebraic variables and equations transforming them into outputs.</span>

<span class="sd">        eliminate_alg(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_eliminate_alg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">make_semi_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the implicit DAE to a semi-explicit DAE.</span>

<span class="sd">        make_semi_explicit(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_make_semi_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">make_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the implicit DAE or semi-explicit DAE into an explicit ODE.</span>

<span class="sd">        make_explicit(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_make_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sort_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort dependent parameters.</span>

<span class="sd">        sort_d(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_sort_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">split_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate interdependencies amongst dependent parameters.</span>

<span class="sd">        split_d(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_split_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">eliminate_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate dependent parameters.</span>

<span class="sd">        eliminate_d(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_eliminate_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">eliminate_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate quadrature states and turn them into ODE states.</span>

<span class="sd">        eliminate_quad(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_eliminate_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sort_dae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the DAE and implicitly defined states.</span>

<span class="sd">        sort_dae(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_sort_dae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sort_alg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the algebraic equations and algebraic states.</span>

<span class="sd">        sort_alg(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_sort_alg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">scale_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale the variables.</span>

<span class="sd">        scale_variables(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_scale_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">scale_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale the implicit equations.</span>

<span class="sd">        scale_equations(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_scale_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Add an external function.</span>

<span class="sd">          add_fun(self, Function f) -&gt; Function</span>
<span class="sd">          add_fun(self, str name, Importer compiler, dict opts) -&gt; Function</span>
<span class="sd">          add_fun(self, str name, [str] arg, [str] res, dict opts) -&gt; Function</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          add_fun(self, Function f)</span>



<span class="sd">        Add an already existing function.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          add_fun(self, str name, Importer compiler, dict opts)</span>



<span class="sd">        Add an external function.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          add_fun(self, str name, [str] arg, [str] res, dict opts)</span>



<span class="sd">        Add a function from loaded expressions.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">has_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does a particular function already exist?</span>

<span class="sd">        has_fun(self, str name) -&gt; bool</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_has_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get function by name.</span>

<span class="sd">        fun(self, str name) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">parse_fmi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import existing problem from FMI/XML</span>

<span class="sd">        parse_fmi(self, str filename)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_parse_fmi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_lc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a named linear combination of output expressions.</span>

<span class="sd">        add_lc(self, str name, [str] f_out) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_lc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a function object.</span>

<span class="sd">        create(self, str fname, [str] s_in, [str] s_out) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get variable expression by name.</span>

<span class="sd">        var(self, str name) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        __call__(self, str name) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder___call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a derivative expression by non-differentiated expression.</span>

<span class="sd">          der(self, MX var) -&gt; MX</span>
<span class="sd">          der(self, str name) -&gt; MX</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          der(self, str name)</span>



<span class="sd">        Get a derivative expression by name.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          der(self, MX var)</span>



<span class="sd">        Get a derivative expression by non-differentiated expression.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">nominal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the nominal value(s) by expression.</span>

<span class="sd">          nominal(self, MX var) -&gt; [float]</span>
<span class="sd">          nominal(self, str name) -&gt; float</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          nominal(self, MX var)</span>



<span class="sd">        Get the nominal value(s) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          nominal(self, str name)</span>



<span class="sd">        Get the nominal value by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_nominal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_nominal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the nominal value(s) by expression.</span>

<span class="sd">          set_nominal(self, MX var, [float] val)</span>
<span class="sd">          set_nominal(self, str name, float val)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_nominal(self, MX var, [float] val)</span>



<span class="sd">        Set the nominal value(s) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_nominal(self, str name, float val)</span>



<span class="sd">        Set the nominal value by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_nominal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the lower bound(s) by expression.</span>

<span class="sd">          min(self, MX var, bool normalized) -&gt; [float]</span>
<span class="sd">          min(self, str name, bool normalized) -&gt; float</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          min(self, MX var, bool normalized)</span>



<span class="sd">        Get the lower bound(s) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          min(self, str name, bool normalized)</span>



<span class="sd">        Get the lower bound by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the lower bound(s) by expression.</span>

<span class="sd">          set_min(self, MX var, [float] val, bool normalized)</span>
<span class="sd">          set_min(self, str name, float val, bool normalized)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_min(self, MX var, [float] val, bool normalized)</span>



<span class="sd">        Set the lower bound(s) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_min(self, str name, float val, bool normalized)</span>



<span class="sd">        Set the lower bound by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the upper bound(s) by expression.</span>

<span class="sd">          max(self, MX var, bool normalized) -&gt; [float]</span>
<span class="sd">          max(self, str name, bool normalized) -&gt; float</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          max(self, MX var, bool normalized)</span>



<span class="sd">        Get the upper bound(s) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          max(self, str name, bool normalized)</span>



<span class="sd">        Get the upper bound by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the upper bound(s) by expression.</span>

<span class="sd">          set_max(self, MX var, [float] val, bool normalized)</span>
<span class="sd">          set_max(self, str name, float val, bool normalized)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_max(self, MX var, [float] val, bool normalized)</span>



<span class="sd">        Set the upper bound(s) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_max(self, str name, float val, bool normalized)</span>



<span class="sd">        Set the upper bound by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the initial guess(es) by expression.</span>

<span class="sd">          guess(self, MX var, bool normalized) -&gt; [float]</span>
<span class="sd">          guess(self, str name, bool normalized) -&gt; float</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          guess(self, MX var, bool normalized)</span>



<span class="sd">        Get the initial guess(es) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          guess(self, str name, bool normalized)</span>



<span class="sd">        Get the initial guess by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the initial guess(es) by expression.</span>

<span class="sd">          set_guess(self, MX var, [float] val, bool normalized)</span>
<span class="sd">          set_guess(self, str name, float val, bool normalized)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_guess(self, MX var, [float] val, bool normalized)</span>



<span class="sd">        Set the initial guess(es) by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_guess(self, str name, float val, bool normalized)</span>



<span class="sd">        Set the initial guess by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the (optionally normalized) value(s) at time 0 by expression.</span>

<span class="sd">          start(self, MX var, bool normalized) -&gt; [float]</span>
<span class="sd">          start(self, str name, bool normalized) -&gt; float</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          start(self, MX var, bool normalized)</span>



<span class="sd">        Get the (optionally normalized) value(s) at time 0 by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          start(self, str name, bool normalized)</span>



<span class="sd">        Get the (optionally normalized) value at time 0 by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the (optionally normalized) value(s) at time 0 by expression.</span>

<span class="sd">          set_start(self, MX var, [float] val, bool normalized)</span>
<span class="sd">          set_start(self, str name, float val, bool normalized)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_start(self, MX var, [float] val, bool normalized)</span>



<span class="sd">        Set the (optionally normalized) value(s) at time 0 by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_start(self, str name, float val, bool normalized)</span>



<span class="sd">        Set the (optionally normalized) value at time 0 by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">derivative_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the (optionally normalized) derivative value(s) at time 0 by expression.</span>

<span class="sd">          derivative_start(self, MX var, bool normalized) -&gt; [float]</span>
<span class="sd">          derivative_start(self, str name, bool normalized) -&gt; float</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          derivative_start(self, MX var, bool normalized)</span>



<span class="sd">        Get the (optionally normalized) derivative value(s) at time 0 by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          derivative_start(self, str name, bool normalized)</span>



<span class="sd">        Get the (optionally normalized) derivative value at time 0 by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_derivative_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_derivative_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set the (optionally normalized) derivative value(s) at time 0 by expression.</span>

<span class="sd">          set_derivative_start(self, MX var, [float] val, bool normalized)</span>
<span class="sd">          set_derivative_start(self, str name, float val, bool normalized)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_derivative_start(self, MX var, [float] val, bool normalized)</span>



<span class="sd">        Set the (optionally normalized) derivative value(s) at time 0 by expression.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          set_derivative_start(self, str name, float val, bool normalized)</span>



<span class="sd">        Set the (optionally normalized) derivative value at time 0 by name.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_derivative_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get the unit given a vector of symbolic variables (all units must be</span>

<span class="sd">          unit(self, MX var) -&gt; str</span>
<span class="sd">          unit(self, str name) -&gt; str</span>

<span class="sd">        identical)</span>



<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          unit(self, MX var)</span>



<span class="sd">        Get the unit given a vector of symbolic variables (all units must be</span>
<span class="sd">        identical)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          unit(self, str name)</span>



<span class="sd">        Get the unit for a component.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the unit for a component.</span>

<span class="sd">        set_unit(self, str name, str val)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Readable name of the class.</span>

<span class="sd">        type_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print representation.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Add a new variable: returns corresponding symbolic expression.</span>

<span class="sd">          add_variable(self, str name, int n) -&gt; MX</span>
<span class="sd">          add_variable(self, str name, Variable var)</span>
<span class="sd">          add_variable(self, str name, Sparsity sp) -&gt; MX</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          add_variable(self, str name, Variable var)</span>



<span class="sd">        Add a variable.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          add_variable(self, str name, int n)</span>
<span class="sd">          add_variable(self, str name, Sparsity sp)</span>



<span class="sd">        Add a new variable: returns corresponding symbolic expression.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Variable const &amp;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access a variable by name</span>

<span class="sd">        variable(self, str name) -&gt; Variable</span>
<span class="sd">        variable(self, str name) -&gt; Variable</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          DaeBuilder()</span>
<span class="sd">          DaeBuilder(DaeBuilder other)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          DaeBuilder(DaeBuilder other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          DaeBuilder()</span>



<span class="sd">        Default constructor.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_DaeBuilder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_DaeBuilder</span>
<span class="n">DaeBuilder_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DaeBuilder_swigregister</span>
<span class="n">DaeBuilder_swigregister</span><span class="p">(</span><span class="n">DaeBuilder</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">XmlFile</span><span class="p">(</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      XML parser Can be used for parsing XML files into CasADi data structures.</span>



<span class="sd">    Joel Andersson</span>

<span class="sd">    C++ includes: xml_file.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XmlFile</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SharedObject</span><span class="p">,</span> <span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XmlFile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name() -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_XmlFile</span>

    <span class="k">def</span> <span class="nf">load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        load_plugin(str name)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">load_plugin</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">load_plugin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        doc(str name) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">doc</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        XmlFile()</span>
<span class="sd">        XmlFile(XmlFile other)</span>
<span class="sd">        XmlFile(str name)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_XmlFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
<span class="n">XmlFile_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_swigregister</span>
<span class="n">XmlFile_swigregister</span><span class="p">(</span><span class="n">XmlFile</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">XmlFile_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_name() -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_type_name</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">XmlFile_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    load_plugin(str name)</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_load_plugin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">XmlFile_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    doc(str name) -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">XmlFile_doc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SerializerBase</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: serializer.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SerializerBase</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SerializerBase</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_SerializerBase</span>

    <span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        pack(self, Linsol e)</span>
<span class="sd">        pack(self, std::vector&lt; casadi::Linsol,std::allocator&lt; casadi::Linsol &gt; &gt; const &amp; e)</span>
<span class="sd">        pack(self, int e)</span>
<span class="sd">        pack(self, float e)</span>
<span class="sd">        pack(self, [Sparsity] e)</span>
<span class="sd">        pack(self, Sparsity e)</span>
<span class="sd">        pack(self, [float] e)</span>
<span class="sd">        pack(self, [int] e)</span>
<span class="sd">        pack(self, [str] e)</span>
<span class="sd">        pack(self, DM e)</span>
<span class="sd">        pack(self, [DM] e)</span>
<span class="sd">        pack(self, SX e)</span>
<span class="sd">        pack(self, [SX] e)</span>
<span class="sd">        pack(self, MX e)</span>
<span class="sd">        pack(self, [MX] e)</span>
<span class="sd">        pack(self, str e)</span>
<span class="sd">        pack(self, [Function] e)</span>
<span class="sd">        pack(self, Function e)</span>
<span class="sd">        pack(self, [GenericType] e)</span>
<span class="sd">        pack(self, GenericType e)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase_pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">_SERIALIZED_SPARSITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_SPARSITY</span>
    <span class="n">_SERIALIZED_MX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_MX</span>
    <span class="n">_SERIALIZED_DM</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_DM</span>
    <span class="n">_SERIALIZED_SX</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_SX</span>
    <span class="n">_SERIALIZED_LINSOL</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_LINSOL</span>
    <span class="n">_SERIALIZED_FUNCTION</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_FUNCTION</span>
    <span class="n">_SERIALIZED_GENERICTYPE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_GENERICTYPE</span>
    <span class="n">_SERIALIZED_INT</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_INT</span>
    <span class="n">_SERIALIZED_DOUBLE</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_DOUBLE</span>
    <span class="n">_SERIALIZED_STRING</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_STRING</span>
    <span class="n">_SERIALIZED_SPARSITY_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_SPARSITY_VECTOR</span>
    <span class="n">_SERIALIZED_MX_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_MX_VECTOR</span>
    <span class="n">_SERIALIZED_DM_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_DM_VECTOR</span>
    <span class="n">_SERIALIZED_SX_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_SX_VECTOR</span>
    <span class="n">_SERIALIZED_LINSOL_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_LINSOL_VECTOR</span>
    <span class="n">_SERIALIZED_FUNCTION_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_FUNCTION_VECTOR</span>
    <span class="n">_SERIALIZED_GENERICTYPE_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_GENERICTYPE_VECTOR</span>
    <span class="n">_SERIALIZED_INT_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_INT_VECTOR</span>
    <span class="n">_SERIALIZED_DOUBLE_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_DOUBLE_VECTOR</span>
    <span class="n">_SERIALIZED_STRING_VECTOR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase__SERIALIZED_STRING_VECTOR</span>

    <span class="k">def</span> <span class="nf">type_to_string</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_to_string(casadi::SerializerBase::SerializationType type) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase_type_to_string</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">type_to_string</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">type_to_string</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        connect(self, DeserializerBase s)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        reset(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">SerializerBase_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase_swigregister</span>
<span class="n">SerializerBase_swigregister</span><span class="p">(</span><span class="n">SerializerBase</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SerializerBase_type_to_string</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    type_to_string(casadi::SerializerBase::SerializationType type) -&gt; str</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">SerializerBase_type_to_string</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DeserializerBase</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: serializer.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DeserializerBase</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DeserializerBase</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_DeserializerBase</span>

    <span class="k">def</span> <span class="nf">_pop_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::SerializerBase::SerializationType&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        _pop_type(self) -&gt; casadi::SerializerBase::SerializationType</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase__pop_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_sparsity(self) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_mx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_mx(self) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_mx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_dm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_dm(self) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_dm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_sx(self) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_linsol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Linsol&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_linsol(self) -&gt; Linsol</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_linsol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_function(self) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_generictype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::GenericType&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_generictype(self) -&gt; GenericType</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_generictype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_int(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_double(self) -&gt; float</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_string(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_sparsity_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Sparsity,std::allocator&lt; casadi::Sparsity &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_sparsity_vector(self) -&gt; [Sparsity]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_sparsity_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_mx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_mx_vector(self) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_mx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_dm_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_dm_vector(self) -&gt; [DM]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_dm_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_sx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_sx_vector(self) -&gt; [SX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_sx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_linsol_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Linsol,std::allocator&lt; casadi::Linsol &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_linsol_vector(self) -&gt; std::vector&lt; casadi::Linsol,std::allocator&lt; casadi::Linsol &gt; &gt;</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_linsol_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_function_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Function,std::allocator&lt; casadi::Function &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_function_vector(self) -&gt; [Function]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_function_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_generictype_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::GenericType,std::allocator&lt; casadi::GenericType &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_generictype_vector(self) -&gt; [GenericType]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_generictype_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_int_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_int_vector(self) -&gt; [int]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_int_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_double_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_double_vector(self) -&gt; [float]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_double_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">blind_unpack_string_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string,std::allocator&lt; std::string &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        blind_unpack_string_vector(self) -&gt; [str]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_blind_unpack_string_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Sparsity&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_sparsity(self) -&gt; Sparsity</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_mx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_mx(self) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_mx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_dm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_dm(self) -&gt; DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_dm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Matrix&lt; casadi::SXElem &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_sx(self) -&gt; SX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_linsol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Linsol&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_linsol(self) -&gt; Linsol</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_linsol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_function(self) -&gt; Function</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_generictype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::GenericType&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_generictype(self) -&gt; GenericType</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_generictype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_int(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_double(self) -&gt; float</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_string(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_sparsity_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Sparsity,std::allocator&lt; casadi::Sparsity &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_sparsity_vector(self) -&gt; [Sparsity]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_sparsity_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_mx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_mx_vector(self) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_mx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_dm_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; double &gt;,std::allocator&lt; casadi::Matrix&lt; double &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_dm_vector(self) -&gt; [DM]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_dm_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_sx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Matrix&lt; casadi::SXElem &gt;,std::allocator&lt; casadi::Matrix&lt; casadi::SXElem &gt; &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_sx_vector(self) -&gt; [SX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_sx_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_linsol_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Linsol,std::allocator&lt; casadi::Linsol &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_linsol_vector(self) -&gt; std::vector&lt; casadi::Linsol,std::allocator&lt; casadi::Linsol &gt; &gt;</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_linsol_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_function_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::Function,std::allocator&lt; casadi::Function &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_function_vector(self) -&gt; [Function]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_function_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_generictype_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::GenericType,std::allocator&lt; casadi::GenericType &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_generictype_vector(self) -&gt; [GenericType]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_generictype_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_int_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi_int,std::allocator&lt; casadi_int &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_int_vector(self) -&gt; [int]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_int_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_double_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double,std::allocator&lt; double &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_double_vector(self) -&gt; [float]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_double_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack_string_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string,std::allocator&lt; std::string &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        unpack_string_vector(self) -&gt; [str]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_unpack_string_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        connect(self, SerializerBase s)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        reset(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="nb">type</span> <span class="o">=</span> <span class="n">SerializerBase</span><span class="o">.</span><span class="n">type_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pop_type</span><span class="p">())</span>
      <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;blind_unpack_&quot;</span><span class="o">+</span><span class="nb">type</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">f</span><span class="p">()</span>

<span class="n">DeserializerBase_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">DeserializerBase_swigregister</span>
<span class="n">DeserializerBase_swigregister</span><span class="p">(</span><span class="n">DeserializerBase</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StringSerializer</span><span class="p">(</span><span class="n">SerializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: serializer.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SerializerBase</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">StringSerializer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SerializerBase</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">StringSerializer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        StringSerializer(dict opts)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_StringSerializer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_StringSerializer</span>

    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns a string that holds the serialized objects.</span>

<span class="sd">          encode(self) -&gt; str</span>


<span class="sd">        As a side effect, this method clears the internal buffer</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">StringSerializer_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">StringSerializer_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">StringSerializer_swigregister</span>
<span class="n">StringSerializer_swigregister</span><span class="p">(</span><span class="n">StringSerializer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">FileSerializer</span><span class="p">(</span><span class="n">SerializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: serializer.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SerializerBase</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FileSerializer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SerializerBase</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FileSerializer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Advanced serialization of CasADi objects.</span>

<span class="sd">          FileSerializer(str fname, dict opts)</span>


<span class="sd">        StringSerializer, FileDeserializer</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_FileSerializer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_FileSerializer</span>
<span class="n">FileSerializer_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FileSerializer_swigregister</span>
<span class="n">FileSerializer_swigregister</span><span class="p">(</span><span class="n">FileSerializer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StringDeserializer</span><span class="p">(</span><span class="n">DeserializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: serializer.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DeserializerBase</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">StringDeserializer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DeserializerBase</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">StringDeserializer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Advanced deserialization of CasADi objects.</span>

<span class="sd">          StringDeserializer(str string)</span>


<span class="sd">        StringDeserializer</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_StringDeserializer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_StringDeserializer</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the string to deserialize objects from.</span>

<span class="sd">        decode(self, str string)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">StringDeserializer_decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">StringDeserializer_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">StringDeserializer_swigregister</span>
<span class="n">StringDeserializer_swigregister</span><span class="p">(</span><span class="n">StringDeserializer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">FileDeserializer</span><span class="p">(</span><span class="n">DeserializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: serializer.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DeserializerBase</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FileDeserializer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">DeserializerBase</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FileDeserializer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Advanced deserialization of CasADi objects.</span>

<span class="sd">          FileDeserializer(str fname)</span>


<span class="sd">        FileSerializer</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_FileDeserializer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_FileDeserializer</span>
<span class="n">FileDeserializer_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">FileDeserializer_swigregister</span>
<span class="n">FileDeserializer_swigregister</span><span class="p">(</span><span class="n">FileDeserializer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Opti</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      A simplified interface for NLP modeling/solving.</span>



<span class="sd">    This class offers a view with model description facilities The API is</span>
<span class="sd">    guaranteed to be stable.</span>

<span class="sd">    Example NLP:</span>

<span class="sd">    ::</span>

<span class="sd">        opti = casadi.Opti();</span>

<span class="sd">        x = opti.variable();</span>
<span class="sd">        y = opti.variable();</span>

<span class="sd">        opti.minimize(  (y-x^2)^2   );</span>
<span class="sd">        opti.subject_to( x^2+y^2==1 );</span>
<span class="sd">        opti.subject_to(     x+y&gt;=1 );</span>

<span class="sd">        opti.solver(&#39;ipopt&#39;);</span>
<span class="sd">        sol = opti.solve();</span>

<span class="sd">        sol.value(x)</span>
<span class="sd">        sol.value(y)</span>



<span class="sd">    Example parametric NLP:</span>

<span class="sd">    ::</span>

<span class="sd">        opti = casadi.Opti();</span>

<span class="sd">        x = opti.variable(2,1);</span>
<span class="sd">        p = opti.parameter();</span>

<span class="sd">        opti.minimize(  (p*x(2)-x(1)^2)^2   );</span>
<span class="sd">        opti.subject_to( 1&lt;=sum(x)&lt;=2 );</span>

<span class="sd">        opti.solver(&#39;ipopt&#39;);</span>

<span class="sd">        opti.set_value(p, 3);</span>
<span class="sd">        sol = opti.solve();</span>
<span class="sd">        sol.value(x)</span>

<span class="sd">        opti.set_value(p, 5);</span>
<span class="sd">        sol = opti.solve();</span>
<span class="sd">        sol.value(x)</span>



<span class="sd">    Joris Gillis, Erik Lambrechts, Joel Andersson</span>

<span class="sd">    C++ includes: optistack.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Opti</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">,</span> <span class="n">SharedObject</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Opti</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a decision variable (symbol)</span>

<span class="sd">          _variable(self, int n, int m, str attribute) -&gt; MX</span>


<span class="sd">        The order of creation matters. The order will be reflected in the</span>
<span class="sd">        optimization problem. It is not required for decision variables to actualy</span>
<span class="sd">        appear in the optimization problem.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        n:  number of rows (default 1)</span>

<span class="sd">        m:  number of columnss (default 1)</span>

<span class="sd">        attribute:  &#39;full&#39; (default) or &#39;symmetric&#39;</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Create a parameter (symbol); fixed during optimization.</span>

<span class="sd">          _parameter(self, int n, int m, str attribute) -&gt; MX</span>


<span class="sd">        The order of creation does not matter. It is not required for parameter to</span>
<span class="sd">        actualy appear in the optimization problem. Parameters that do appear, must</span>
<span class="sd">        be given a value before the problem can be solved.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        n:  number of rows (default 1)</span>

<span class="sd">        m:  number of columnss (default 1)</span>

<span class="sd">        attribute:  &#39;full&#39; (default) or &#39;symmetric&#39;</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set objective.</span>

<span class="sd">          minimize(self, MX f)</span>


<span class="sd">        Objective must be a scalar. Default objective: 0 When method is called</span>
<span class="sd">        multiple times, the last call takes effect</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_subject_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Clear constraints.</span>

<span class="sd">          _subject_to(self)</span>
<span class="sd">          _subject_to(self, MX g)</span>
<span class="sd">          _subject_to(self, [MX] g)</span>




<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          _subject_to(self)</span>



<span class="sd">        Clear constraints.</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          _subject_to(self, MX g)</span>
<span class="sd">          _subject_to(self, [MX] g)</span>



<span class="sd">        Add constraints.</span>

<span class="sd">        Examples:</span>

<span class="sd">        ::</span>

<span class="sd">          * \\begin{itemize}</span>
<span class="sd">          * opti.subject_to( sqrt(x+y) &gt;= 1);</span>
<span class="sd">          * opti.subject_to( sqrt(x+y) &gt; 1)}: same as above</span>
<span class="sd">          * opti.subject_to( 1&lt;= sqrt(x+y) )}: same as above</span>
<span class="sd">          * opti.subject_to( 5*x+y==1 )}: equality</span>
<span class="sd">          *</span>
<span class="sd">          * Python</span>
<span class="sd">          * opti.subject_to([x*y&gt;=1,x==3])</span>
<span class="sd">          * opti.subject_to(opti.bounded(0,x,1))</span>
<span class="sd">          *</span>
<span class="sd">          * MATLAB</span>
<span class="sd">          * opti.subject_to({x*y&gt;=1,x==3})</span>
<span class="sd">          * opti.subject_to( 0&lt;=x&lt;=1 )</span>
<span class="sd">          * </span>



<span class="sd">        Related functionalities: opti.lbg,opti.g,opti.ubg represent the vector of</span>
<span class="sd">        flattened constraints</span>

<span class="sd">        opti.debug.show_infeasibilities() may be used to inspect which constraints</span>
<span class="sd">        are violated</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__subject_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set a solver.</span>

<span class="sd">          solver(self, str solver, dict plugin_options, dict solver_options)</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        solver:  any of the nlpsol plugins can be used here In practice, not all</span>
<span class="sd">        nlpsol plugins may be supported yet</span>

<span class="sd">        options:  passed on to nlpsol plugin No stability can be guaranteed about</span>
<span class="sd">        this part of the API</span>

<span class="sd">        options:  to be passed to nlpsol solver No stability can be guaranteed about</span>
<span class="sd">        this part of the API</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set initial guess for decision variables</span>

<span class="sd">          set_initial(self, [MX] assignments)</span>
<span class="sd">          set_initial(self, MX x, DM v)</span>


<span class="sd">        ::</span>

<span class="sd">          * opti.set_initial(x, 2)</span>
<span class="sd">          * opti.set_initial(10*x(1), 2)</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_set_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Set value of parameter.</span>

<span class="sd">          set_value(self, [MX] assignments)</span>
<span class="sd">          set_value(self, MX x, DM v)</span>


<span class="sd">        Each parameter must be given a value before &#39;solve&#39; can be called</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::OptiSol&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Crunch the numbers; solve the problem.</span>

<span class="sd">        solve(self) -&gt; OptiSol</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solve_limited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::OptiSol&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Crunch the numbers; solve the problem.</span>

<span class="sd">          solve_limited(self) -&gt; OptiSol</span>


<span class="sd">        Allows the solver to return without error when an iteration or time limit is</span>
<span class="sd">        reached</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_solve_limited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::native_DM&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Obtain value of expression at the current value</span>

<span class="sd">          value(self, DM x, [MX] values) -&gt; double</span>
<span class="sd">          value(self, SX x, [MX] values) -&gt; double</span>
<span class="sd">          value(self, MX x, [MX] values) -&gt; double</span>


<span class="sd">        In regular mode, teh current value is the converged solution In debug mode,</span>
<span class="sd">        the value can be non-converged</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        values:  Optional assignment expressions (e.g. x==3) to overrule the current</span>
<span class="sd">        value</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get statistics.</span>

<span class="sd">          stats(self) -&gt; dict</span>


<span class="sd">        nlpsol stats are passed as-is. No stability can be guaranteed about this</span>
<span class="sd">        part of the API</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">return_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get return status of solver passed as-is from nlpsol No stability can be</span>

<span class="sd">          return_status(self) -&gt; str</span>

<span class="sd">        guaranteed about this part of the API.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_return_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">initial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get assignment expressions for initial values</span>

<span class="sd">        initial(self) -&gt; [MX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">value_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get assignment expressions for latest values</span>

<span class="sd">        value_variables(self) -&gt; [MX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_value_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">value_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        value_parameters(self) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_value_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          get the dual variable</span>

<span class="sd">          dual(self, MX m) -&gt; MX</span>


<span class="sd">        m must be a constraint expression. The returned value is still a symbolic</span>
<span class="sd">        expression. Use value on it to obtain the numerical value.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_nx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of (scalarised) decision variables.</span>

<span class="sd">        _nx(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__nx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of (scalarised) parameters.</span>

<span class="sd">        _np(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_ng</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of (scalarised) constraints.</span>

<span class="sd">        _ng(self) -&gt; int</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__ng</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all (scalarised) decision variables as a symbolic column vector.</span>

<span class="sd">        _x(self) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all (scalarised) parameters as a symbolic column vector.</span>

<span class="sd">        _p(self) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all (scalarised) constraint expressions as a column vector.</span>

<span class="sd">        _g(self) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get objective expression.</span>

<span class="sd">        _f(self) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_lbg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all (scalarised) bounds on constraints as a column vector.</span>

<span class="sd">        _lbg(self) -&gt; MX</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__lbg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_ubg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        _ubg(self) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__ubg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_lam_g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get all (scalarised) dual variables as a symbolic column vector.</span>

<span class="sd">          _lam_g(self) -&gt; MX</span>


<span class="sd">        Useful for obtaining the Lagrange Hessian:</span>

<span class="sd">        ::</span>

<span class="sd">          * sol.value(hessian(opti.f+opti.lam_g&#39;*opti.g,opti.x)) % MATLAB</span>
<span class="sd">          * sol.value(hessian(opti.f+dot(opti.lam_g,opti.g),opti.x)[0]) # Python</span>
<span class="sd">          * </span>






<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__lam_g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">to_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          to_function(self, str name, [MX] args, [MX] res, dict opts) -&gt; Function</span>
<span class="sd">          to_function(self, str name, dict:MX dict, [str] name_in, [str] name_out, dict opts) -&gt; Function</span>
<span class="sd">          to_function(self, str name, [MX] args, [MX] res, [str] name_in, [str] name_out, dict opts) -&gt; Function</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          to_function(self, str name, dict:MX dict, [str] name_in, [str] name_out, dict opts)</span>
<span class="sd">          to_function(self, str name, [MX] args, [MX] res, [str] name_in, [str] name_out, dict opts)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          to_function(self, str name, [MX] args, [MX] res, dict opts)</span>



<span class="sd">        Create a CasADi Function from the Opti solver.</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_to_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">bounded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        bounded(MX lb, MX expr, MX ub) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_bounded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">bounded</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">bounded</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::OptiAdvanced&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a copy with advanced functionality.</span>

<span class="sd">          _debug(self) -&gt; OptiAdvanced</span>


<span class="sd">        You get access to more methods, but you have no guarantees about API</span>
<span class="sd">        stability</span>

<span class="sd">        The copy is effectively a deep copy: Updating the state of the copy does not</span>
<span class="sd">        update the original.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_advanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::OptiAdvanced&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a copy with advanced functionality.</span>

<span class="sd">          _advanced(self) -&gt; OptiAdvanced</span>


<span class="sd">        You get access to more methods, but you have no guarantees about API</span>
<span class="sd">        stability</span>

<span class="sd">        The copy is effectively a deep copy: Updating the state of the copy does not</span>
<span class="sd">        update the original.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti__advanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Opti&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a copy of the.</span>

<span class="sd">          copy(self) -&gt; Opti</span>


<span class="sd">        The copy is effectively a deep copy: Updating the state of the copy does not</span>
<span class="sd">        update the original.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">update_user_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          update_user_dict(self, MX m, dict meta)</span>
<span class="sd">          update_user_dict(self, [MX] m, dict meta)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          update_user_dict(self, [MX] m, dict meta)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          update_user_dict(self, MX m, dict meta)</span>



<span class="sd">        add user data Add arbitrary data in the form of a dictionary to symbols or</span>
<span class="sd">        constraints</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_update_user_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">user_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get user data.</span>

<span class="sd">        user_dict(self, MX m) -&gt; dict</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_user_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Readable name of the class.</span>

<span class="sd">        type_name(self) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print representation.</span>

<span class="sd">        disp(self, bool more)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string representation.</span>

<span class="sd">        str(self, bool more) -&gt; str</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">callback_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Helper methods for callback()</span>

<span class="sd">          callback_class(self)</span>
<span class="sd">          callback_class(self, OptiCallback callback)</span>


<span class="sd">        Do not use directly.</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_callback_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">advanced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_advanced</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lam_g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lam_g</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lbg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lbg</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ubg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ubg</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nx</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">np</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_np</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ng</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ng</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">casadi_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_casadi_solver</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">sys</span>
      <span class="kn">import</span> <span class="nn">os</span>
      <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stacktrace&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;file&quot;</span><span class="p">:</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">),</span><span class="s2">&quot;line&quot;</span><span class="p">:</span><span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">}}</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">update_user_dict</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="kn">import</span> <span class="nn">sys</span>
      <span class="kn">import</span> <span class="nn">os</span>
      <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stacktrace&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;file&quot;</span><span class="p">:</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">),</span><span class="s2">&quot;line&quot;</span><span class="p">:</span><span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">}}</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">update_user_dict</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">subject_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subject_to</span><span class="p">()</span>
      <span class="kn">import</span> <span class="nn">sys</span>
      <span class="kn">import</span> <span class="nn">os</span>
      <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stacktrace&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;file&quot;</span><span class="p">:</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">),</span><span class="s2">&quot;line&quot;</span><span class="p">:</span><span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">}}</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subject_to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">update_user_dict</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">meta</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">ret</span>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">fh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_class</span><span class="p">();</span>
        <span class="k">return</span>
      <span class="k">class</span> <span class="nc">OptiCallbackHelper</span><span class="p">(</span><span class="n">OptiCallback</span><span class="p">):</span>
          <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
            <span class="n">OptiCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>

          <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">_fh</span> <span class="o">=</span> <span class="n">fh</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_cb</span> <span class="o">=</span> <span class="n">OptiCallbackHelper</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">callback_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">);</span>


    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fh</span><span class="p">)</span>




    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">          Opti(str problem_type)</span>
<span class="sd">          Opti(Opti other)</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Opti(Opti other)</span>



<span class="sd">        .............</span>


<span class="sd">        .......</span>

<span class="sd">        ::</span>

<span class="sd">          Opti(str problem_type)</span>



<span class="sd">        Create Opti Context.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        problem_type:  of optimization &#39;nlp&#39; or &#39;conic&#39; (default nlp)</span>



<span class="sd">        .............</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_Opti</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_Opti</span>
<span class="n">Opti_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_swigregister</span>
<span class="n">Opti_swigregister</span><span class="p">(</span><span class="n">Opti</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Opti_bounded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    bounded(MX lb, MX expr, MX ub) -&gt; MX</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">Opti_bounded</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="n">OPTI_GENERIC_EQUALITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_GENERIC_EQUALITY</span>
<span class="n">OPTI_GENERIC_INEQUALITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_GENERIC_INEQUALITY</span>
<span class="n">OPTI_EQUALITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_EQUALITY</span>
<span class="n">OPTI_INEQUALITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_INEQUALITY</span>
<span class="n">OPTI_DOUBLE_INEQUALITY</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_DOUBLE_INEQUALITY</span>
<span class="n">OPTI_PSD</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_PSD</span>
<span class="n">OPTI_UNKNOWN</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_UNKNOWN</span>
<span class="n">OPTI_VAR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_VAR</span>
<span class="n">OPTI_PAR</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_PAR</span>
<span class="n">OPTI_DUAL_G</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OPTI_DUAL_G</span>
<span class="k">class</span> <span class="nc">IndexAbstraction</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    IndexAbstraction() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IndexAbstraction</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IndexAbstraction</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IndexAbstraction_start_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">IndexAbstraction_start_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;stop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IndexAbstraction_stop_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">IndexAbstraction_stop_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        IndexAbstraction()</span>
<span class="sd">        IndexAbstraction(IndexAbstraction other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_IndexAbstraction</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_IndexAbstraction</span>
<span class="n">IndexAbstraction_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">IndexAbstraction_swigregister</span>
<span class="n">IndexAbstraction_swigregister</span><span class="p">(</span><span class="n">IndexAbstraction</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MetaCon</span><span class="p">(</span><span class="n">IndexAbstraction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    MetaCon() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">IndexAbstraction</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MetaCon</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">IndexAbstraction</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MetaCon</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;original&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_original_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">original</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_original_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;canon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_canon_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">canon</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_canon_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_type_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_type_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;lb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_lb_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_lb_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;ub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_ub_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_ub_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_n_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_n_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;flipped&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_flipped_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">flipped</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_flipped_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;dual_canon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_dual_canon_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">dual_canon</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_dual_canon_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;dual&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_dual_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">dual</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_dual_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;extra&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_extra_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_extra_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        MetaCon()</span>
<span class="sd">        MetaCon(MetaCon other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_MetaCon</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_MetaCon</span>
<span class="n">MetaCon_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaCon_swigregister</span>
<span class="n">MetaCon_swigregister</span><span class="p">(</span><span class="n">MetaCon</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MetaVar</span><span class="p">(</span><span class="n">IndexAbstraction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">    MetaVar() -&gt; </span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">IndexAbstraction</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MetaVar</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">IndexAbstraction</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MetaVar</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;attribute&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_attribute_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_attribute_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_n_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_n_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_m_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_m_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_type_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_type_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_count_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_count_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_i_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_i_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;active_i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_active_i_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">active_i</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_active_i_get</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;extra&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_extra_get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_extra_get</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        MetaVar()</span>
<span class="sd">        MetaVar(MetaVar other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_MetaVar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_MetaVar</span>
<span class="n">MetaVar_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">MetaVar_swigregister</span>
<span class="n">MetaVar_swigregister</span><span class="p">(</span><span class="n">MetaVar</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OptiCallback</span><span class="p">(</span><span class="n">_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: optistack.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OptiCallback</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OptiCallback</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        OptiCallback(self)</span>
<span class="sd">        OptiCallback(self, OptiCallback obj)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">OptiCallback</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_OptiCallback</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        call(self, int i)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiCallback_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_OptiCallback</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_casadi</span><span class="o">.</span><span class="n">disown_OptiCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="n">OptiCallback_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiCallback_swigregister</span>
<span class="n">OptiCallback_swigregister</span><span class="p">(</span><span class="n">OptiCallback</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OptiAdvanced</span><span class="p">(</span><span class="n">Opti</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ includes: optistack.hpp </span>




<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Opti</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OptiAdvanced</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Opti</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OptiAdvanced</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_OptiAdvanced</span>

    <span class="k">def</span> <span class="nf">_casadi_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Function&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the underlying CasADi solver of the Opti stack.</span>

<span class="sd">        _casadi_solver(self) -&gt; Function</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced__casadi_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">is_parametric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          return true if expression is only dependant on Opti parameters, not</span>

<span class="sd">          is_parametric(self, MX expr) -&gt; bool</span>

<span class="sd">        variables</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_is_parametric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">symvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get symbols present in expression.</span>

<span class="sd">          symvar(self) -&gt; [MX]</span>
<span class="sd">          symvar(self, MX expr) -&gt; [MX]</span>
<span class="sd">          symvar(self, MX expr, casadi::VariableType type) -&gt; [MX]</span>


<span class="sd">        Returned vector is ordered according to the order of variable()/parameter()</span>
<span class="sd">        calls used to create the variables</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_symvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">canon_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MetaCon&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpret an expression (for internal use only)</span>

<span class="sd">        canon_expr(self, MX expr) -&gt; MetaCon</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_canon_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MetaVar&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get meta-data of symbol (for internal use only)</span>

<span class="sd">        get_meta(self, MX m) -&gt; MetaVar</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_meta_con</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MetaCon&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get meta-data of symbol (for internal use only)</span>

<span class="sd">        get_meta_con(self, MX m) -&gt; MetaCon</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_get_meta_con</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set meta-data of an expression.</span>

<span class="sd">        set_meta(self, MX m, MetaVar meta)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_set_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">set_meta_con</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set meta-data of an expression.</span>

<span class="sd">        set_meta_con(self, MX m, MetaCon meta)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_set_meta_con</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">assert_active_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        assert_active_symbol(self, MX m)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_assert_active_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">active_symvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        active_symvar(self, casadi::VariableType type) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_active_symvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">active_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::DM,std::allocator&lt; casadi::DM &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        active_values(self, casadi::VariableType type) -&gt; [DM]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_active_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">x_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        x_lookup(self, int i) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_x_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">g_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        g_lookup(self, int i) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_g_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">x_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        x_describe(self, int i) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_x_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">g_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        g_describe(self, int i) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_g_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        describe(self, MX x, int indent) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">show_infeasibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        show_infeasibilities(self, float tol)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_show_infeasibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solve_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        solve_prepare(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solve_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solve_actual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DMDict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        solve_actual(self, dict:DM args) -&gt; dict:DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solve_actual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DMDict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        arg(self) -&gt; dict:DM</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">res</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::DMDict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        res(self) -&gt; dict:DM</span>
<span class="sd">        res(self, dict:DM res)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_res</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        constraints(self) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::MX&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        objective(self) -&gt; MX</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">baked_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::OptiAdvanced&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        baked_copy(self) -&gt; OptiAdvanced</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_baked_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">assert_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        assert_empty(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_assert_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">bake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix the structure of the optimization problem.</span>

<span class="sd">        bake(self)</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_bake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;problem_dirty_&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_problem_dirty__get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">problem_dirty_</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_problem_dirty__get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mark_problem_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        mark_problem_dirty(self, bool flag)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_mark_problem_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">problem_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        problem_dirty(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_problem_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;solver_dirty_&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solver_dirty__get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">solver_dirty_</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solver_dirty__get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mark_solver_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        mark_solver_dirty(self, bool flag)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_mark_solver_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solver_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        solver_dirty(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solver_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">__swig_getmethods__</span><span class="p">[</span><span class="s2">&quot;solved_&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solved__get</span>
    <span class="k">if</span> <span class="n">_newclass</span><span class="p">:</span>
        <span class="n">solved_</span> <span class="o">=</span> <span class="n">_swig_property</span><span class="p">(</span><span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solved__get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mark_solved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        mark_solved(self, bool flag)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_mark_solved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">solved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        solved(self) -&gt; bool</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_solved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">assert_solved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        assert_solved(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_assert_solved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">assert_baked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        assert_baked(self)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_assert_baked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">instance_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi_int&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        instance_number(self) -&gt; int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_instance_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        OptiAdvanced(OptiAdvanced other)</span>
<span class="sd">        OptiAdvanced(Opti x)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_OptiAdvanced</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
<span class="n">OptiAdvanced_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiAdvanced_swigregister</span>
<span class="n">OptiAdvanced_swigregister</span><span class="p">(</span><span class="n">OptiAdvanced</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OptiSol</span><span class="p">(</span><span class="n">PrintableCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      A simplified interface for NLP modeling/solving.</span>



<span class="sd">    This class offers a view with solution retrieval facilities The API is</span>
<span class="sd">    guaranteed to be stable.</span>

<span class="sd">    Joris Gillis, Erik Lambrechts</span>

<span class="sd">    C++ includes: optistack.hpp </span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__swig_setmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_setmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_setmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">_swig_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OptiSol</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">__swig_getmethods__</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintableCommon</span><span class="p">]:</span>
        <span class="n">__swig_getmethods__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="s1">&#39;__swig_getmethods__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_swig_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OptiSol</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        type_name(self) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        disp(self, bool more)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        str(self, bool more) -&gt; str</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::native_DM&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Obtain value of expression at the current value</span>

<span class="sd">          value(self, DM x, [MX] values) -&gt; double</span>
<span class="sd">          value(self, SX x, [MX] values) -&gt; double</span>
<span class="sd">          value(self, MX x, [MX] values) -&gt; double</span>


<span class="sd">        In regular mode, teh current value is the converged solution In debug mode,</span>
<span class="sd">        the value can be non-converged</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>

<span class="sd">        values:  Optional assignment expressions (e.g. x==3) to overrule the current</span>
<span class="sd">        value</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">value_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get assignment expressions for the optimal solution</span>

<span class="sd">        value_variables(self) -&gt; [MX]</span>





<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_value_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">value_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; casadi::MX,std::allocator&lt; casadi::MX &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        value_parameters(self) -&gt; [MX]</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_value_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Dict&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get statistics.</span>

<span class="sd">          stats(self) -&gt; dict</span>


<span class="sd">        nlpsol stats are passed as-is. No stability can be guaranteed about this</span>
<span class="sd">        part of the API</span>




<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_opti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;casadi::Opti&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        _opti(self) -&gt; Opti</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol__opti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">opti</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opti</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">()</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        OptiSol(OptiSol other)</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">new_OptiSol</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span> <span class="o">=</span> <span class="n">this</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">delete_OptiSol</span>
<span class="n">OptiSol_swigregister</span> <span class="o">=</span> <span class="n">_casadi</span><span class="o">.</span><span class="n">OptiSol_swigregister</span>
<span class="n">OptiSol_swigregister</span><span class="p">(</span><span class="n">OptiSol</span><span class="p">)</span>

<span class="c1"># This file is compatible with both classic and new-style classes.</span>


</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Marco Aurelio S. de Aguiar

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>